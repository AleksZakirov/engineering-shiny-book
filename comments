#big-shiny.Rmd

One of the goal of this book is to present you a methodology and toolkit that will help you reduce this form of complexity. 

<!-- COMMENT: Here is the description of complexity, not of the content of the book or tools to help to deal with -->
<!-- For example, we will talk about a design / prototype / build / secure / deploy framework, which helps you reduce the complexity of implementing and maintaining new application features.  -->

<!-- We are going to be talking a lot about the `{golem}` package, which provides a toolkit for reducing the cognitive load of handling complexity in large Shiny applications.  -->
<!-- For example, creating a new Shiny module requires a strict structure to be followed.  -->
<!-- You can always try to remember all steps to create a module and code it from scratch, but this method has an important cognitive load and is very error prone.  -->
<!-- Another way is to copy and paste an existing module and adapt it, which is, as any copy and paste, likely to lead to errors.  -->
<!-- Or, there is the `{golem}` way, in which you rely on a robust tool to build the foundations for a new module. -->

<!-- Another benefit of adopting automation for common application components is that it ensures you are following the same convention each time, at each step.  -->
<!-- Conventions are crucial when it comes to building and maintaining complex systems: by imposing a formalized structure for a piece of code, it enhances readability, lessens the learning curve, and reduces the risk for typos and/or copy and paste errors.  -->

But this complexify the interface for the users who have to perform another action in addition to changing their inputs.  

<!-- COMMENT: This was an example, no need to add a solution that is explained later. -->
<!-- We will argue somewhere else in the book that not enough reactivity is better than too much reactivity, as the latter increases computation time, and relies on the assumption that the user makes the right action on the first try. -->

That solution increases implementation complexity, while leaving it as is requires the user to think about whether or not the starting date is before the ending date, thus increasing the interface complexity.

<!-- COMMENT: The solution should be the starting text of the following paragraph -->
<!-- So what should we do? It is up to you: deciding where to draw the line between interface & implementation complexity very much depends on the kind of project you are working on, and on the kind of users that will use your app.  -->
<!-- Things that you can assess here is the ease of working on implementation of feature (for your team), how much your app will be used, how frequently, by what kind of users...  -->
<!-- Drawing the line between the two is not the simplest thing on earth, and requires to restrain yourself from implementing too much, and still create an application that is easy to use.  -->

So, as The Clash said, "what are we gonna do now?" 
<!-- COMMENT: I do not see the parallel with passing twice into a piece of code -->
<!-- You might have heard: "if you copy and paste a piece of code twice, you should write a function".  -->
<!-- ?? We can modify this sentence a little: "if you pass in a piece of code twice, .. ??" -->

In other words, production-grade Shiny apps requires working with a software engineering mindset, which is not always an easy task in the R world. 
<!-- COMMENT: There are many academics using R in production, not for software building, but for code that will help decision-making. Production quality is a concern. -->
<!-- R comes from the land of the academics and is still used as an "experimentation tool", where production quality is one of the least concerns.  -->