# Using JavaScript {#optimjs}

In its core, building a Shiny app is building a JavaScript app that can talk with an R session. 
This process is hidden from the common Shiny developer, who usually works on everything from R. 
In a sense,  everything is done with R, but when you are writting UI elements in Shiny what you are actually doing is building a series of HTML tags, which are then linked to JavaScript events. 
Later on, when the app is running, these JavaScript events will communicate with R, in the sense that they will send data to R, and receive data from R. 
Most of the time, when this JavaScript events are receiving data, that also means that they modify the page the user sees.
What happens under the hood is a little bit complex and out of scope for this book, but the general idea is there: R talks to your browser through a websocket, and this very same browser talks to R through the same websocket.

// TODO: create here a simple Flowchart 
// R -> (WebSocket) -> JS 
// R <- (WebSocket) <- JS 

It's important to note here that the communication happens in both ways: from R to JavaScript, and from JavaScript to R. 
In fact, when we write a piece of code like `sliderInput("plop", "this", 1, 10, 5)`, what we are doing is creating a binding between JavaScript and R, where JavaScript listens to any event happening in the browser on the slider with the id `"plop"`, and whenever JavaScript detects that something happens to this element, something (most of the time its value) is sent back to R. 
With `output$bla <- renderPlot({})`, what we are doing is making the two communicates the other way around: we are telling JavaScript to listen to any incoming data from R for the `id` `"bla"`, and whenever JavaScript sees incoming data from R, it puts it into the proper HTML tag. 

So even if everything happens in R, we __are__ writting a web (so HTML, CSS and JavaScript) application, from R. 
Once you've realized that, the possibilities are endless: in fact almost anything doable in a web app can be done in Shiny. 
What this also implies is that getting (even a little bit) better at writting HTML, CSS and especially JavaScript will make your app better, lighter, and more efficient. 
Indeed, JavaScript is a language which has been designed to interact with a web page: change element appearances, hide and show things, cick somewhere, show alerts and prompts... 
What that means is that knowing just enought JavaScript can improve the quality of your app: especially when you've been using R to build some complex UI renderings: think conditional pannels, simulating a button click from the server, hide and show elements...
All these things are good examples of where you should be using JavaScript instead of building more or less complex `renderUI` or `insertUI` patterns in your server.

This is what this part aims to do: giving you just enough JavaScript knowledge to lighten your Shiny App, and improve the global user and developer experience.
In this part, we'll first see some JavaScript basics, which can be used "client-side" only, or later in R & JS communication, which is what we'll see next: how to make R and JavaScript communicate with each other. In this part, we'll also explore common patterns for JavaScript in Shiny. 
Finally, we'll quickly present some of the functions from `{golem}` which are built on top of JavaScript. 

> Note that this chapter is not supposed to be a comprehensive JavaScript course. 
External resources are linked at the botton of this chapter if you want to dive deeper into JavaScript.

## A quick introduction to JavaScript

JavaScript is a programming language which has been designed to work in the browser^[
You can now work with JavaScript in a server with Node.JS, but this is out of scope of this book. 
See linked resources to learn more.
].
JavaScript, as R, can be used as a functional language, but most of what we do in JavaScript is done in an object-oriented way. 
You have to think of a web page as a tree, where the top of the webpage is the root node, and every element in the page is a node in this tree. 
And of course, you can work on any of these HTML node with JavaScript: modify it, bind and/or listen to events, hide and show it...

JavaScript code can be add to your app "as-is", in other words just as if you were creating a web app: with an html `script` tag.

If you're working with `{golem}`, including a JavaScript file is performed using two functions: 

+ `golem::add_js_file("name")`, which adds a standard JavaScript file, i.e. one which is not meant to be used to communicate with R.
We'll see in the first part of this chapter how to add JavaScript code there.
+ `golem::add_js_handler("name")`, which creates a file with a skeleton for shiny handlers. 
We'll see this second type of elements in the `JavaScript <-> Shiny communication` part.

### Understanding div, class, and id

Consider this piece of code:

```{r}
library(shiny)
fluidPage(
  titlePanel("Hello Shiny"), 
  actionButton("go", "go")
)
```

This `{shiny}` code creates a piece of HTML code, which contains three nodes: a `div`, which is a container, an `h2`, which is a level two header, a button which has an id and a class.
Both are included into the `div`. 
Let's detail what we've got here:

+ HTML tags, which are the building blocks of the "tree": here, `div`, `h2` and `button` are HTML tags.
+ The button has an `id`, which is short for "identifier". 
This id has to to be unique: it's this reference that allows to spot this exact element, and more specifically it's this id that allows JavaScript and R to talk to each other: if you click on a button, you have to be sure that it's this specific button, and only that one.
+ Elements can have a class, which can apply to multiple elements. 
This can be used in JavaScript, but it's also very useful for styling elements in CSS. 

### About jQuery & jQuery selectors

The `jQuery` framework is natively included in Shiny.

> jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use API that works across a multitude of browsers. 

jQuery is a very (like, very) popular JavaScript library which is designed to manipulate the DOM, its events and its elements. 
It can be used to do a lot of things, like hide and show, change class, click somewhere... And to be able to do that, it comes with the notion of selectors, which will be put between `$()`.
You can use:

+ `#plop` to refer to the element with the id `plop`

+ `.pouet` to refer to element(s) of class `pouet`

+ `"button:contains('this')"` to refer to the buttons with a text containing `'this'`

You can also use special HTML attributes.
For example:

``` html
<a href = "https://thinkr.fr" data-value = "panel2">ThinkR</a>
```

contains the `href` & `data-value` attributes.
You can refer to these with `[]` after the tag name.

+ `a[href = "https://thinkr.fr"]` refers to link(s) with `href` being `https://thinkr.fr`

+ `a[data-value="panel2"]` refers to link(s) with  `data-value` being `"panel2"`

### Common JavaScript patterns for Shiny

It's hard to give an exhaustive list of what you can do with JavaScript inside Shiny. 
As a Shiny app is part JavaScript, part R, once you've got a good grasp of JavaScript you can quickly enhance any of your applications.
That being said, there are some common things that can be done that would allow you to immedialy optimise your application: i.e. small JavaScript functions that can will prevent you from writing complexe algorithmic logic in your application server. 

+ `$('#id').show();` and `$('#id').hide();` show and hide one or more elements that match the given selector.
For example, this can be use to replace: 

```{r eval = FALSE}
output$ui <- renderUI({
  if (this){
    tags(...)
  } else {
    NULL
  }
})
```

+ `alert("message")` uses the built-in alert-box mechanism from the user's browser. 
It works well as it relies on the browser instead of R. 
For example, you can use this functionality to replace a call to `{shinyalert}`: the result is a little bit less esthetically pleasing, but that's easier to implement and maintain.

+ `var x = prompt("this", "that");` this function open the built-in prompt, which is a text area where the user can input text. 
When the user click on "OK", the text is stocked in a variable `x` here, which you can then send back to R (see further part down this chapter for info about how to do that). 
This can replace something like : 

```{r}
mod <- function() {
  modalDialog(
    tagList(
      textInput(ns("info"), "Your info here")
    ),
    footer = tagList(
      modalButton("Cancel"),
      actionButton(ns("ok"), "OK")
    )
  )
}

observeEvent(input$show, {
  showModal(mod())
})
observeEvent(input$ok, {
  removeModal()
})
```

+ `$('#id').css('color', 'blue');` changes the css attributes of the selected element(s). 
Here, we're switching to blue on the `#id` element.

+ `$("#id").text( "this" );` changes the text content to "this". 
This can be used to replace 

```{r eval = FALSE}
output$ui <- renderUI({
  if (this){
    tags$p("First")
  } else {
    tags$p("Second")
  }
})
```

+ `$("#id").remove();` completely removes the element from the DOM. 
Can be used a replacement for `shiny::removeUI()`.


### Adding attributes to HTML elements

+`onclick`

```{r eval = FALSE}
actionButton(
  "plop", "plop", 
  onclick = "alert('hello world')"
)
```

+ `shiny::tagAppendAttributes`

```{r eval = FALSE}
plotOutput(
  "plop"
) %>% tagAppendAttributes(
  onclick = "alert('hello world')"
)
```


```{r eval = FALSE}
library(shiny)
ui <- function(request){
  fluidPage(
    plotOutput(
      "plop"
    ) %>% tagAppendAttributes(
      onclick = "alert('hello world')"
    )
  )
}

server <- function(input, output, session){
  output$plop <- renderPlot({
    plot(iris)
  })
}

shinyApp(ui, server)
```

Real Life example : https://github.com/ColinFay/tidytuesday201942/blob/master/R/mod_dataviz.R#L109 and https://github.com/ColinFay/tidytuesday201942/blob/master/R/mod_dataviz.R#L305

## JavaScript <-> Shiny communication 

First of all, 

### From R to JavaScript 

Inside this skeleton:

```{r echo = FALSE}
readLines("golex/inst/app/www/plop.js") %>%
  glue::as_glue()
```

> `golem::add_js_handler()`

Called from server-side with:


```{r eval = FALSE}
session$sendCustomMessage("fun", list())
```

`list()` -> JSON. 

Example:

- JavaScript 

```{js, eval = FALSE, echo = TRUE}
Shiny.addCustomMessageHandler('monalerte', function(arg) {
alert(arg.message);
alert(arg.message2);
})
```

- R 

```{r eval = FALSE}
session$sendCustomMessage(
  "monalerte", 
  list(
    message = "Mon premier message", 
    message2 = "Mon deuxième message"
  )
)
```

### From JavaScript to R

```{js, eval = FALSE, echo = TRUE}
Shiny.setInputValue("rand", Math.random())
```

```{r eval = FALSE}
observeEvent( input$rand , {
  print( input$rand )
})
```


## About `{golem}` js functions

`{golem}` comes with a series of JavaScript functions that you can call from the server. 
These functions are added by default with `golem::activate_js()` in `app_ui`.


Then they are called with `golem::invoke_js("function", "ui_element")`.

This `ui_element` define the UI element to interact with. 
It can be a full jQuery selector, an id or a class.

### `golem::activate_js()`

+ `showid` & `hideid`, `showclass` & `hideclass` show and hide elements through their id or class.

```{r eval = FALSE}
session$sendCustomMessage("showid", ns("plot"))
```

+ `showhref` & `hidehref` hide and show a link by trying to match the `href` content.

```{r eval = FALSE}
session$sendCustomMessage("showhref", "panel2")
```

+ `clickon` click on the element. You have to use the full jQuery selector. 

+ `show` & `hide` show and hide elements, using the full jQuery selector.

## Learn more about JavaScript

