# Planning Ahead {#planning}

## UX Matters

We have a natural tendency, as R-coders, to be focused on the backend, i.e the algorithmic part of the application. 
But let's state the truth: no matter how complex and innovative your backend is , your application is bad if your User Experience (UX) is bad. 
That's the hard truth. 
If people can't understand how to use your application, your application isn't successful, no matter how incredible the backend is. 

-> Thinking about the end user matters

### "Don't make me think" 

> "Simplify, then add lightness"

> __Colin Chapman CBE, Founder of Lotus Cars__

There are mainly two contexts where you'll be building a web app with R: one for professional use (i.e people will rely on this app to do their job), or for fun (i.e people will just use the app as a distraction). 
But in both cases, people will want the app to be useable, and __easily__ usable. 

If people will use your app in a professional context, they don't want to fight with your interface, read complexe manuals, or lose time understanding what is supposed to do what in your application. 
Think about all the professional applications and softwares that you've been ranting about during your professional life. 
You don't want your app to be one of that. On the other end, if users open your app for fun, they are not going to fight your app into submission: they are just going to give up using your app if it's too complex to be used. 

#### The KISS principle

> The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided.

`r right_link("KISS principle", "https://en.wikipedia.org/wiki/KISS_principle")`

Deeply rooted in the [Unix Philosophy](http://www.catb.org/~esr/writings/taoup/html/ch01s07.html), the KISS principle, for "Keep Thing Simple, Stupid", also known as the "Rule of Least Surprise" or "Principle of Least Astonishment."

> Rule of Least Surprise: In interface design, always do the least surprising thing.

`r right_link("Basics of the Unix Philosophy", "http://www.catb.org/~esr/writings/taoup/html/ch01s06.html#id2878339")`

#### "Don't make me think" 

Try to find a simple, and efficient UI. 
One that people can understand and use in a matter of seconds. 
Don't implement features or visual elements that are not actually needed, just "in case". 
And spend time working on that UI, really thinking about what visual elements you are implementing. 

-> "Self explanatory"

> All kinds of things on a Web page can make us stop and think unnecessarily. Take names, for example. Typical culprits are cute or clever names, marketing-induced names, company-specific names, and unfamiliar technical names

-> If things are clickable, it has to look clickable

> "As a user, I should never have to devote a millisecond of thought to whether
things are clickable—or not" 

-> Restrain reactivity 

-> Not everything needs to be interactive plots 

### About Accessibility 

A user interface needs to be "ready to be consumed" by the broader audience possible. 
That means people with visual, mobility, or cognitive disabilities. 

Web Accessibility is pretty standard concept in the web development world, and you can learn about this straight from the first chapter of [learn.freecodecamp.org](https://learn.freecodecamp.org/). 
-> Screen to speech technology : html semantic tags
-> Mobility impairment, people w/ parkinson for example. Exemple of the text input & ENTER button. Making things keyboard friendly. 
-> ColorBlind, viridis

### Further reading 

+ [_Don't Make Me Think_, Steve Krug](https://en.wikipedia.org/wiki/Don%27t_Make_Me_Think)

// TODO: Find resources about simplicity in UI/UX design

## Working as a team: tools & organisation

Big Shiny Apps usually mean that several people will work on the application. 
For example, at ThinkR, 3 to 4 people usually work on the application. 
So, how do we organize that?

### From the tools point of view: 

+ Use version control (not sure I have to expand on that topic ;) )
+ Think of your shiny app as a tree, and divide it as much as possible into little pieces. 
Then, create one Shiny module by piece. 
This allows you to split the work, and also to have smaller files — it's easier to work on 20 files of 200 lines than on one big app.R file. 

### From the organisational point of view

 + Define one person in charge of having the big picture of the app. 
 This person will kick off the project, and write the skeleton of the app, with the good modules and files structure. 
 This person will also be in charge of accepting new merge requests from other developers, and to orchestrate the master and dev branches. 
+ List the tasks, and open one issue for each task on your version control system. 
Each issue will be solved in a separate branch. 
+ Finally, assign one module to one developer — if it seems that working on one module is a two-person job, divide again into two other submodules. 
This is a relatively complex task, as the output of one module influences the input of another, so be sure to assign them well. 

## Workin with a "long-term" mindset

### Scaling

This includes two things: scaling and maintaining. 
As said in the disclaimer, I won't expand on the topic of scaling, as many have written about that, but here is one piece of advice: make the R process running the app do as little as possible, and in particular prevent it from doing what it's not supposed to do. 
Which includes: use JavaScript so that the client browser renders things (instead of making R do the work — basic JS is easy to learn), use parallelization and async, and if possible, make the heavy lifting be done outside the R session running the app. 

// TODO: link to resources.

### Maintaining

Maintainance, on the other hand, is something to think about from the beginning.  
It includes being able to ensure that the application will work in the long run, and that new features can be easily implemented. 

+ Working in the long run: separate the code with "business logic" (aka the data manipulation and the algorithm, that can work outside the context of the app) from the code building the application. 
That way, you can write regression tests for these functions to ensure they are stable. 
+ Implement new elements: as we are working with modules, it's easy to insert new elements inside the global application. 

// TO DO: be more precise on the tooling. 
