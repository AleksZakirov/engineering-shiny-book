# (PART) Step 3: Build  {-}

# Building app with `{golem}` {#stepbuild}

Now that the application is prototyped inside a `{golem}` [@R-golem] skeleton, you can now work on the integration of the application. 

This parts encompasses the integration of the back-end/front-end together, and working on the global engineering of the application, _i.e_:

+ add and organize dependencies
+ creating and including sub-modules if necessary
+ organize utility functions and link them to the module they are used in
+ adding testing infrastructure 
+ linking to CI / CD services
+ check

## Add dependencies

When you are building a `{shiny}` [@R-shiny] application, you will have to deal with dependencies. 
Well, at least with one dependency, `{shiny}`. 
But chances are that you will not only be using `{shiny}` inside your application: you will probably call functions from other packages, for example from `{ggplot2}` [@R-ggplot2] for plotting, `{DT}` [@R-DT] for interactive tables, or any other packages  that will be necessary to your application working. 

```{r echo = FALSE}
paks <-  eval(formals(golem::use_recommended_deps)$recommended)
paks <- grep("shiny|golem", paks, invert = TRUE, value = TRUE)
paks <- paste0("`{", eval(formals(golem::use_recommended_deps)$recommended), "}`")
```


If you are building your application using `{golem}`, you will have 3 default dependencies: `{golem}` itself, `{shiny}`, and `{config}`. 
If you call `golem::use_recommended_deps()` in the first workflow script, you will also have `r knitr::combine_words(paks)` as dependencies to your package. 
The idea with this function is to provide a shortcut for adding commonly used dependencies, so that you don't have to do it by hand.

But what about other dependencies like `{ggplot2}` or `{DT}`?
These ones need to be added by hand. 
Every time you add a new dependency, go to the `dev/02_dev.R`, and call the `use_package()` function from `{usethis}`: 

```{r 11-step-by-step-build-1, eval = FALSE}
usethis::use_package("pkg.you.want.to.add")
```

There are two places where the dependencies of your application need to be managed
^[This is not `{shiny}` nor `{golem}` specific, but a requirerment for any package]
: the `DESCRIPTION` file and the `NAMESPACE`

+ The `DESCRIPTION` file, which dictates what packages has to be installed when your application is installed. 
As you can not install just a part of a package, this requirement in the `DESCRIPTION` implies that when installed, a Shiny App as a Package will install the dependency on the machine. 
For example, if you list `{DT}` inside the `DESCRIPTION` file, the whole package will be installed when your app is installed.
What `use_package()` is doing is adding the package you have entered to the `DESCRIPTION`.

+ The `NAMESPACE`, which describe how your app interacts with the R session at run time, _i.e_ when your application is launched. 
What this `NAMESPACE` allows to do is to specify only a subset of functions from another package: for example you can choose here to import on `renderDT()` and `DTOutput()` from `{DT}`, instead of importing the whole package. 
The idea with selected import from dependencies is that it allows to avoid namespace conflicts: if you remember correctly, we described a few chapters ago a namespace conflict occurring between `jsonlite::flatten()` and `purrr::flatten()`
^[which can be pretty common as `{jsonlite}` might import `JSON` files as list, and `{purrr}` has pretty powerful tools for manipulating lists]
: using a selective importation, _i.e_ only importing the function we need from `{purrr}` and not the whole package will help us handle that. 
To do so, we will need to do to every script that defines a function, and add a `{roxygen2}` [@R-roxygen2] tag, in the following form : `#' @importFrom purrr map map_df partial`.
Note that you can also use explicit namespacing, _i.e_ the `pkg::function()` notation inside your code. 

Also, if you need a little help to indentify dependencies, all the explicitly namespaced calls (`pkg::function()`) can be scraped using the `{attachment}` [@R-attachment] package:

```{r 11-step-by-step-build-2, eval = FALSE}
attachment::att_from_rscripts()
```

If you are using a development package (for example one installed from GitHub), you can add it to the `DESCRIPTION` using the `use_dev_package()` from `{usethis}`. 
This will add another field to the `DESCRIPTION` file, `Remotes`, with the location where the package is available. 

All of this can seem a little bit daunting at first, but that is for the best: 

> Having a high quality namespace helps encapsulate your package and makes it self-contained. This ensures that other packages won’t interfere with your code, that your code won’t interfere with other packages, and that your package works regardless of the environment in which it’s run.

_R Packages_, [@rpkg]

To learn more about the details of dependencies, `DESCRIPTION` and `NAMESPACE`, here are some resources: 

+ [Writing R Extensions](https://cran.r-project.org/manuals.html), the official manual from the R-Core team
+ [R Packages](https://r-pkgs.org/), especially the _Package metadata_ and _Namespace_ 

## Submodules and utility functions

When building a large application, you will be splitting your code base into smaller pieces: we have defined in the _Structuring your Project_ chapter that these utilitarian functions should be defined in files that are prefixed with a specific term.
In the `{golem}` world, `utils_*` files contain small functions that might be used several times in the application, and the `fct_*` files larger functions that are more central to the application. 

Two functions can be called to add these files: 

```{r 11-step-by-step-build-3, eval = FALSE}
golem::add_fct( "helpers" ) 
golem::add_utils( "helpers" )
```

+ The first will create a `R/fct_helpers.R` file
+ The second will create a `R/utils_helpers.R` file

The idea, as explained before, is that as soon as you open a `{golem}` based project, you are able to identify what the files contain. 

The `utils_*` convention is a pretty common one: a lot of R packages contain a file call `utils.R` that bundles a series of small functions that are used throughout the package.
For example, the `{hexmake}` app has two of these files [`R/utils_ui.R`](https://github.com/ColinFay/hexmake/blob/master/R/utils_ui.R) and [`R/utils_server.R`](https://github.com/ColinFay/hexmake/blob/master/R/utils_server.R), in which you will find small functions that are reused throughout the app. 

The `fct_*` files are to be used with larger functions, which are more central to the application, but that might not fit into a specific module. 
For example, in `{hexmake}`, you will find [`R/fct_mongo.R`](https://github.com/ColinFay/hexmake/blob/master/R/fct_mongo.R), that is used to handle all the things related to connecting and interacting with the Mongodb database. 

As you can see, the difference is that `fct_*` file are more "topic-centric", in the sense that they gather functions that relates to a specific feature of the application (here, the database), while `utils_*` files are more used as a place where to put functions that might not relate to each other.

Note that when building a module with `golem::add_module()`, you can add a module specific `fct_*` or  `utils_*` file:

```{r eval = FALSE}
golem::add_module("rendering", fct = "connect", utils = "wrapper")
```

Will create: 

+ `R/mod_rendering.R`
+ `R/mod_rendering_fct_connect.R`
+ `R/mod_rendering_utils_wrapper.R`

And this can also be done the other way around, by specifying the module you want to link your file to:

```{r eval = FALSE}
golem::add_utils("wrapper", module = "rendering")
```


## Add tests

No piece of software should go into production if it has not been sufficiently tested. 
In this part of the building process, you will be setting tests for the application you are building. 
We will get back to the how, why and what of testing in an upcoming chapter, but as we are currently going through the `02_dev.R` script, we mention here the line that allows you to add a test skeleton to your app. 

If you have followed every steps from the `01_start.R` file, you already have a full testing infrastructure ready, with a set of recommended tests inserted by `{golem}`. 
But as it is hard to find tests that are relevant to all applications (as every application is unique), you will have to add and fill manually the tests that will check your app. 
And right now, to add a new testing file, you can call:

```{r 11-step-by-step-build-4, eval = FALSE}
usethis::use_test("app")
```

More on testing in the _Build yourself a safety net_ chapter.

## Documentation and Code Coverage

### Vignette

Vignettes are longer format documentation for your application, they are the one users see when they are running `browseVignettes()`, when they look at the documentation in the `Help` pane from RStudio, when they are browsing a webpage on CRAN, and it is also the documents that are used when the `{pkgdown}` websites are built. 
The good news is that if you have been using our "Rmd first" method, you already have most of the Vignettes built: they are the Markdown files describing how the back-end of your application works. 

Depending on how you applied this principle, these Rmd files might live inside the `inst/` folder, or already as package Vignettes.
If you need to add a new Vignette, be it for adding an Rmd describing the back-end or a global documentation about the application, you can call the `use_vignette()` function from `{usethis}`.

```{r 11-step-by-step-build-5, eval = FALSE}
usethis::use_vignette("shinyexample")
```

Then, you can build all the Vignettes with:

```{r 11-step-by-step-build-6, eval = FALSE}
devtools::build_vignettes()
```

### Code coverage & CI

Code coverage is a way to detect the volume of code that is covered by unit testing. 
You can do this locally, or you can use online services like Appveyor, an online platform that computes and track the code coverage of your repository. 

```{r 11-step-by-step-build-7, eval = FALSE}
usethis::use_travis()
usethis::use_appveyor()
usethis::use_coverage()
```

## Using `{golem}` dev functions

There is a series of tools to make your app behave differently whether it is in dev or prod mode. 
Notably, the `app_prod()` and `app_dev()` function look for the value of `options( "golem.app.prod" )`, or return TRUE if this option does not exist.

Setting this options at the beginning of your dev process allows to make your app behave in a specific way when you are in dev mode. 
For example, printing message to the console with `cat_dev()`.

```{r 11-step-by-step-build-8, eval = TRUE}
options( "golem.app.prod" = TRUE)
golem::cat_dev("hey\n")
options( "golem.app.prod" = FALSE)
golem::cat_dev("hey\n")
```

You can then make any function being "dev-dependant" with the `make_dev()` function: 

```{r 11-step-by-step-build-9, eval = TRUE}
log_dev <- golem::make_dev(log)
log_dev(10)
options( "golem.app.prod" = TRUE)
log_dev(10)
```
