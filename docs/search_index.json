[
["index.html", "Engineering Production-Grade Shiny Apps Introduction Motivation Book structure About the authors Want to help? Other resources Acknowledgments", " Engineering Production-Grade Shiny Apps Colin Fay, Vincent Guyader, Cervan Girard, Sébastien Rochette 2020-01-23 Introduction img.left { float: left; margin-right: 1em; } This book is currently under development. It will be published in 2020 in the R Series by Chapman &amp; Hall. Motivation This book will not get you started with Shiny, nor talk about how to deploy into production and scale your app. What we’ll see is the process of building the app. Why? Lots of blog posts and books talk about starting to use shiny or putting apps in production. Very few (if any) talk about this grey area between getting started and pushing into production. So this is what this book is going to talk about: building Shiny application. We’ll focus on the process, the workflow, and the tools we use at ThinkR when building big Shiny Apps. Hence, if you’re starting to read this book, we assume you have a working knowledge of how to build a small application, and want to know how to go one step further. Book structure Part 1 (Building big Shiny Apps) gives a general context about what is a successful Shiny Apps and what challenges arise when you’re dealing with a large scale application. It also introduces the {golem} package and more general concept about organising your workflow. This first part will be light on code: you’ll read more about conceptual ideas and organisation strategy. Part 2 to 6 describes a series of steps you can take when you want to build a Shiny App, and the tooling associated with each step. Part 7 (Optimizing) tackles the question of optimization, first by presenting some common caveats of Shiny Apps, and then showing how to optimize R code, and use JavaScript to lighten R work. About the authors // TODO Colin Fay Vincent Guyader Cervan Girard Sébastien Rochette Want to help? Any feedbacks on the book is very welcome. Feel free to open an issue, or to make a PR if you spot a typo (I’m not a native english speaker, so there might be some waiting to be found ;) ). Other resources Getting started with Shiny Learn Shiny with RStudio Getting Started with Shiny (WIP) Mastering Shiny A gRadual intRoduction to Shiny Shiny into production Shiny in production: Principles, practices, and tools Shiny in Production Suggest a Resource! Acknowledgments Contributors to this book Liz Roten, for proofreading chapter 1 and helping us with writing advices. Dan S. Reznik, for proof-reading the JavaScript chapter. // TODO : "],
["successfulshinyapp.html", "Chapter 1 About Successful Shiny Apps 1.1 A (very) short introduction to Shiny 1.2 What’s a complex Shiny App? 1.3 What’s a successful Shiny App?", " Chapter 1 About Successful Shiny Apps I Too Like to Live Dangerously .right{ text-align: right;} Austin Powers 1.1 A (very) short introduction to Shiny If you’re reading this page, chances are you already know what a Shiny App is — a web application that communicates with R, built in R, and working with R. The beauty of {shiny} is that it makes it easy for anybody to create a small app in a matter of hours. With small and simple Shiny apps, no knowledge of HTML, CSS or JavaScript is required, which makes it really easy to use—you can rapidly create a POC for a data-product and showcase an algorithm or present your results with an elegant, simple to build user interface. The first version of {shiny} has been published in 2012, and since then there it has been one of the top project of the RStudio team. At the time of writing these lines (January 2020), more than 4600 commits has been made to the main GitHub repository, by 46 contributors. It’s now downloaded around 400K times a month, according to cranlogs, and has 703 reverse dependencies (package that depends on it) according to devtools::revdep(&quot;shiny&quot;). If you’re very new to Shiny, this book might feel a little bit complex, as it relies on the assumption that you already know how to build (at least basic) Shiny applications, and that you want to push your Shiny skills to the next level. If you are very new to Shiny, we suggest you start with the Mastering Shiny book before coming back to this book. Ready to get started with complex Shiny App? 1.2 What’s a complex Shiny App? One of the unfortunate things about reality is that it often poses complex problems that demand complex solutions .right{ text-align: right;} The Art of Unix Programming 1.2.1 Reaching the cliff of complexity Things are quite simple when it comes to small prototypes or proof of concepts. But things change when your application reaches “the cliff of complexity”1. But what do we mean by complexity? Getting a clear definition is not an easy task2 as it very depends on who is concerned and who you’re talking to. A good definition is the one from The Art of Unix Programming: “Complex software is harder to think about, harder to test, harder to debug, and harder to maintain — and above all, harder to learn and use.” But let’s try to come with a definition that will serve us in the context of engineering Shiny applications. When building software, we can think of complexity from two points of view: the complexity as it is seen by the coder, and the complexity as it is seen by the customer / end user.3 With great complexity comes great responsibility When your program reaches this state, there is a lot of potential for failure, be it from a developer or user perspective. For the code, bugs are harder to anticipate: it’s hard to think about all the different paths the software can follow and difficult to detect bugs because they are deeply nested in the numerous routines the app is doing. It’s also hard to think about what the state of your app is at a given moment in time because of the numerous inputs and outputs your app contains. From the user perspective, the more complex an app, the more steep the learning curve is, which means that the user will have to invest more time learning how the app works, and will be even more disappointed if ever they realize this time has been a waste. 1.2.1.1 Two views of complexity From the developer point of view An app is to be considered complex when it is big enough in terms of size and functionality that it makes it impossible to reason about it at once, and you must rely on tools to understand and handle this complexity. This type of complexity is called implementation complexity. One of the goal of this book is to present you a methodology and toolkit that will help you reduce this form of complexity. For example, we’ll talk about a design / prototype / build / secure / deploy framework, which helps you reduce the complexity of implementing and maintaining new app features. We’ll also be talking at length about the {golem} package, which provides a toolkit for reducing the cognitive load of handling complexity in large Shiny applications. For example, creating a new Shiny module requires following a very strict structure. One way to do that is to remember how to do that and to code it from scratch (a method which has an important cognitive load and is very error prone). Another way is to copy and paste an existing module and to adapt it, which is, as any copy and paste, likely to lead to errors. Or there is the {golem} way, in which you rely on a robust tool to build the foundations for a new module. Another benefit of adopting automation for common application components is that it ensures that you’re following a convention. And conventions are crucial when it comes to building and maintaining complex systems: by imposing a formalized structure for a piece of code, it enhances readability, lessens the learning curve, and lightens the chance for typos and/or copy and paste errors. Customers and users On the other hand, customers and end user see complexity as interface complexity. Interface complexity can be driven by a lot of elements, for example the probability of making an error while using the app, the difficulty to understand the logical progression in the app, the presence of unfamiliar behaviour or terms, visual distractions… This book will also bring you strategy to help you cope with the need for simplification when it comes to designing interface. 1.2.1.2 Balancing complexities There is an inherent tension between these two source of complexity, as designing an app means finding a good balance between implementation and interface complexity. Reducing implementation complexity means one has to make some decisions that will lower one while rising the other. For example, we can think of something very common in Shiny: the “too much reactivity” pattern. In some cases, coders try to make everything reactive: e.g., three sliders and a selectInput, all updating a single plot. This behavior lowers the interface complexity: users don’t have to think a lot about what they are doing, they just move things around and it updates. But this kind of pattern can make the app compute too many things: users rarely go to the slider value they need on their first try. They usually miss what they actually want to select in an input. So, way more computation for R. One solution can be to delay reactivity or to cache things so that R computes fewer things. But that comes with a cost: handling delayed reactivity and caching elements increases implementation complexity. One other solution is simply to add a button after the input, and only update the plot when the user clicks on it. This pattern makes it easier to control reactivity from an implementation side. But it can make the interface a little bit more complex for the user who have to perform another action in addition to changing their inputs. We’ll argue somewhere else in the book that not enough reactivity is better than too much reactivity, as the latter increases computation time, and relies on the assumption that the user makes the right action on the first try. Another good example is {shiny}’s dateRangeInput() function, which takes a start which is posterior to the end (which is the behavior of the JavaScript plugin used in {shiny} to create this input). Handling this special case is doable: with a little bit of craft, you can watch what the user inputs and throw an error if the start is after the end.4 That solution augments the implementation complexity, while leaving it as is requires the user to think about whether or not the starting date is before the ending date, thus increasing the interface complexity. So what should we do? It’s up to you: deciding where to draw the line between interface &amp; implementation complexity very much depends of the kind of project you’re working on, and on the kind of users that will use your app. Things that you can assess here is the ease of working on implementation of feature (for your team), how much your app will be used, how frequently, by what kind of users… Drawing the line between the two is not the simplest thing on earth, and requires to restrain yourself from implementing too much, and still create an application that is easy to use. 1.2.2 Assessing complexity How can we get a good overview of this complexity? 1.2.2.1 Codebase size Another measure that sometimes comes in the discussion is the codebase size. It’s relatively hard to use this number of lines metric, as R is very permissive when it comes to indentation and line breaks, and (unlike JavaScript or CSS), it is generally not minified5. It also depends on your coding style and the packages you’re using. For example, {tidyverse} packages encourage the use of the pipe (%&gt;%)6 with one function by line, producing more lines in the end code. Consider this piece of valid R code: iris[ 1 : 5, c ( &quot;Species&quot; ) ] [1] setosa setosa setosa setosa setosa Levels: setosa versicolor virginica 9 lines of code for something that could also be written in one line. iris[1:5, c(&quot;Species&quot;)] [1] setosa setosa setosa setosa setosa Levels: setosa versicolor virginica In other words, using this kind of writing style can make the code base larger in term of lines, without really adding complexity to the general program. Another drawback of this metric is that it focuses on numbers instead of readability, and in the long run, yes, readability matters.7 Still, this metric can be useful to reinforce what you’ve learned from other metrics: it’s rather unlikely that you’ll find this “extreme” coding style we’ve just showed, and even if it might not make sense to compare two code base that just differ by 1 or 2 % of lines of code, it’s very likely that a code base which is ten, twenty, one hundred times larger is a more complex software. Also, another good sign related to this metric is the number of files in the project: R developers tend to split their functions into several files, so the more files you’ll find in a project, the more large the code base is. Numerous files can also be a sign of maintenance complexity: it’s harder to reason about an app logic split into several files than about something that fits into one linear code inside one file. If you want to use this metric, you can do it straight from R with the {cloc} package, available at https://github.com/hrbrmstr/cloc. if (!requireNamespace(&quot;cloc&quot;)){ remotes::install_github(&quot;hrbrmstr/cloc&quot;) } For example, let’s compare a rather big package ({shiny}) with a small one ({attempt}): library(cloc) library(dplyr) shiny_cloc &lt;- cloc_cran(&quot;shiny&quot;, .progress = FALSE, repos = &quot;http://cran.irsn.fr/&quot; ) attempt_cloc &lt;- cloc_cran(&quot;attempt&quot;, .progress = FALSE, repos = &quot;http://cran.irsn.fr/&quot; ) clocs &lt;- bind_rows( shiny_cloc, attempt_cloc ) # Counting lines of code clocs %&gt;% group_by(pkg) %&gt;% summarise( loc = sum(loc) ) # A tibble: 2 x 2 pkg loc &lt;chr&gt; &lt;int&gt; 1 attempt 4011 2 shiny 71478 # Counting files clocs %&gt;% group_by(pkg) %&gt;% summarise( files = sum(file_count) ) # A tibble: 2 x 2 pkg files &lt;chr&gt; &lt;int&gt; 1 attempt 35 2 shiny 269 Here, just from these two metrics, we can safely assume that {shiny} is a more complex package than {attempt}. 1.2.2.2 Cyclomatic complexity Cyclomatic complexity is a software engineering measure which allows to define the number of different linear paths a piece of code can take. It’s computed based on a control-flow graph8 representation of an algorithm. The complexity number is then computed by taking the number of nodes, and subtracting the number of edges plus two times the number of connected components of this graph: M = E − N + 2P, where M is the measure, E the number of edges, N the number of nodes and 2P 2 time the number of connected components. We won’t go deep into this topic, as there are a lot things going on in this computation and you can find many documentation about this online. Please refer to the bibliography for further readings about the theory behind this measurement. In R, the cyclomatic complexity is computed with the {cyclocomp} package, which can be installed from CRAN with: install.packages(&quot;cyclocomp&quot;) The cyclocomp package comes with three main functions: cyclocomp(), cyclocomp_package(), and cyclocomp_package_dir (). The one we’ll be interested in is cyclocomp_package_dir(): building successful shiny apps with the {golem} framework (we’ll get back on that later) means you’ll be building your app as a package. You can then use cyclocomp_package_dir() to compute the complexity of your app. Here is for example the cyclomatic complexity of the default golem template: library(cyclocomp) cyclocomp_package(&quot;golex&quot;) %&gt;% head() name cyclocomp 1 app_server 1 2 app_ui 1 3 golem_add_external_resources 1 4 run_app 1 And the one from another small application: cyclocomp_package(&quot;tidytuesday201942&quot;) %&gt;% head() name cyclocomp 24 mod_dataviz_ui 8 23 mod_dataviz_server 7 35 rv 6 14 display 4 39 undisplay 4 37 tagRemoveAttributes 3 And, finally, the one for {shiny}: cyclocomp_package(&quot;shiny&quot;) %&gt;% head() name cyclocomp 507 untar2 75 119 diagnoseCode 54 399 runApp 50 155 find_panel_info_non_api 37 381 renderTable 37 105 dataTablesJSON 34 And, bonus, this cyclocomp_package() function can also be used to retrieve the number of functions inside the package. Why does it matter? Successful Shiny apps implies two things: you’ll be writing unit tests for your code, and all the inputs from the users will be checked during the application runtime. Both means that the more a function is complex, the more it will be hard to reason about: it’s almost impossible to make a mental model of a very complex function. Checking users inputs is also harder, as a higher complexity might implies that there are several inputs, and / or that an input can have a large number of states along the function execution. It’s also harder to maintain complex function: bugs are harder to spot as they might happen only in one of the multiple paths the code can take. And of course, integrating changes is harder as you have to think about how new elements will impact all the possible paths the code might take. So, as The Clash said, “what are we gonna do now?” You might have heard this saying that “if you copy and paste a piece of code twice, you should write a function”. Then, this might be a solution here: splitting things in smaller pieces lower the local cyclomatic complexity. One thing that can also be done is leveraging the strength of S3 methods to split elements: if you have a function that behave differently based on the type of the input, generics and methods are easier to reason about than if statements inside a larger function. But that’s not a magic solution: (A) because the global complexity of the app is not lowered by splitting things into pieces, (B) because the deeper the call stack the harder it can be to reason about the big picture. 1.2.2.3 Other measures Complexity can come from other sources: unsufficient code coverage leading to bugs that are hard to spot, dependencies that breaks the implementation, old package, or a lot of other things. How do we assess that? We can have a look at the {packageMetrics2} package to have some of these metrics: for example, the number of dependencies, the code coverage, the number of releases and the date of the last one, etc. library(packageMetrics2) frame_metric &lt;- function(pkg){ metrics &lt;- package_metrics(pkg) tibble::tibble( n = names(metrics), val = metrics, expl = list_package_metrics()[names(metrics)] ) } frame_metric(&quot;golem&quot;) %&gt;% knitr::kable() Metrics: ARR ATC DWL DEP DPD CCP FLE FRE LIB LLE LNC LNR LRE NAT NTF NUP OGH SAP SEM SEQ SWD VIG n val expl ARR 0 Number of times = is used for assignment ATC NA Author Test Coverage DWL 6265 Number of Downloads DEP 27 Num of Dependencies DPD 0 Number of Reverse-Dependencies CCP 2.33898305084746 Cyclomatic Complexity FLE 16.8833333333333 Average number of code lines per function FRE 2019-08-05T14:50:02+00:00 Date of First Release LIB 0 Number of library and require calls LLE 26 Number of code lines longer than 80 characters LNC 0 Number of lines of compiled code LNR 1464 Number of lines of R code LRE 2019-08-05T14:50:02+00:00 Date of Last Release NAT 0 Number of attach and detach calls NTF 0 Number of times T/F is used instead of TRUE/FALSE NUP 0 Updates During the Last 6 Months OGH 1 Whether the package is on GitHub SAP 1 Number of sapply calls SEM 0 Number of trailing semicolons in the code SEQ 0 Number of 1:length(vec) expressions SWD 18 Number of setwd calls VIG 4 Number of vignettes frame_metric(&quot;shiny&quot;) %&gt;% knitr::kable() Metrics: ARR ATC DWL DEP DPD CCP FLE FRE LIB LLE LNC LNR LRE NAT NTF NUP OGH SAP SEM SEQ SWD VIG n val expl ARR 14 Number of times = is used for assignment ATC NA Author Test Coverage DWL 11635778 Number of Downloads DEP 22 Num of Dependencies DPD 714 Number of Reverse-Dependencies CCP 3.79710144927536 Cyclomatic Complexity FLE 24.4810996563574 Average number of code lines per function FRE 2012-12-01T07:16:17+00:00 Date of First Release LIB 1 Number of library and require calls LLE 424 Number of code lines longer than 80 characters LNC 0 Number of lines of compiled code LNR 24395 Number of lines of R code LRE 2019-10-10T11:50:02+00:00 Date of Last Release NAT 0 Number of attach and detach calls NTF 0 Number of times T/F is used instead of TRUE/FALSE NUP 1 Updates During the Last 6 Months OGH 1 Whether the package is on GitHub SAP 10 Number of sapply calls SEM 1 Number of trailing semicolons in the code SEQ 0 Number of 1:length(vec) expressions SWD 6 Number of setwd calls VIG 0 Number of vignettes If you’re building an app with {golem}, a framework for building shiny apps, you can use the DESCRIPTION file, the one that contains the dependencies, as a starting point for assessing the state of your dependencies: desc::desc_get_deps(&quot;golex/DESCRIPTION&quot;) type package version 1 Imports shiny * 2 Imports golem * Then, it can be used as a series of inputs for our previous function. 1.2.3 Production Grade Software Engineering Complexity is still frowned upon by a lot of developers, notably because it has been seen as something to avoid according to the Unix philosophy. But there are dozens of reasons why an app can become complex: for example, the question your app is answering is quite complicated and involves a lot of computation and routines. The resulting app is rather ambitious and implements a lot of features, etc. So yes, there is a chance that if you’re reading this page, you’re working or are planning to work on a complex Shiny app. And this is not necessarily a bad thing! Shiny apps can definitely be used to implement production-grade9 software, but production-grade software implies production-grade software engineering. To make your project a success, you need to use tools that reduce the complexity of your app and ensure that your app is resilient to aging. In other words, production-grade Shiny apps require working with a software engineering mindset, which is not always an easy task in the R world. R comes from the land of the academics and is still used as an “experimentation tool”, where production quality is one of the least concerns. Many developers in the R world have learned R as a tool for making statistics, not as a tool for building software. These contexts are very different and require different mindsets, skills, and tools. With {shiny}, as we said before, it’s quite easy to prototype a simple app, without any “hardcore” software engineering skills. And when we’re happy with our little proof of concept, we’re tempted to add something new. And another. And another. And without any structured methodology, we’re almost certain to reach the cliff of complexity very soon and end up with a code base that is hardly (if ever) ready to be refactored to be sent to production. The good news is that building a complex app with R (or with any other language) is not an impossible task. But it requires planning, rigor, and correct engineering. This is what this book is about: how to organise your Shiny App in a way that is time and code efficient, and how to use correct engineering to make your app a success. 1.3 What’s a successful Shiny App? The good news is that your application does not have to be complex to be successful. Even more, in a world where “less is more”, the more you can reduce your application complexity, the more you’ll be prepared for success. So what’s a successful Shiny app? Defining such a metric is not an easy a task, but we can extract some common patterns when it comes to applications that would be considered successful. 1.3.1 It exists First of all, an app is successful if it was delivered. In other words, the developer team was able to move from specification to implementation to testing to delivering. This is a very engineering-oriented definition of success, but it’s a pragmatic one: an app that never reaches the state of usability is not a successful app, as something along the way has blocked the process of finishing the code. This implies a lot of things: but mostly it implies that the team was able to organise itself in an efficient way, so that they were able to work together in making the project a success. And anybody that has already worked on a code base as a team knows it’s not an easy task. 1.3.2 It’s accurate The app was delivered, and it answers the question it is supposed to answer, or serves the purpose it is supposed to serve. Delivering is not the only thing to keep in mind: you can deliver a working app but it might not work in the way it is supposed to work. Just as before, accuracy means that between the moment the idea appears in someone’s mind and the moment the app is actually ready to be used, everybody was able to work together toward a common goal. 1.3.3 It’s usable The app was delivered, it answers the question it is supposed to answer, and it is user-friendly. Unless you’re coding for the sake of the art, there will always be one or more end users. And if these people can’t use the app because it’s too hard to use, too hard to understand, because it’s too slow or there is no inherent logic in how the user experience is designed, then it’s inappropriate to call the app is a success. 1.3.4 It’s immortal Of course that’s a little bit far fetched, but when designing the app, you should set the ground for robustness in time and aim at a (theoretical) immortality of the app. Planning for the future is a very important component of a successful Shiny App project. Once the app is out, it’s successful if it can exist in the long run, with all the hazards that implies: new package versions that potentially break the code base, implementation of new features in the global interface, changing key features of the UI or the back-end, and not to mention passing the code base along to someone who has not worked on the first version, and who is now in charge of developing the next version. And this, again, is hard to do without effective planning and efficient engineering. In fact, this new person might simply be you, a month from now. And &quot;You’ll be there in the future too, maintaining code you may have half forgotten under the press of more recent projects. When you design for the future, the sanity you save may be your own.10 We borrow this term from Charity Major, as heard in Test in Production with Charity Majors, CoRecursive↩ Ironic right?↩ from The Art of Unix Programming, “Chapter 13: Speaking of Complexity”↩ see shiny/issues/2043#issuecomment-525640738 for an example↩ The minification process is the process of removing all blank characters and put everything on one line so that the file in the output is much smaller.↩ “%&gt;% should always have a space before it, and should usually be followed by a new line.”, tidyverse style guide↩ “Pressure to keep the codebase size down by using extremely dense and complicated implementation techniques can cause a cascade of implementation complexity in the system, leading to an un-debuggable mess.”, from The Art of Unix Programming, “Chapter 13: Speaking of Complexity”↩ A control flow graph is a graph representing all the possible paths a piece of code can take while it’s executed.↩ By production-grade, we mean a software that can be used in a context where people use it for doing their job, and where failures or bugs have real-life consequences↩ The Art of Unix Programming, Eric Steven Raymond↩ "],
["planning.html", "Chapter 2 Planning Ahead 2.1 Working with a “long-term” mindset 2.2 Working as a team: tools &amp; organisation", " Chapter 2 Planning Ahead 2.1 Working with a “long-term” mindset “Rome ne fut pas faite toute en un jour” French proverb 2.1.1 Prepare for success One common thing you’ll hear about Shiny is that it’s a good prototyping tool. And this can’t be denied: building a POC for an app is relatively easy if you compare to what it needs when building apps in other languages. With Shiny, you can build a “works on my machine” app in just a couple of hours, and show it to your team, your boss, your investors… Thanks to the way Shiny is built, you don’t have to care about websocket, ports, html, JavaScript, libraries, and all the things that are elegantly bundled straight into Shiny. So, you can have a quick, hacky application that will work on your machine, and that very rapidly. But that’s not the way you should start. Indeed, starting with hacky foundations will lead to two possibilities: You’ll have to rewrite everything from scratch to have a robust application. If you don’t want to do that, you’ll get stucked with a legacy code base for the app that is built on top of hacky function. The idea there is that even if Shiny is a good tool for prototyping, there is no harm in starting your application on solid ground, even for a prototype. We’ll discover in this book a framework called {golem}, which is a toolbox for building production-grade Shiny application. Even if {golem} is focused on production, there is no reason not to use it for your Proof of Concepts: starting a new {golem} project is relatively straightforward, and even if you don’t use the advanced features, you can use it for very small apps. That way, you’re getting ready for complexity, and if you need to turn this small app into a production app, the foundations are there. 2.1.2 Team work and the KISS principle The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided. .right{ text-align: right;} KISS principle Deeply rooted in the Unix Philosophy, the KISS principle stands for “Keep It Simple, Stupid”. The story behind this principle is supposed to be that Kelly Johnson, lead engineer at the Lockheed Skunk Works, gave his workers a set of very common tools and said that the airplanes should be repairable with these tools, and these tools only. The idea behind this being that repairing an aircraft should be possible for any average engineer. This should be a principle to keep in mind when building application. Indeed, large scale Shiny projects can lead to many people working on the code base, and this for a long period of time. Many people means a variety of skills, with some common ground in Shiny development. So when choosing how and what to implement, try to make a rule to go for the simplest solution11, i.e the one that any common Shiny Developer would be able to understand and maintain. If you go for an exotic solution or a complex technology, be sure that you’re doing it for a good reason: unknown or hard to grasp technology reduce the chance of finding someone that will be able to maintain that piece of code in the future. 2.2 Working as a team: tools &amp; organisation Complex Shiny Apps usually imply that several people will work on the application. For example, at ThinkR, 3 to 4 people usually work on the application, but there might be more people involved on larger project. Working as a team, whatever the coding project, requires discipline and organisation. How can we achieve that? 2.2.1 From the tools point of view: 2.2.1.1 Version Control &amp; Test all the things When you are working on a complex application, chances are that you’ll be working on it for a significant period of time, meaning that you’ll write code, modify it, use it, go back to it after a few weeks, change some other things, and probably break things. Breaking things is a natural process of software engineering, notably when working on a piece of code during a long period. Remember the last chapter where we defined that complex applications are too large to be understood fully? Adding code that breaks the codebase will happen with complex app, so the sooner you take measure to solve code break the better. As you can’t prevent code to break, you should at least get the tooling to: Be informed that the code has broken Be able to identify changes, and to potentially get back in time to a previous code base. To get informed about a code break, you’ll need to write tests for your app, and to use Continuous Integration so that you’re sure this is automatically detected12. We’ll get back to testing and version control in depth in chapter 14. 2.2.1.2 Small is beautiful Last chapter introduced the notion of complexity in size, where the app grows so large that it’s very hard to have a good grasp of it. A large code base implies that the safe way to work is to split the app in pieces as much as possible. Splitting a Shiny project is made possible by following two techniques: Split your app into Shiny Modules, so that your app be though of as a tree, making is possible for every developer to concentrate on one node, and only one, instead of having to think about the global infrastructure when implementing features Extract your core “non-reactive” functions, that we will also call the “business logic”, and include them in external files, so that you can work on these outside of the app: in other words, so that you don’t have to relaunch the whole app every time you need to do something new We’ll get back to Shiny module and how to organised your project in the next chapter. 2.2.2 From the organisational point of view First of all, you’ll need one person (or maybe two) to be in charge of supervising the whole project. It’s hard to have the complete picture of what the app is doing, and most of the time, as a developer, you don’t need to. On the other hand, if the work is correctly spit between members of the team, you’ll probably be focusing on one or more part(s) of the application, but you don’t need to know every single bit of what the application is doing. But someone has to be get the whole picture: what each part of the software is doing, and how to make all work together, and of course how to check that, at the end of the day, the results returned by the application are the correct ones. This very same person will be the one that kicks off the project, and write the first draft of the application. If you’re following the workflow we’ll describe in this book, this person in charge of supervising will create a {golem} project, fill the information, and define the application structure by providing the modules, and the prototype of the app. If you’re working following git flow (described in chapter 13), this person in charge of managing the app will also be in charge of reviewing the pull requests and merging them to dev if they solve the associated issue. Don’t worry if this sounds like a foreign language to you, we’ll get back to this method in this book. Once this skeleton of an app is created, create a series of tasks to be accomplished. Using a Version Control System like git will help you there: you’ll open a series of issues which will be closed during the development. Other management tools can be used there: for example redmine, jira, or any issue tracking software can play this role. We strongly suggest to use git, either on GitHub or on GitLab, as it can be easily integrated with R, and of course as it can also be used for doing versioning. As the app will be split in various Shiny Modules, you can assign the development of one or more module(s) to one member of the team. Remember that it’s simpler to work in a context where one developer is assigned to one module, even if in reality it’s a little bit more complex than that, and several members of the team might go back and forth working on a module. But in a perfect world, one module equals one file, and every body safely works on their own part of the application. Then, only one person is in charge of making all the pieces fit together. Which might not be the most “elegant” solution, but production code requires pragmatism.↩ Relying on automatic tooling for monitoring code base is way safer than relying on developers to do manual checks every time they commit code.↩ "],
["structure.html", "Chapter 3 Structuring your Project 3.1 Shiny App as a Package 3.2 Using Shiny Modules 3.3 Splitting your app into files", " Chapter 3 Structuring your Project 3.1 Shiny App as a Package In the next chapter you’ll be introduced to the {golem} package, which is an opinionated framework for building production-ready Shiny Applications. This framework starts by creating a package skeleton waiting to be filled. But, in a world where Shiny Applications are mostly created as a series of files, why bother with a package? 3.1.1 What’s in a Shiny App? OK, so let’s ask the question the other way round. Think about your last Shiny which was created as a single-file (app.R) or two files app (ui.R and server.R). You’ve got these two, and you put them into a folder. So, let’s have a review of what you’ll need next for a robust application. First, metadata. In other words, the name of the app, the version number (which is crucial to any serious, production-level project), what the application does, who to contact if something goes wrong. Then, you need to find a way to handle the dependencies. Because you know, when you want to push your app into production, you can’t have this conversation with IT: IT: Hey, I tried to ‘source(“app.R”)’ but I’ve got an error. R-dev: What’s the error? IT: It says “could not find package ‘shiny’”. R-dev: Ah yes, you need to install {shiny}. Try to run ‘install.packages(“shiny”)’. IT: OK nice. What else? R-dev: Let me think, try also ‘install.packages(“DT”)’… good? Now try ‘install.packages(“ggplot2”)’, and … […] IT: Ok, now I source the ‘app.R’, right? R-dev: Sure! IT: Ok so it says ‘could not find function runApp()’ R-dev: Ah, you’ve got to do library(shiny) at the beginning of your script. And library(purrr), and library(jsonlite)*. * Which will lead to a Namespace conflict on the flatten() function that can cause you some debugging headache. So, hey, it would be cool if we could have a Shiny app that only imports specific functions from a package, right? So yes, dependencies matter. You need to handle them, and handle them correctly. Now, let’s say you’re building a big app. Something with thousands of lines of code. Handling a one-file or two-file shiny app with that much lines is just a nightmare. So, what to do? Let’s split everything into smaller files that we can call! And finally, we want our app to live long and prosper, which means we need to document it: each small pieces of code should have a piece of comment to explain what these specific lines do. The other thing we need for our application to be successful on the long term is tests, so that we are sure we’re not introducing any regression. Oh, and that would be nice if people can get a tar.gz and install it on their computer and have access to a local copy of the app! OK, so let’s sum up: we want to build an app. This app needs to have metadata and to handle dependencies correctly, which is what you get from the DESCRIPTION + NAMESPACE files of the package. Even more practical is the fact that you can do “selective namespace extraction” inside a package, i.e you can say “I want this function from this package”. Also, this app needs to be split up in smaller .R files, which is the way a package is organized. And I don’t need to emphasize how documentation is a vital part of any package, so we solved this question too here. So is the testing toolkit. And of course, the “install everywhere” wish comes to life when a Shiny App is in a package. 3.1.2 The other plus side of Shiny as a Package 3.1.2.1 Testing Nothing should go to production without being tested. Nothing. Testing production apps is a wide question, and I’ll just stick to tests inside a Package here. Frameworks for package testing are robust and widely documented. So you don’t have to put any extra-effort here: just use a canonical testing framework like {testthat}. Learning how to use it is not the subject of this chapter, so feel free to refer to the documentation. See also Chapter 5 of “Building a package that lasts”. What should you test? First of all, as we’ve said before, the app should be split between the UI part and the back-end (or ‘business logic’) part. These back-end functions are supposed to run without any interactive context, just as plain old functions. So for these ones, you can do classical tests. As they are back-end functions (so specific to a project), {golem} can’t provide any helpers for that. For the UI part, remember that any UI function is designed to render an HTML element. So you can save a file as HTML, and then compare it to a UI object with the golem::expect_html_equal(). library(shiny) ui &lt;- tagList(h1(&quot;Hello world!&quot;)) htmltools::save_html(ui, &quot;ui.html&quot;) golem::expect_html_equal(ui, &quot;ui.html&quot;) # Changes ui &lt;- tagList(h2(&quot;Hello world!&quot;)) golem::expect_html_equal(ui, &quot;ui.html&quot;) This can for example be useful if you need to test a module. A UI module function returns an HTML tag list, so once your modules are set you can save them and use them inside tests. my_mod_ui &lt;- function(id){ ns &lt;- NS(&quot;id&quot;) tagList( selectInput(ns(&quot;this&quot;), &quot;that&quot;, choices = LETTERS[1:4]) ) } my_mod_ui_test &lt;- tempfile(fileext = &quot;html&quot;) htmltools::save_html(my_mod_ui(&quot;test&quot;), my_mod_ui_test) # Some time later, and of course saved in the test folder, # not as a temp file golem::expect_html_equal(my_mod_ui(&quot;test&quot;), my_mod_ui_test) {golem} also provides two functions, expect_shinytag() and expect_shinytaglist(), that test if an object is of class &quot;shiny.tag&quot; or &quot;shiny.tag.list&quot;. Testing package launch: when launching golem::use_recommended_tests(), you’ll find a test built on top of {processx} that allows to check if the application is launch-able. Here’s a short description of what happens: # Standard testthat things context(&quot;launch&quot;) library(processx) testthat::test_that( &quot;app launches&quot;,{ # We&#39;re creating a new process that runs the app x &lt;- process$new( &quot;R&quot;, c( &quot;-e&quot;, # As we are in the tests/testthat dir, we&#39;re moving # two steps back before launching the whole package # and we try to launch the app &quot;setwd(&#39;../../&#39;); pkgload::load_all();run_app()&quot; ) ) # We leave some time for the app to launch # Configure this according to your need Sys.sleep(5) # We check that the app is alive expect_true(x$is_alive()) # We kill it x$kill() } ) Note: this specific configuration will possibly fail on Continuous integration platform as Gitlab CI or Travis. A workaround is to, inside your CI yml, first install the package with remotes::install_local(), and then replace the setwd (...) run_app() command with myuberapp::run_app(). For example: in .gitlab-ci.yml: test: stage: test script: - echo &quot;Running tests&quot; - R -e &#39;remotes::install_local()&#39; - R -e &#39;devtools::check()&#39; in test-golem.R: testthat::test_that( &quot;app launches&quot;,{ x &lt;- process$new( &quot;R&quot;, c( &quot;-e&quot;, &quot;datuberapp::run_app()&quot; ) ) Sys.sleep(5) expect_true(x$is_alive()) x$kill() } ) 3.1.2.2 Documenting Documenting packages is a natural thing for any R developer. Any exported function should have its own documentation, hence you are “forced” to document any user facing-function. Also, building a Shiny App as a package allows you to write standard R documentation: A README at the root of your package Vignettes that explain how to use your app A {pkgdown} that can be used as an external link for your application. 3.1.3 Deploy 3.1.3.1 Local deployment As your Shiny App is a standard package, it can be built as a tar.gz, sent to your colleagues, friends, and family, and even to the CRAN. It can also be installed in any R-package repository. Then, if you’ve built your app with {golem}, you’ll just have to do: library(myuberapp) run_app() to launch your app. 3.1.3.2 RStudio Connect &amp; Shiny Server Both these platforms expect a file app configuration, i.e an app.R file or ui.R / server.R files. So how can we integrate this “Shiny App as Package” into Connect or Shiny Server? Using an internal package manager like RStudio Package Manager, where the package app is installed, and then you simply have to create an app.R with the small piece of code from the section just before. Uploading the package folder to the server. In that scenario, you use the package folder as the app package, and upload the whole thing. Then, write an app.R that does: pkgload::load_all() shiny::shinyApp(ui = app_ui(), server = app_server) And of course, don’t forget to add this file in the .Rbuildignore! This is the file you’ll get if you run golem::add_rconnect_file(). 3.1.3.3 Docker containers In order to dockerize your app, simply install the package as any other package, and use as a CMD R -e 'options(&quot;shiny.port&quot;=80,shiny.host=&quot;0.0.0.0&quot;);myuberapp::run_app()'. Of course changing the port to the one you need. You’ll get the Dockerfile you need with golem::add_dockerfile(). 3.1.4 Resources R packages “Building a package that lasts” Writing R Extensions R package primer - a minimal tutorial 3.2 Using Shiny Modules 3.2.1 Small is beautiful Modules are one of the most powerful tool for building Shiny Application. But what are they? Shiny modules address the namespacing problem in Shiny UI and server logic, adding a level of abstraction beyond functions .right{ text-align: right;} Modularizing Shiny app code Let’s first untangle this quote with a simple example about what is shiny namespace problem. 3.2.1.1 One million “Validate” buttons Shiny needs its outputs and inputs to have a unique id. And unfortunately, we can’t bypass that: when you send a plot from R to the browser, i.e from the server to the ui, the browser needs to know exactly where to put this element. This “exactly where” is handled through the use of an id. Ids are not a Shiny specific concept: they are at the very root of the way web pages work. Understanding all of this is not the purpose of this chapter: just remember that Shiny inputs and outputs ids have to be unique, so that the browser knows where to put what it receives from R, and R knows what to listen to from the browser. The need to be unique is made a little bit complex by the way Shiny handles the names, as it share a global pool for all the id names, with no native way to use namespaces. Namespaces are a computer science concept which has been designed to handle a common issue: how to share the same name for a variable in various place of your program without them conflicting. In other words, how to use an object called foo several times in the program, and still be sure that it’s correctly used depending on the context. R itself has a system for namespaces ; that’s what packages do and why you can have purrr::flatten and jsonlite::flatten: the function name is the same, but the two live in different namespaces, and they can mean two different things, as the symbol is evaluated inside two different namespaces. If you want to learn more about namespaces, please refer to the 7.4 Special environments chapter from Advanced R. So, that’s what modules are made for: creating small namespaces where you can safely define ids without conflicting with other ids in the app. Why do we need to do that? Think about the number of times you’ve created a “ok” or “validate” button. How do you handle that? By creating validate1, validate2, and so on and so forth. And if you think about it, you’re mimicking a namespacing process: a validate in namespace 1, another in namespace 2. Consider this piece of code: library(shiny) ui &lt;- function(request){ fluidPage( sliderInput(&quot;choice1&quot;, &quot;choice 1&quot;, 1, 10, 5), actionButton(&quot;validate1&quot;, &quot;Validate choice 1&quot;), sliderInput(&quot;choice2&quot;, &quot;choice 2&quot;, 1, 10, 5), actionButton(&quot;validate2&quot;, &quot;Validate choice 2&quot;) ) } server &lt;- function( input, output, session ){ observeEvent( input$validate1 , { print(input$choice1) }) observeEvent( input$validate2 , { print(input$choice2) }) } shinyApp(ui, server) This, of course, is an approach that works. Well, it works as long as your code base is small. But how can you be sure that you’re not creating validate6 on line 55 and another on line 837? How can you be make sure that you’re deleting the correct combination of UI/server components if they are named that way? Also, how do you work smoothly in a context where you have to scroll from sliderInput(&quot;choice1&quot; to observeEvent( input$choice1 , { which might be separated by thousands of lines? 3.2.1.2 A bite-sized code base And of course, you know the saying that “if you copy and paste something more than twice, you should make a function”, so how do we refactor this piece of code so that it’s reusable? Yes, you guessed right: using shiny modules. Shiny modules aim at three things: simplifying id namespacing, split the code base into a series of functions, and allow UI/Server parts of your app to be reused. Most of the time, modules are used to do the two first: I’d say that 90% of the module I write are never reused13 ; they are here to allow me to split the code base into smaller, more manageable pieces. With Shiny modules, you’ll be writing a combination of UI and server functions. Think of them as small, standalone Shiny apps, which output and handle a fraction of your global application. If you’ve been developing R packages, you’d probably trying to split your functions into series of smaller functions, that’s the exact same thing: you are, with just a little bit of tweaking, doing the same thing. That is to say creating smaller functions that are easier to understand, develop and maintain. 3.2.2 A practical walk through 3.2.2.1 Your first Shiny Module So, here is how you’d refactor the example from before with modules: name_ui &lt;- function(id){ ns &lt;- NS(id) tagList( sliderInput(ns(&quot;choice&quot;), &quot;Choice&quot;, 1, 10, 5), actionButton(ns(&quot;validate&quot;), &quot;Validate Choice&quot;) ) } name_server &lt;- function(input, output, session){ ns &lt;- session$ns observeEvent( input$validate , { print(input$choice) }) } library(shiny) ui &lt;- function(request){ fluidPage( name_ui(&quot;name_ui_1&quot;), name_ui(&quot;name_ui_2&quot;) ) } server &lt;- function( input, output, session ){ callModule(name_server, &quot;name_ui_1&quot;) callModule(name_server, &quot;name_ui_2&quot;) } shinyApp(ui, server) Let’s stop for a minute and decompose what we’ve got here. The server function is pretty much the same as before: you’ll just be using the same code as the one you’ve been using so far. The ui function has some new things in it. Well, two new things, which are ns &lt;- NS(id) and ns(inputId). That’s where the namespacing happens. You can think about this function as a way to add a namespace to your id: you’ve been doing validate1 and validate2 before, now you’re doing this with the function created by ns &lt;- NS(id). You’ll find this little piece of code on top of all the module ui functions. To understand what it does, let’s try and run it outside of Shiny: id &lt;- &quot;name_ui_1&quot; ns &lt;- NS(id) ns(&quot;choice&quot;) [1] &quot;name_ui_1-choice&quot; And here it is, our namespaced id! And of course, calling it with various id will create various namespaces for the id, preventing you from id conflicts14. All you have to do now is to make sure that ids are unique at the “upper” levels. Then you can have as many validate input as you want in your app: as long as this validate is unique inside your module you’re good to go. The app_ui contains a series of call to module_ui_function(unique_id, ...) with potential parameters: name_ui &lt;- function(id, butname){ ns &lt;- NS(id) tagList( actionButton(ns(&quot;validate&quot;), butname) ) } name_ui(&quot;name_ui_1&quot;, &quot;Validate Choice&quot;) name_ui(&quot;name_ui_2&quot;, &quot;Validate Choice, again&quot;) &lt;button id=&quot;name_ui_1-validate&quot; type=&quot;button&quot; class=&quot;btn btn-default action-button&quot;&gt;Validate Choice&lt;/button&gt; &lt;button id=&quot;name_ui_2-validate&quot; type=&quot;button&quot; class=&quot;btn btn-default action-button&quot;&gt;Validate Choice, again&lt;/button&gt; The app_server side contains a series of callModule(module_server_function, unique_id, ...), with potential parameters. 3.2.2.2 Passing args to your modules Shiny modules will potentially be reused. It’s not the general pattern, but they can. In that case, you’ll potentially be using extra arguments to generate the UI and server conditionally. Let’s for example have a look at mod_dataviz.R from the {tidytuesday201942} Shiny application. This application contains 6 tabs, 4 of them being pretty much alike: a side bar with inputs, an a main panel with a button and the plot. This is a typical case where you should reuse modules: if two or more parts are relatively similar, it’s easier to bundle it inside a reusable module, and condition the ui/server with function arguments. Here, are some examples of how it works in the UI: mod_dataviz_ui &lt;- function(id, type = c(&quot;point&quot;, &quot;hist&quot;, &quot;boxplot&quot;, &quot;bar&quot;)){ h4( sprintf( &quot;Create a geom_%s&quot;, type ) ), if (type == &quot;boxplot&quot; | type ==&quot;bar&quot;) { selectInput( ns(&quot;x&quot;), &quot;x&quot;, choices = names_that_are(c(&quot;logical&quot;, &quot;character&quot;)) ) } else { selectInput( ns(&quot;x&quot;), &quot;x&quot;, choices = names_that_are(&quot;numeric&quot;) ) } } And in the server: mod_dataviz_server &lt;- function(input, output, session, type){ if (type == &quot;point&quot;){ x &lt;- rlang::sym(input$x) y &lt;- rlang::sym(input$y) color &lt;- rlang::sym(input$color) r$plot &lt;- ggplot( big_epa_cars, aes(!!x, !!y, color = !!color) ) + geom_point() + scale_color_manual( values = color_values( 1:length(unique(pull(big_epa_cars, !!color))), palette = input$palette ) ) } } Then, the app server is: app_server &lt;- function(input, output,session) { #callModule(mod_raw_server, &quot;raw_ui_1&quot;) callModule(mod_dataviz_server, &quot;dataviz_ui_1&quot;, type = &quot;point&quot;) callModule(mod_dataviz_server, &quot;dataviz_ui_2&quot;, type = &quot;hist&quot;) callModule(mod_dataviz_server, &quot;dataviz_ui_3&quot;, type = &quot;boxplot&quot;) callModule(mod_dataviz_server, &quot;dataviz_ui_4&quot;, type = &quot;bar&quot;) } And the UI: app_ui &lt;- function() { # [...] tagList( fluidRow( id = &quot;geom_point&quot;, mod_dataviz_ui(&quot;dataviz_ui_1&quot;, &quot;point&quot;) ), fluidRow( id = &quot;geom_hist&quot;, mod_dataviz_ui(&quot;dataviz_ui_2&quot;, &quot;hist&quot;) ) ) } 3.2.3 Communication between modules One of the hardest part about modules is sharing data across them. There are at least two approaches: returning reactive, or the “stratégie du petit r” (to be pronounced with a french accent). 3.2.3.1 Returning values from the module One common approach is return a reactive from one module, and to pass it to another. name_ui &lt;- function(id){ ns &lt;- NS(id) tagList( sliderInput(ns(&quot;choice&quot;), &quot;Choice&quot;, 1, 10, 5) ) } name_server &lt;- function(input, output, session){ ns &lt;- session$ns return( reactive({ input$choice }) ) } name_b_ui &lt;- function(id){ ns &lt;- NS(id) tagList( actionButton(ns(&quot;validate&quot;), &quot;Print&quot;) ) } name_b_server &lt;- function(input, output, session, react){ ns &lt;- session$ns observeEvent( input$validate , { print(react()) }) } library(shiny) ui &lt;- function(request){ fluidPage( name_ui(&quot;name_ui_1&quot;), name_b_ui(&quot;name_ui_2&quot;) ) } server &lt;- function( input, output, session ){ res &lt;- callModule(name_server, &quot;name_ui_1&quot;) callModule(name_b_server, &quot;name_ui_2&quot;, react = res) } shinyApp(ui, server) That works well, but for large Shiny Apps it might be hard to handle large list of reactive outputs / inputs. It might also create some reactivity issues, as they are harder to control. 3.2.3.2 The “stratégie du petit r” With this strategy, instead of passing reactives as function input, we’ll be creating a global reactive list which is passed along other modules. The idea is that it allows us to be less preoccupied about what your module takes as input. Here, we will be creating a “global” reactiveValues() that we will pass downstream. name_ui &lt;- function(id){ ns &lt;- NS(id) tagList( sliderInput(ns(&quot;choice&quot;), &quot;Choice&quot;, 1, 10, 5) ) } name_server &lt;- function(input, output, session, r){ ns &lt;- session$ns observeEvent( input$choice , { r$choice &lt;- input$choice }) } name_b_ui &lt;- function(id){ ns &lt;- NS(id) tagList( actionButton(ns(&quot;validate&quot;), &quot;Print&quot;) ) } name_b_server &lt;- function(input, output, session, r){ ns &lt;- session$ns observeEvent( input$validate , { print(r$choice) }) } library(shiny) ui &lt;- function(request){ fluidPage( name_ui(&quot;name_ui_1&quot;), name_b_ui(&quot;name_ui_2&quot;) ) } server &lt;- function( input, output, session ){ r &lt;- reactiveValues() callModule(name_server, &quot;name_ui_1&quot;, r) callModule(name_b_server, &quot;name_ui_2&quot;, r) } shinyApp(ui, server) The plus side of this method is that whenever you’re add something in one module, it’s immediately available in the other modules. The down side is that it can be harder to reason about the app, as the input / content of the r is not specified anywhere: as you don’t pass any arguments to your function other than r, you don’t really know what’s inside. Also, not that if you want to share your module, for example in a package, you should document the structure of the r. For example: #&#39; @param r a `reactiveValues()` with a `choice` element in it. This `r$choice` will be printed to the R console. 3.2.3.3 A third way There is another way to share data across modules, which is creating an R6 object which is then pass along the modules. In the spirit, it’s more or less the same as passing the r list, except that it is not a reactive object, making it more robust to the complexity of handling reactivity invalidation across modules. This methods is explain in the chapter Reactivity anti-patterns of this book. 3.2.3.4 When should you modularize? From the very beginning. The overhead of writing a module compared to putting everything inside the app function is relatively low: it’s even simpler if you are working in a framework like {golem}, which promotes the use of modules from the very beginning of your application. &quot;Yes but I just want to write a small app, nothing fancy Production apps almost always started as a small POC. Then the small POC becomes an interesting idea. Then this idea becomes a strategical asset. And before you know it your ‘not-that-fancy’ app needs to become larger 3.3 Splitting your app into files 3.3.1 Small is beautiful (bis repetita) There is nothing harder to maintain than a Shiny app which is only made of one 1000 lines long app.R. Well, there still is the 10 000 lines long app.R, but you’ve got the idea. Long scripts are almost always synonym of complexity when it comes to building an application. Of course, small and numerous scripts don’t systematically prevent from codebase complexity but they simplify collaboration and maintenance, and of course divide the application logic into smaller, easier to understand bits of code. So yes, big files are complex to handle and make development harder. Indeed, here is what happens when you’re working on a production application: You’ll be working during a long period of time (either in one run or split across several months) on your codebase, meaning that you’ll have to get back to pieces of code you have written a long time ago. You’ll possibly be developing with others. Maintaining a code base when several persons are working on the files is already a complex thing: from time to time you might be working on the same file separately, a situation where you’ll have to be careful about what and how you merge things when changes are implemented. Of course, it’s almost impossible to work on one same file all along the project without losing your mind: even more if this file is thousands of lines long. You’ll be implementing numerous features. Numerous features imply a lot of UI &amp; server interaction. And in an app.R file of thousands of line, it’s very hard to match the UI element with its server counterpart: when the UI is on line 50 and the server on line 570, you’ll be scrolling a lot when working on that element. So yes, there are a lot of reasons for splitting your application into smaller pieces: it’s easier to maintain, easier to decipher, and of course it facilitates collaboration. 3.3.2 Conventions matter So, now that we’ve talk about the benefits of splitting files, let’s think about how to do that. Splitting files is good, splitting files using a defined convention is better. Why? Because using a common convention for your files helps the other developers (and potentially you) to know exactly what is contained in a specific file, and that way it helps everybody know where to look for debugging / implementing new features. For example, if you follow {golem}’s convention, you’ll know that a file starting with mod_ contains a module, so if I take over a project, look in the R/ folder and see files starting with these three letters, I’ll know immediately what these files contain. That’s what we’ll see in this part: a proposition for a convention on how to split your application into smaller pieces. First of all, put everything into an R/ folder. If you’re building your app using the {golem} framework, this is already what you’re doing: using this package convention to hold the functions for your application. Once you’ve got this, here is the {golem}-specific convention for organizing your files: app_*.R (typically app_ui.R and app_server.R) should contain the top level functions which are used to defined your user interface and your server function. fct_* are files that contains business logic, potentially large functions. They are the backbone of the app but are potentially not specific to a given module. They can be added in {golem} with the add_fct(&quot;name&quot;) function. mod_* are files that contain ONE module. As many shiny apps contains a series of tabs, or at least a tab-like pattern, we suggest that you number then according to their step in the application. And as tabs are almost always named, you can use the tab-name as the file name. For example, if you’re building a dashboard and the first tab is called “Import”, your should name your file mod_01_import.R, which you can create with golem::add_module(&quot;01_import&quot;). Note that when building a module file with {golem}, you can add a fct_ and utils_ specific file, that will hold functions and utilities for this specific modules. For example, golem::add_module(&quot;01_import&quot;, fct = &quot;readr&quot;, utils = &quot;ui&quot;) will create R/mod_01_import.R, R/mod_01_import_fct_readr.R and R/mod_01_import_utils_ui.R. utils_* are files that contain utilities, which are small helper functions. For example, you might want to have a not_na, which is not_na &lt;- Negate(is.na), a not_null, or small tools that you’ll be using application-wide. Note that you can also create utils for a specific module. *_ui_*, for example utils_ui.R, relates to the user interface. Anything back-end can be noted using *_server_*, for example fct_connection_server.R will contain functions that are related to the connection to a database, and which are specifically used from the server side. Of course, as with any convention, you might be deviating from time to time from this pattern. Your app may not have that many functions, or maybe the functions can all fit into one utils_ file. But be it one or thousands of file, it’s always a good practice to stick to a formalized pattern. Most of the time, pieces / panels of the app are to unique too be reused elsewhere.↩ Well, of course you can still have inner module id conflicts, but they are easier to avoid, detect, and fix. ↩ "],
["golem.html", "Chapter 4 Introduction to {golem} 4.1 Getting started with {golem} 4.2 Understanding {golem} app structure", " Chapter 4 Introduction to {golem} OK, that’s a lot of things to process. Is there a tool that can help us simplify this workflow? Of course there is, and it’s called {golem}, a framework for building production-grade Shiny Application. 4.1 Getting started with {golem} {golem} is an R package that can be thought as a toolkit for simplifying the creation, development and deployment of Shiny applications. A lot of things in this book reflect the way {golem} and the packages from the “golem-verse” are designed. We advice to use {golem} if you plan on following the workflow described in this book, but of course the workflow will still be valid of you plan on not using {golem}. The stable release can be found on CRAN, and installed with: install.packages(&quot;golem&quot;) {golem} dev version can be found on GitHub and you’ll have to install it with: remotes::install_github(&quot;Thinkr-open/golem&quot;) The current version of the package on CRAN is: library(dplyr, warn.conflicts = FALSE) tools::CRAN_package_db() %&gt;% filter(Package == &quot;golem&quot;) %&gt;% select(Version) Version 1 0.1 While the current version of the dev version is: x &lt;- tempfile() download.file(&quot;https://raw.githubusercontent.com/ThinkR-open/golem/dev/DESCRIPTION&quot;, x) desc::desc_get_version(x) [1] &#39;0.1.0.9600&#39; {golem} is an R package that implements an opinionated framework for building production-ready Shiny apps. The motivation behind {golem} is that building a proof-of-concept application is easy, but things change when the application becomes larger and more complex, and especially when it comes to sending that app to production. And until recently there hasn’t been any real framework for building and deploying production-grade Shiny Apps. This is where {golem} comes into play: offering Shiny developers a toolkit for making a stable, easy-to-maintain, and robust for production web application with R. {golem} has been developed to abstract away the most common engineering tasks (for example, module creation, addition of external CSS or JavaScript file, …), so you can focus on what matters: building the application. And once your application is ready to be deployed, {golem} guides you through testing, and brings you tool for deploying to common platforms. Some things to keep in mind before using {golem}: A {golem} application is contained inside a package, so knowing how to build a package is recommended but not necessary. The good news is also that everything you know about package development can be applied to {golem}. A {golem} app works better if you are working with shiny modules, so knowing how modules work is also recommended but not necessary. 4.2 Understanding {golem} app structure When starting a new project with {golem} (here on an app called golex), you’ll start with this specific architecture. fs::dir_tree(&quot;golex&quot;) golex ├── DESCRIPTION ├── NAMESPACE ├── R │ ├── app_server.R │ ├── app_ui.R │ └── run_app.R ├── dev │ ├── 01_start.R │ ├── 02_dev.R │ ├── 03_deploy.R │ └── run_dev.R ├── inst │ └── app │ └── www │ ├── favicon.ico │ └── plop.js └── man └── run_app.Rd If you are familiar with packages, this structure will look familiar to you. And that’s for a good reason: an app built with {golem} IS a package. Let’s focus on these various elements for a moment in order to be sure you understand what part each file plays and how you can use (or not use) each of them. 4.2.1 DESCRIPTION &amp; NAMESPACE The DESCRIPTION and NAMESPACE are standard package files (i.e. they are not {golem}-specific). In the first, you’ll find a series of metadata about your package, for example who wrote the package, what’s the package version, what is its goal, who to complain to if things go wrong, and also information about external dependencies, the license, the encoding…. This DESCRIPTION file will be filled automatically by the first function you’ll run in dev/01_start.R, and by other functions from the dev/ scripts. In other words, most of the time you won’t interact with it directly, but through wrappers from {golem} and {usethis}. The NAMESPACE file is one of the most important file in your package. It’s also the one you’ll NEVER edit by end! R uses this one to define how to interact with the rest of the library: what function to import and from which package and what function to export, i.e what functions are available when you do library(golex). This file will be built when running the documenting process in your R package: {roxygen2} will scan all your .R files, and build the man/ + the NAMESPACE, by scanning the roxygen tags there. Explaining how these files are to be filled and how to document your functions is out of the scope of this book, as we hope if you’re reading this lines you’re already familiar with how to build a package. If you’d like to learn more about these, here are some resources you can refer to: Writing R Extensions - The DESCRIPTION file Writing R Extensions - Package namespaces R Packages - Package metadata R Packages - Namespace Building a package that lasts — eRum 2018 workshop 4.2.2 R/ The R/ folder is also the standard folder where you’ll be putting all your app functions. When you start your app project, this folder is pre-populated with three .R: app_server.R, app_ui.R, and run_app.R. During the process of building your application, all the core functionalities of your app will go there: you’ll put there the content of your modules (with golem::add_modules()) and the utilitarian / business logic functions you’ll build with golem::add_utils() and golem::add_fct(). If you want to add a standard file (that is to say out of {golem} nomenclature), you can call usethis::use_r(&quot;name&quot;), which create a R/name.R file. All your .R file should go there, with the only exception of the files you’ll create when deploying to RStudio products: these processes needing an app.R at the root of the project, the golem::add_rstudioconnect_file() will bypass this “.R only in R/” rule to add a file at your package root. Good news is that {golem} also knows that a package with an app.R at its root can’t build, so this file is added to the .Rbuildignore. If you’ve been building classic Shiny Apps, you’ve been use to source() your R files at the beginning of your app.R or ui.R/server.R. Keep in mind that, as we are building a package, we don’t need to source files from one place to another: {golem}, be it in the dev/run_dev.R, app.R for RStudio products, or running the run_app() function, leverages the package structure to allow you to have access to other functions from inside the whole R/ folder15. Note also that this folder can’t contain sub-folders. 4.2.2.1 app_server.R #&#39; @import shiny app_server &lt;- function(input, output,session) { # List the first level callModules here } This first function contains your server logic. If you’re familiar with the classic ‘ui.R / server.R’ methodology, this function can be thought of as a drop in replacement for the content of the function you’ve got in your server.R. Building a complex Shiny application commonly implies using Shiny modules. If so, you’ll be adding there a series of callModule(), the ones you’ll get on the very bottom of the file created with golem::add_module(). You’ll also find there global elements from your server-logic: top reactiveValues, connections to databases, options setting… 4.2.2.2 app_ui.R #&#39; @import shiny app_ui &lt;- function() { tagList( # Leave this function for adding external resources golem_add_external_resources(), # List the first level UI elements here fluidPage( h1(&quot;golex&quot;) ) ) } This piece of the app_ui.R is designed to received the counterpart of what you put in your server. Everything here is to be put after the # List the first level UI elements here line. Just as with their server counterparts, the UI side of these elements are the one from the bottom of the file you’re creating with golem::add_module(). By default, {golem} uses a fluidPage(), which is {shiny}’s most commonly used template. If ever you want to use navBarPage(), this is where you’ll define this: replace one with the other, and you’ll be good to go. You can also define any other template page, for example with an htmlTemplate(). Keep in mind that removing the fluidPage() here implies that there is no available CSS / JS template to be used anymore, and you’ll need to be adding your own there. #&#39; @import shiny golem_add_external_resources &lt;- function(){ addResourcePath( &#39;www&#39;, system.file(&#39;app/www&#39;, package = &#39;golex&#39;) ) tags$head( golem::activate_js(), golem::favicon() # Add here all the external resources # If you have a custom.css in the inst/app/www # Or for example, you can add shinyalert::useShinyalert() here #tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;) ) } The second part of this file contains the golem_add_external_resources() function, which is used to add, well, external resources. You may have noticed that this function is to be found above in the file, in the app_ui() function. This function is used for linking to external files inside your applications: notably the files you’ll create with golem::add_css_file() and friends. In golem_add_external_resources(), you can also define custom resourcesPath. The first line (the one with addResourcePath()) is the one allowing the inst/app/www folder to mounted and be available at www with your app when you launch it. That’s why later on, when creating CSS or JS files, you’ll be asked to add there tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;). The other part of this function, starting with tags$head, creates a &lt;head&gt; tag for your application. This &lt;head&gt; tag is a pretty standard tag, which is used in HTML to define a series of metadata about your app. We encourage you to add any new external file (e.g pictures) in this inst/app/www folder, so that you can later use it in the UI with the common www prefix. An other common pattern would be: Adding images in inst/app/img Calling addResourcePath( 'img', system.file('app/img', package = 'golex') ) Adding elements to your UI with tags$img(src = &quot;img/name.png&quot;). 4.2.2.3 run_app.R #&#39; Run the Shiny Application #&#39; #&#39; @export #&#39; @importFrom shiny shinyApp #&#39; @importFrom golem with_golem_options run_app &lt;- function(...) { with_golem_options( app = shinyApp(ui = app_ui, server = app_server), golem_opts = list(...) ) } This run_app()function is the one that you’ll use to launch the app16. The body of this function is wrapped inside with_golem_options(), which allows you to pass arguments to the run_app() function, which will later be callable with golem::get_golem_options(). Some example of passing arguments include run_app(prod = FALSE) or something in the like of run_app(user = &quot;admin). 4.2.3 inst/app/www/ The inst/app/www/ folder contains all the files which are gonna be made available at application run time. Any web application has external files that allows it to run17. For example, {shiny} and its fluidPage() bundles a series of CSS and JavaScript files, notably the Boostrap library, or jQuery. These external files enhance your app: CSS for the design part, and JavaScript for the interactive part (more or less). On top of that, you can add your own files: your own design with CSS, or your own JavaScript content (as we’ll see in the last chapters of this book). In order to work, you have to include, somewhere in the UI, a link to these files. That’s what the links in the golem_add_external_resources() are made for: linking the external resources that you’ll build with the following functions. golem::add_css_file() golem::add_js_file() golem::add_js_handler() golem::use_favicon() Be aware that these files are available under the www/ at application run time, i.e. that the www/ folder is available by your browser, not by R when it runs / generate your application. In other words, you can use the www prefix in the HTML generated in your UI, which is read by your browser, not from the R/server side. If you want to link to a file that is read during application generation, you’ll need to do, for example, includeMarkdown( system.file(&quot;app/www/plop.md&quot;, package = &quot;golex&quot;) ). 4.2.4 man/ This man/ folder includes the package documentation. It’s a common folder that is automatically filled when you document your app: notably when running the dev/run_dev.R script and the document_and_reload() function. As with the NAMESPACE and DESCRIPTION, these two files are out of scope of this book (and to be honest, you’ll probably never have to interact with them directly). To know more about documentation and how to build it, here are some external links: R Packages - Object documentation Building a package that lasts — eRum 2018 workshop Same goes for the dependencies: you’ll never have to call library() in an app built with {golem}.↩ Very technically speaking, it’s the print() from the object outputted by run_app() that launches the app, but that’s another story. ↩ Some webpages don’t need any external sources, as they don’t have any design and are plain HTML, but generally speaking we won’t call this format a web app. ↩ "],
["workflow.html", "Chapter 5 The workflow 5.1 Part 1: Design 5.2 Part 2: Prototype 5.3 Part 3: Build 5.4 Part 4: Secure 5.5 Part 5: Deploy", " Chapter 5 The workflow The recommended workflow for building successful Shiny Apps happens in five parts: Design, Prototype, Build, Secure and Deploy. 5.1 Part 1: Design The Design part is the time when you think about how you will conceive the application, before actually writing any line of code. It’s not Shiny nor R specific: it’s something software engineers have been doing for any software or web application: discuss with the clients, the end-users, and the developers that will work on the project. In this first part, you’ll discover some tools that will help you define how the application will be build, that is to say somewhere between users’ dreams, what’s technically possible, and the time you’ve got for building it. 5.2 Part 2: Prototype The Prototype step is the one during which you’ll be building the front-end and the back-end, but separately. As you may know, a Shiny application is an interface used to communicate information to the end-users. The general appearance, position of the inputs and outputs as well as graphical interactions need to be chosen with care. On the other hand, the back-end should be built carefully: people will potentially make decision based on what they learn from your app. That’s why you should take extra care building the UI, but also building the back-end. In this part, we will be talking about two processes: A ‘UI-first’ approach, with tools to build the skeleton of the application before engineering its core. A ‘Rmd-first’ approach, which focuses on the actual computation of the outputs. The idea here is to prototype the outputs outside of the application reactivity. This ‘Rmd first’ method is designed to help you focus on the core of the application outside of any reactive context, and also to develop functions and write the documentation with visual outputs and example data. Here, we are building the two sides of the app separately: the core back-end can be outputted to HTML documents that can be sent and validated by the clients, and the front-end can be tested without actual implementation of the back-end. 5.3 Part 3: Build The Build step is the one where you’ll be working on combining the business (or back-end) logic with the front-end. In this step 3, you’ll be working on the core engine of the application. If you’re planning on building a robust Shiny application, you’ll have to start using the correct development tools. In this part, you’ll see how you can upgrade your development workflow using {golem}, a package which has been created to help you design a robust and maintainable Shiny application. 5.4 Part 4: Secure Securing your app is ensuring your application will last forever. This might seem like a hard task, but some good practices will help you all along life-cycle of the app. In this part, we will go through unit tests, reproducible development environment, version control and continuous integration in the context of Shiny applications. 5.5 Part 5: Deploy To Deploy is to send your application to production. Being exhaustive here is an impossible task as there are numerous ways to make your application accessible to its targeted users. But we’ll try to provide some! In this part, we will quickly present a series of methods to deploy your application on various environments, and show how you can use {golem} to make this task easier. "],
["matters.html", "Chapter 6 UX Matters 6.1 Simplicity is Gold 6.2 The danger of feature-creep 6.3 Web Accessibility Title", " Chapter 6 UX Matters We have a natural tendency, as R-coders, to be focused on the back-end, i.e the server part of the application18. Which is perfectly normal—chances are you didn’t come to R to design front-ends.19 But let’s state the truth: no matter how complex and innovative your backend is, your application is bad if your User Experience (UX) is bad. That’s the hard truth. If people can’t understand how to use your application, your application isn’t successful, no matter how incredible the backend is. This natural taste for back-end / server logic can deserve you on the long run: by neglecting the UI and the UX, you’ll make your application less likely to be adopted among your users. Which is a good way to fail your application project. 6.1 Simplicity is Gold “Simplify, then add lightness” Colin Chapman CBE, Founder of Lotus Cars There are mainly two contexts where you’ll be building a web app with R: one for professional use (i.e people will rely on this app to do their job), or for fun (i.e people will just use the app as a distraction). But in both cases, people will want the app to be usable, and easily usable. If people use your app in a professional context, they don’t want to fight with your interface, read complex manuals, or lose time understanding what they are supposed to do and how they are supposed to use your application. In other words, they want an efficient tool: something that, beyond being accurate, is easy to grasp. In a professional context, when it comes to “Business applications”, remember that the easier the learning curve the better the user experience. Think about all the professional applications and softwares that you’ve been ranting about during your professional life, all these cranky user interfaces you haven’t understand and/or you need to relearn every time you use them. You don’t want your app to be one of these applications. And on the other end, if users open your app for fun, they are not going to fight your app into submission: they are just going to give up if it’s too complex to be used. Even a game has to appear easy to use when the users open it. Aiming for simplicity is a hard thing, but following some rules will help you start on a solid ground. In this section, we’ll review two general principals: the “don’t make me think” principle, which states that interfaces should be as self-explanatory as possible, and the “Rule of least surprise”, stating that elements should behave the way they are commonly expected to behave. These two rules aim at solving one issue: the bigger the cognitive load of your app is, the harder it will be for the end-user to use your app on a daily basis. And of course, the less a success your project will be. 6.1.1 How we read the web: scanning content One big lie we tell ourselves as developer is that end-user will use the app the way we designed it to be used. We love to think that when faced to our app, the users will carefully read the instructions, make a rational decision based on careful examination of the inputs, before doing what we expect them to do. But the harsh truth is that it’s not how what happens. First of all, user rarely read carefully all the instructions: they scan, and perform the first action that more or less match what they need to do, i.e the satisfice. FROM ‘Don’t make me think’, Steve Krug For example, let’s have a look at the user interface of hexmake, a Shiny app for building hex stickers, available at https://connect.thinkr.fr/hexmake/ What will be your reading pattern for this application? What is the first thing you’ll do when using this app? There is an inherent logic in the application: each submenu is designed to handle one specific part of your sticker. The last-but-one menu is the one used to download the sticker, and the last one the menu to open the “how to” of the app. When opening this app, will your fist move be to open the how to? Will you open all the sub-menu and select the most “logical” one to start with? Chances are that reading this line, you think you’ll do that. But in reality, we behave less rationally that we’d like to think. What we most of the time do is click on the first thing that matches what we are here to do. For example, most of the time we will first change the package name, or upload an image, before even opening the about section of this app. Once user have scanned the page, they perform the first action that seems reasonable. Or as coined in “Rational Choice and the Structure of the Environment” by Herbert A. Simon, &quot; organisms adapt well enough to “satisfice”; they do not, in general, “optimize.”“. In other words, ”As soon as we find a link that seems like it might lead to what we’re looking for, there’s a very good chance that we’ll click it&quot; (’Don’t make me think’, Steve Krug). What that also means is that user might perform what you’d expect to be “irrational” choices. As they are scanning your webpage, they might do something unexpected, or use a part of your app in a way that you wouldn’t expect it to be used. For example, if you are creating an app that is designed to take as input data that comes under a specific form, you need to check that this requirement is fulfill, or you’ll end up debugging errors on uncommon datasets. This is a pretty common thing about apps and about software in general: you have to expect users to use your product in ways you wouldn’t have expect, in way that might seem absurd to you. For example, consider this small app: library(shiny) ui &lt;- function(request){ tagList( selectInput( &quot;species&quot;, &quot;Choose one or more species&quot;, choices = unique(iris$Species), multiple = TRUE, selected = unique(iris$Species)[1] ), plotOutput(&quot;plt&quot;) ) } server &lt;- function( input, output, session ){ output$plt &lt;- renderPlot({ plot( iris[ iris$Species %in% input$species, ] ) }) } shinyApp(ui, server) What’s wrong with this app? Probably nothing from a developer point of view: there’s a label expliciting that one should select one or more element from the dropdown, and then something is plotted. Pretty standard. But what happen if the dropdown is empty? Our first conception would be that this would never happen, as it’s explicitly specified that there should be one or more elements selected. In fact, chances are that even with this label, users will eventually end up with an empty selectInput, leading to the printing of an error where the plot should be. What should we do? Adopt a defensive programming mindset. Every time you create interactive elements, inputs and outputs, or things the user might interact with, ask yourself: “what if [that crazy thing] happens? How do I handle the case where the minimal viable requirements for my app are not met?”. And in fact, you shouldn’t be focusing on that only for the user side: the backed should also be examined for potential unexpected behavior. For example, if your Shiny app relies on a database connection, you should check gracefully that the connection is possible, and if it’s not, send a message to your user that the database is not reachable, and that they should either restart the app or come back in a few minutes. In fact, this is a crucial thing when it comes to making your app successful: you should always fail gracefully and informatively. That means that when your R code fails, the whole app shouldn’t fail. If the R code fails for some reason, the user should get back either nothing or an informative bug message, not be faced with a grey page over the application. Because of the way Shiny is designed, a lot of R errors will make the Shiny app fail completely. If you haven’t think about this upfront, that means that a user might use the app for say 10 minutes, do a series of specifications, enter parameters and data, and at some point the app completely crashes. Then the user has to restart from scratches, because there is no native way, from there, to restart from where the app has crashed. This is a very important thing to keep in mind when building Shiny app: once the app has failed, there is no easy way to get it back to the moment just before it crashed, meaning that your users might lose a significant amount of time they have spent configuring the app. 6.1.2 A self-evident app (or at least self-explanatory) One of the goal of a usable app is to make it self-evident, and fall back to a self explanatory app if the first option is too complex a goal. What’s the difference between the two? self-evident : “Not needing to be demonstrated or explained; obvious.” lexico.com self-explanatory : “Easily understood; not needing explanation.” https://www.lexico.com/en/definition/self_explanatory So the first is that the app is designed in such a way that there is no learning curve to using it. A self-explanatory app has a small learning curve, but it’s designed in a way that will make the user understand it in a matter of seconds. Let’s for example get back to our {tidytuesday201942} application available at connect.thinkr.fr/tidytuesday201942 By itself, this application is not self-evident: you need to have a series of background knowledge before understanding what this application was designed for. For example, you might need to have a vague sense of what tidytuesday is. If you don’t, you’ll have to read the home text, which will help you understand what this is. Then, if we have a look at the menu, we see that these are a series of functions from {ggplot2}: without any background about the package, you might find it difficult understanding what this app actually does. Yet, if you want to understand what this app is designed for, you’ll find enough information either on the home page or in the About section, with external links if needed. And of course, when building apps, context matters. The {tidytuesday201942} app is one that has been developed in the context of tidytuesday, an online weekly event for learning data analysis, mainly through the use of {tidyverse} packages. So there is a good chance visitors of the app will already know what is {ggplot2} when visiting the app. 6.1.2.1 The “Rule of Least Surprise” Also know as “Principle of Least Astonishment.” Rule of Least Surprise: In interface design, always do the least surprising thing. .right{ text-align: right;} 'Basic of the Unix Philosophy', Eric Steven Raymond When we are browsing the web, we have a series of pre-conception about what things are and what they do. For example, we expect an underline text to be clickable: so there’s a good chance that if you use underline text inside your app, the user will try to click on it. Usually, the link is also colored differently from the rest of the text. Same goes for the pointer of the mouse, which usually switch from an arrow to a small hand with a finger up. A lot of other conventions exist on the web, and you should endeavor to follow them: a clickable link should have at least one of the properties we just described—and if it’s neither underlined nor colored nor changing the pointer when it’s hovered, chances are that the user won’t click on it. Just imagine for a second if our “Download” button in the {tidytuesday201942} app didn’t actually download the graph you had generated. Even more, imagine if this button didn’t download the graph but something else. How would you feel about this experience? And it’s not just about links: almost every visual elements on a web page is surrounded by conventions. Buttons should have borders. Links should appear clickable. Bigger texts are headers. Elements “visually nested” are related. Etc. Weirdly enough, that’s an easy thing to spot when we arrive on a webpage / an app: it can either feel “natural”, or you can immediately see that something is off. The hard thing is that it’s something you spot when you are a new-comer: developing the app makes us so familiar with the app that we might miss when something is not used the way it’s conventionally used20. Let’s exemplify this with the “Render” button from the {tidytuesday201942} application. This app is built on top of Bootstrap 4, which has no CSS class for {shiny} action button21. Result: without any further CSS, the buttons don’t come out as buttons, making it harder to decipher they are actually buttons. Compare this native design: To the one with a little bit of CSS (which is the one online): Yes, it’s subtle, yet the second version of the button is clearer to understand. Least surprise is crucial to make the user experience a good one: users rarely think that if something is behaving unexpectedly on an app it’s because of the app—they’ll usually think it’s their fault. When users are astonished they usually assume that they have made a mistake; they are unlikely to realize that the page has astonished them. They are more likely to feel that they are at fault for not anticipating the page. Don’t take advantage of this; making users feel stupid is not endearing. .right{ text-align: right;} The cranky user: The Principle of Least Astonishment 6.1.2.2 Think about the progression If there is a progression in your app, you should have designed a clear pattern of moving forward. If you need to bring your user from step 1 to step 7, you need to guide them through the whole process, and it can be as simple as putting “Next” buttons on the bottom of each page. Inside your app, this progression has to be clear, even more if step n+1 relies on the inputs from n. A good and simple way to do that is to hide elements at step n+1 until all the requirements are fulfilled at step n. Indeed, you can be sure that if step 2 relies on step 1 and you didn’t hide step 2 until you have everything you need, users will go to step 2 too soon. Another way to help this readability is to ensure some kind of linear logic through the app: step 1, data upload, step 2, data cleaning, step 3, data visualization, step 4, exporting the report. And organised your application around this logic, from left to right / right to left, or from top to bottom. Let’s compare {tidytuesday201942} to {hexmake} — one has a clear progression, {hexmake}, and has been designed as such: the upper menus design the stickers, and then once they are filled you can download them. So there’s a progression here, from top to bottom. On the other hand, the {tidytuesday201942} doesn’t have a progression inside it: you can navigate from one tab to the other indifferently. Hence there is no visual clues of progression on that app. 6.1.2.3 Inputs and errors You’re the one developing the app, so of course you’re conscious of all the inputs that are needed to complete a specific task. But your user might be new to the app, distracted while reading, they might not clearly understand what they are doing, maybe they don’t really want to use your app but are forced to by their boss… Or maybe your app is a little bit hard to understand, so it’s hard to know what to do at first. When building your app, you should make sure that if an input is necessary, it’s made clear inside the app. One way to do this is simply by hiding UI elements that can’t be used until all the necessary inputs are there. For example, if you’re building a dashboard and tab 2 needs specific inputs from tab 1, then tab 3 specific inputs from tab 2, then be sure that tab 2 and 3 are not clickable / available until all the required inputs are filled. That way, you can help the user navigate through the app, by reducing the cognitive load of having to be sure that everything is correctly set-up: if it’s not clickable, that’s because something is missing. Think about all the time when you’re ordering something on the internet, and need to fill specific fields before being able to click on the “Validate” button. Well, apply that approach to your app, that will prevent from unwanted mistakes. Note that when using the golem::use_utils_ui() function, you’ll end with a script of UI tools, one being with_red_star, which adds a little red star at the end of the text you’re entering: with_red_star(&quot;Enter your name here&quot;) Enter your name here* Also, be generous when it comes to errors: it’s rather frustrating for a user to see an app crash without any explanation about what went wrong. So, if something fails or behaves unexpectedly, error messages are a key feature to help your user get on the right track. And, at the same time, helping them correct themselves after an error is the best way to save you time answering angry emails! Let’s refactor our app from before: library(shiny) ui &lt;- function(request){ tagList( selectInput( &quot;species&quot;, &quot;Choose one or more species&quot;, choices = unique(iris$Species), multiple = TRUE, selected = unique(iris$Species)[1] ), plotOutput(&quot;plt&quot;) ) } server &lt;- function( input, output, session ){ output$plt &lt;- renderPlot({ if (length(input$species) == 0){ shiny::showNotification( type = &quot;error&quot;, &quot;Species can&#39;t be empty&quot; ) } req(input$species) plot( iris[ iris$Species %in% input$species, ] ) }) } shinyApp(ui, server) Here, as a user, it’s way easier to understand what went wrong: we’ve moved from a red error Error: need finite 'xlim' values to a pop-up explaining what went wrong in the way the user configured the app. Perfect way to reduce your bug tracker incoming tickets! This is a way to do it natively in Shiny, but note that you can also use the {shinyAlert} package to implement alerts. It’s also possible to build your own with a little bit of HTML, CSS and JavaScript. 6.2 The danger of feature-creep 6.2.1 What’s feature-creep? Feature-creep is the process of adding features to the app that complexify the using of the product, to the point that extreme feature-creep can lead to the product being entirely unusable. This movement always starts well-intentioned: easier navigation, more information, more visualizations, modifiable elements, and so on and so forth. It can come from project managers or dev, but users can also be responsible for asking more and more features in the app. If you’re working in a context where the app specifications where designed by the users, or where you regularly meet the users for their feedbacks, they’ll most of the time be asking for more than what is efficiently implementable. Behind feature-creep, there is always a will to make the user experience better, but adding more and more things most of the time leads to a slower app, worst user experience, steeper learning curve, and all these bad states you don’t want your app to be into. Let’s take a rather common data analytic process: querying data, cleaning them, then plotting and summarizing them. And let’s say that we want to add to this a simple admin dashboard, that tracks what the users do in the app. It’s pretty tempting to think of this as a single thing an throw the whole code base into one big project and hope for the best. But let’s decompose what we’ve got there for a minute: one task is querying and cleaning, one other is analyzing, and one other is administration. What’s the point of having one big app for these three unlinked tasks? Splitting this all project into three smaller apps will keep you from having a large app which is harder to maintain, and that might be less performing. Indeed, if you put everything into the same app, you’ll have to add extra mechanisms to prevent the admin panel from loading if your user simply wants to go to the extraction step, and vice versa: a user visiting the admin panel probably doesn’t need the extraction and analysis backend to be loaded when they simply want to browse the way other users have been using the app. Or, as simply put in The Art of Unix Programing: Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do. But let’s focus on a smaller scope, and think about some things that can be thought of as feature-creeping your Shiny app. 6.2.2 Restrain reactivity When designing an app, you’ll be thinking about the way users will navigate through the app. And most of the time, we design with “correct selection” in mind. Something like: “The user will select 40 on the sliderInput() and the plot will update automatically. Then the user will select the element they need in the selectInput() and the plot will update automatically”. When the reality will be more like: &quot;The user will click on the slider, aim at 40 but will reach 45, then 37, before having the right amount of 40. Then they’ll select something in the selectInput(), but chances are not the correct one from the first time. In real life usage, people make mistakes using the app, so if the application reacts to their every moves, the experience using the app can be bad: in the example above, full reactivity means that you might get 4 “wrong” recomputation of the plot before getting it right. In the {tidytuesday201942} application example, let’s imagine all the elements on the left automatically update the plot: especially in a context of a learning tool, reacting to any configuration change will launch a lot of useless computation, slowing the app on the long run. So what should we do? Prevent ourselves from implementing “full reactivity”: instead, we’ll add a user input that will launch the computation. The simplest solution being a button so that the user signals to the application than now they are ready for the application to compute what they have parametrized. 6.2.3 Too much interactivity Users love interactive elements. Maybe too much. If you present a user with a choice between a simple graph and a dynamic one, chances are that they’ll spontaneously go for the dynamic graph. Yet, dynamic is not always the solution, and for several reasons. 6.2.3.1 Speed Dynamic elements are slower to render than fixed one. Most of the time (if not always), rendering dynamic elements means that you’ll bind some external libraries, and maybe you’ll have to make R convert data from one format to another. For example, rendering a {ggplot2} plot will be faster than rendering a ggplotly() plot, which has to convert from one format to another22. 6.2.3.2 Visual noise The more the interactivity, the less straightforward the element is. Think for a minute about the {plotly} outputs. They are awesome if you need this kind of interactivity, but for a common plot there might be too many things to understand. Instead of focusing on the data, a lot of things show: buttons to zoom, to do selection, to export in png, and things like that. With this kind of graphs, users might lose some time focusing on understanding what the buttons do and why they are there, instead of focusing what on what matters: getting insights from the data. Of course these feature are awesome if you need them: exploring data interactively is a fundamental strength when the context is right. But if there is no solid reason for using an interactive table, use a standard HTML table. In other words, don’t make things interactive if there is no value in adding interactivity ; for example, if the users don’t need to sort the table, filter, navigate in pages, DT::datatable() will add more visual noise than adding value to the application. Adding interactivity widgets (in most cases) means adding visual elements to your original content: in other words, you’re adding visual components that might distract the user from focusing on the content of the information. To sum up, a good rule to live by is that you shouldn’t add a feature for the sake of adding a feature. Less is more. .right{ text-align: right;} Ludwig Mies van der Rohe 6.3 Web Accessibility 6.3.1 About Accessibility When building professional Shiny applications, you have to keep in mind that, potentially, this app will be consume by a large audience. A large audience means that there’s a chance that your app will be used by people with visual, mobility, or maybe cognitive disabilities23. Web Accessibility deals with the process of making the web available to people with disabilities. The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability. When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. .right{ text-align: right;} Accessibility in Context - The Web Accessibility Initiative When learning to code a web app through “canonical” courses, you’ll be introduced to web Accessibility very early. For example, you can learn about this straight from the first chapter of learn.freecodecamp.org. The first course, “Responsive Web Design Certification”, has a chapter on web accessibility just after the one on HTML and CSS. 6.3.2 Making your App Accessible 6.3.2.1 Hierarchy Headers are not just there to make your application stylish. &lt;h1&gt; to &lt;h6&gt; are there so they can create a hierarchy inside your webpage: &lt;h1&gt; being more important (hierarchically speaking) than &lt;h2&gt;. In a perfectly designed website, you’d only have one header of level 1, a small amount of level 2 headers, more header of level 3, etc. Hence, you shouldn’t rely on the header level for styling: don’t use an &lt;h1&gt; because you need a larger title somewhere in your app. If you want to increase the size of an header, use CSS, which we will see in an upcoming chapter. 6.3.2.2 HTML element: Semantic tags, and tags metadata In HTML, there are two kind of elements: the one without “meanings” like &lt;div&gt; or &lt;span&gt;, and the one which are considered meaningful, like &lt;title&gt; or &lt;article&gt;. The second ones are called “semantic tags”, as they have a specific meaning in the sens that they define what they contain. library(htmltools) tags$article( tags$h2(&quot;Title&quot;), tags$div(&quot;Content&quot;) ) Title Content One other HTML method you can use is tags attributes as metadata. Tags attributes are complementary elements you can add to a tag to add information: most of the time, you’ll be using it to add a CSS class, and identifier, or maybe some events like onclick24. But these can also be used to add, for example, an alternate text to an image: this alt being the one which is read when the image is not available, either because the page couldn’t reach the resource, or because the person navigating the app is using a screen to speech technology. library(shiny) ui &lt;- function(request){ tagList( plotOutput(&quot;plot&quot;) %&gt;% tagAppendAttributes(alt = &quot;Plot of iris&quot;) ) } server &lt;- function( input, output, session ){ output$plot &lt;- renderPlot({ plot(iris) }) } shinyApp(ui, server) What makes these two things similar (semantic tags and tags metadata) is that they are both unseen by user without any impairment: if the image is correctly rendered and the user is capable of reading images, chances are that this user will see the image. But these elements are made for people with disabilities, and especially users who might be using screen to speech technologies: these visitors use a software that scans the textual content of the page and reads it, and that helps navigate through the page. This navigation is also crucial when it comes to screen to speech technology: these softwares will be able to read the &lt;title&gt; tag, jump to the &lt;nav&gt;, or straight to the &lt;article&gt; on the page. Hence the importance of structuring the page: these technologies need the app to be built in a structured way, so that it’s possible to jump from one section to another, and other common tasks a fully capable user will commonly do. Some other tags exists and can be used for semantic purpose: for example &lt;address&gt;, &lt;video&gt;, or &lt;label&gt;. 6.3.2.3 Navigation Your app user might also have mobility impairment. For example, some with Parkinson might be using your app, or someone with a handicap making it harder for them to move their hand and click. For these users, moving an arm to grab the mouse might be challenging, and they might be navigating the web using their keyboard only. When building your app, thinking about how these users will be able to use it is crucial: maybe there are so may button they need to click that they won’t be able to use it. So, as much as possible, make everything doable with a keyboard: for example, if you have a textInput() with a validation button below, allow the user to validate by pressing the ENTER on their keyboard. library(shiny) ui &lt;- function(request){ tagList( textInput(&quot;text&quot;, &quot;title&quot;) %&gt;% tagAppendAttributes( onKeyPress = &quot;Shiny.setInputValue(&#39;keypress&#39;, {value : event.key}, {priority: &#39;event&#39;})&quot; ), actionButton(&quot;go&quot;, &quot;Go&quot;) ) } server &lt;- function( input, output, session ){ observeEvent( input$keypress , { if (input$keypress$value == &quot;Enter&quot;){ # ... } }) } shinyApp(ui, server) Note that if you need a more systemic way to do this, you can do it with the {nter} package: # Taken from https://github.com/JohnCoene/nter library(nter) library(shiny) ui &lt;- fluidPage( textInput(&quot;text&quot;, &quot;&quot;), actionButton(&quot;send&quot;, &quot;Don&#39;t click hit enter&quot;), verbatimTextOutput(&quot;typed&quot;), nter(&quot;send&quot;, &quot;text&quot;) # trigger &#39;send&#39; button when &#39;text&#39; is active. ) server &lt;- function(input, output) { txt &lt;- eventReactive(input$send, { input$text }) output$typed &lt;- renderPrint(txt()) } shinyApp(ui, server) Listening on http://127.0.0.1:8930 6.3.2.4 Color choices Color blindness is also a common impairment when it comes to web accessibility. And it’s a rather common deficiency: according to colourblindawareness.org, “color (color) blindness (color vision deficiency, or CVD) affects approximately 1 in 12 men (8%) and 1 in 200 women in the world”. Keeping in mind this prevalence of color blindness is even more important in the context of Shiny, where we are developing data science products, which most of the time include data visualization. If designed wrong, dataviz can be unreadable for some specific type of color blindness. That’s why we recommend using the viridis palette, which has been created to be readable by the most common types of color blindness. Here are for example a visualization through the lens of various type of color blindness: # Function to generate the graph with_palette &lt;- function(palette) { x &lt;- y &lt;- seq(-8 * pi, 8 * pi, len = 40) r &lt;- sqrt(outer(x^2, y^2, &quot;+&quot;)) filled.contour(cos(r^2) * exp(-r / (2 * pi)), axes = FALSE, color.palette = palette, asp = 1 ) } With the jet.colors palette from {matlab} with_palette(matlab::jet.colors) with_palette(viridis::viridis) Even without color-blindness, it’s already way more readable. But let’s now use the {dichromat} package to simulate color blindness. library(dichromat) library(purrr) Deutan with jet.colors and viridis graph &lt;- partial(dichromat, type = &quot;deutan&quot;) with_palette( compose( graph, matlab::jet.colors ) ) with_palette( compose( graph, viridis::viridis ) ) Protan with jet.colors and viridis graph &lt;- partial(dichromat, type = &quot;protan&quot;) with_palette( compose( graph, matlab::jet.colors ) ) with_palette( compose( graph, viridis::viridis ) ) Tritan with jet.colors and viridis graph &lt;- partial(dichromat, type = &quot;tritan&quot;) with_palette( compose( graph, matlab::jet.colors ) ) with_palette( compose( graph, viridis::viridis ) ) par(mfrow=c(2,1)) with_palette( compose( partial(dichromat, type = &quot;deutan&quot;), matlab::jet.colors ) ) with_palette( compose( partial(dichromat, type = &quot;deutan&quot;), viridis::viridis ) ) As you can see, the viridis palette always gives a more readable graph than the jet.colors one. And, the plus side, it looks fantastic. So don’t hesitate to try and use it! 6.3.3 Evaluating your App Accessibility &amp; Further reading Evaluating Web Accessibility, with lengthy reports and advice about checking the accessibility of your website https://www.webaccessibility.com/ has an online checker for webpage accessibility, and allows you to freely test 5 pages. {hexmake} accessibility results aka what happens in the server side of a Shiny App↩ Front-end are the visual parts of your application, the one your user interacts with, as opposed to the back-end, which is what is installed on the server, the part the end user doesn’t see. In Shiny, front-end is what correspond to the UI, back-end to the server.↩ For a good summary of these, see The cranky user: The Principle of Least Astonishment↩ {shiny} is built on top of Bootstrap 3, and the action buttons are of class btn-default, which was removed in Bootstrap 4.↩ Well, maybe the native {plotly} implementation is faster, but you get the spirit.↩ And of course, other type of disabilities.↩ See the JavaScript chapter.↩ "],
["step-design.html", "Chapter 7 Don’t rush into coding 7.1 Designing before coding 7.2 Ask questions", " Chapter 7 Don’t rush into coding 7.1 Designing before coding You have to believe that software design is a craft worth all the intelligence, creativity, and passion you can muster. Otherwise you won’t look past the easy, stereotyped ways of approaching design and implementation; you’ll rush into coding when you should be thinking. You’ll carelessly complicate when you should be relentlessly simplifying — and then you’ll wonder why your code bloats and debugging is so hard. .right{ text-align: right;} The Art of Unix Programming - Attitude Matters Too 7.1.1 The Urge to Code At the moment you receive the specifications for your app, it’s tempting to rush into coding. And that’s perfectly normal: we’re Shiny developer because we love building softwares, so as soon as a problem emerges, our brain starts thinking about technical implementation, packages, pieces of code, and all these things that we love to do when we’re building an app. Rushing into coding from the very beginning is not the safest way to go. Focusing on technical details from the very beginning can make you miss the big picture, be it for the whole app if you’re in charge of the project, or for the piece of the whole app you’ve been assigned to. Have you ever faced a situation in a coding project where you tell yourself “Oh, I wish I had realised this sooner, because now I need to refactor a lot of my code for this specific thing”? Yes, we all have been in this situation: realising too late that the thing we’ve implemented doesn’t work with another feature we discover along the road. And what about &quot;Oh I wish I had realised sooner that this package existed before trying to implement my own fonctions to do that!. Yes, same thing: we’re jumping straight into solving programming problem when someone else has open-sourced a solution to this very same problem. Of course, implementing your own solution might be a good thing in specific cases: avoiding heavy dependencies, incompatible licensing, the joy of intellectual challenge… But when building production softwares, it’s safer to go for an existing solution if it exists and fits in the project: existing packages / software benefit from wider testing, wider documentation, and a larger audience if you need to ask questions. So, before rushing into coding, take some time to conceptualise your application / module on a piece of paper. That will help you get the big picture for the piece of code you’ll be writing: what are the inputs, what are the outputs, what packages / services you can use inside your application, how it will fit in the rest of the project. 7.1.2 About Concept Map // TODO 7.2 Ask questions Before starting to code, the safe call will be to ask your team/client (depending on the project) a series of question just to get a good grasp of the whole project. Here is a (non-exhaustive) list of information you might need along the way. Side note: of course, these questions do not cover the core functionning of the application: I’m pretty sure you’ve thought about covering this already. These are more contextual questions which are not directly linked to the application itself 7.2.1 About the end users Who are the end users of your app? Are they tech-literate? In which context will they be using your app? On what machines, and in what context? Will they be using the app in their office, on their phone while driving a tractor, in a plant while wearing lab coats? That might seems like weird questions if you’re just focusing on the very technical side of the app implementation, but think about where the app will be used: the application used while driving agricultural machineries might need less interactive things, bigger fonts, simpler interface, less details and more direct information. If you’re building a Shiny app for a team of sellers who are always on the road, chances are they’ll need an app that they can browse from their mobile. And developing for mobiles requires a different kind of mindeset25. Another good reason why talking to the users is an important step is that most of the time, people writing specifications are not the end users and will ask either for too much features or not enough. Do the users really need that much interactive plots? Do they actually need that much granularity in the information? Will they really read a datatable of 15k lines? Do they really care about being able to zoom in the dygraph so that they can see the point at a minute scale? To what extent does the app has to be fast? Asking these questions is important, because building interactive wigets makes the app a little bit slower, and shoving a series of unnecessary widgets will make the user experience worse. The speed of execution of your app is also an important parameter for your application: getting a sense about the need for speed in your application will allow you to judge wether or not you’ll have to focus on optimizing code execution. On top of that, remember all these things we’ve seen in the last chapter about accessibility: some of your end users might have specific accessibility requirements. 7.2.2 Pre-existing code-base From time to time, you’re building a Shiny app on top of an existing code-base: either scripts with business logic, a package if you’re lucky, or a POC for a Shiny app. 7.2.3 Deployment There are so many considerations about deployment that it will be very hard to list them all here, but keep in mind that if you don’t ask questions about where to deploy your app from the start, you might have bad surprises when you’ll send your app to production. Of course, it’s more or less solved if you’re deploying with Docker: if it works in a container on your machine, it should work in production. But that’s just the tip of the iceberg. One time, we built an app that had to do some API requests. So far so good, nothing too complicated… until we discovered that the server where the app will be deployed doesn’t have access to the internet, making it impossible to issue API requests from the server. Here, the containers worked on our machine, as they had access to the internet. Once deployed, the app stopped working, and we lose a couple of days of exchanges with the client, trying to debug our API calls, until we realised that the issue wasn’t with our app, but with the server itself. It’s even more important to thing about the IT side of your application, as the people writing specs and interacting with you might come from the Data Science team, and they might or might not have discussed with the IT team about deploying the app, so there’s a chance that they don’t have in mind all what is needed to deploy a Shiny App on their company server. For example, maybe your application has a database backend. For that, you’ll need to have access to this database, the correct port should be set, and the permission given to the process that executes the Shiny app to read, and maybe write, to the database. But, and for good reason, database managers don’t issue read and write permissions to a DB without having examined what the app wants to read, and how and where it will write. So, if you don’t want to have weeks of delay for your app deployment, start the discussion from the very beginning of the project. That way, even if the process of getting permission to write on the company database takes time, you might have it by the end of the coding marathon. For developing an app that is mobile first, you can have a look at the great {shinyMobile} package, made by the amazing Rinterface team.↩ "],
["css.html", "Chapter 8 A Gentle Introduction to CSS 8.1 What is CSS 8.2 Getting started with CSS 8.3 Integrate CSS files to your Shiny App", " Chapter 8 A Gentle Introduction to CSS 8.1 What is CSS // TODO 8.2 Getting started with CSS // TODO 8.3 Integrate CSS files to your Shiny App // TODO "],
["stepprotopype.html", "Chapter 9 Building an “ipsum-app” 9.1 Prototyping is crucial 9.2 The “UI first” approach", " Chapter 9 Building an “ipsum-app” 9.1 Prototyping is crucial // TODO Rule of Optimization: Prototype before polishing. Get it working before you optimize it. http://www.catb.org/~esr/writings/taoup/html/ch01s06.html#rule_of_optimization 9.2 The “UI first” approach // TODO I like to go “UI first”. For two main reasons: Once the UI is set, there is no “surprise implementation”. Once we agree on what elements there are in the app, there is no sudden “oh the app needs to do that now”. A pre-defined UI allows every person involved in the coding to know which part of the app they are working on. In other words, when you start working on the backend, it’s much easier to work on a piece you can visually identify and integrate in a complete app scenario. So yes, spend time writing a front-end prototype in lorem ipsum. And good news, we’ve got a tool for you: it’s called {shinipsum}. The main goal of this package is to create random Shiny elements that can be used to draw a UI, without actually doing any heavy lifting in the backend. Hence, once you’ve got a draft of your app on a piece of paper, you can then move to the “ipsum-UI” stage: building the front-end of the app, and filling it with random Shiny elements, with functions like random_ggplot() or random_DT(). Another package that can be used to do that is {fakir}. This package is designed to create fake data frames, primarily for teaching purposes, but it can also be used for inserting data into a shiny prototype. "],
["proto-rmdfirst.html", "Chapter 10 Building with RMarkdown 10.1 Define the content of the application 10.2 Fill the Rmd files 10.3 Use the ‘Rmd first’ method to document further", " Chapter 10 Building with RMarkdown Once again, we advise not to directly write in the Shiny application. We recommend using the ‘Rmd first’ method. It is important to correctly visualize the structure of your application before the build: number of pages and elements, how the different elements interact with each other, what are the inputs needed and the outputs. If you worked the ‘UI-first’, this should be clearer now. It is then time to develop the core of the different parts of the application. 10.1 Define the content of the application Put everything in Rmarkdown files. Use the Rmarkdown files as the sandbox of your application. If you work for a client, Rmd files knitted as HTML or PDF are easily shared for discussions about their expectations. When there are modifications of expectations or needs to visualize different propositions, knitting a Rmd file is usually easier than manually clicking on your Shiny application to reach the modified part and take a snapshot. Your application may contain data wrangling operations, multi-parameters based models, summary tables outputs, graphical outputs. All this manipulations do not require the interactivity of the Shiny application to be developed. We propose to divide the different parts of your Shiny application into multiple Rmarkdown files where you present and develop the content. You may want to create one Rmarkdown file for each page / tab of the graphical interface. The static development will simplify the multiple tests necessary during development to verify that algorithms output the correct results, to propose different colors combinations for your graphs, to improve the speed of operations, … You can use some dataset examples from real cases, small reproducible examples, or from fake datasets (See §11). 10.2 Fill the Rmd files Rmarkdown files are the place to write what you have in mind. As soon as it is related to your Shiny application of course. Write your questions, your objectives. Detail methods used and choices you made for your data wrangling, models, visualization. This will help you present them to your client, boss, colleagues. This will also help yourself in the future when you will want to debug some parts of your code. This will simplify discussion with other developers if you separated the work between multiple persons. Note that developing in multiple Rmd files helps the allocation of work between multiple developers and will reduce code conflicts during development. 10.3 Use the ‘Rmd first’ method to document further We recommend building Shiny Apps in a package. A package requires documentation and unit tests. While you develop the content of your application in a series of Rmarkdown files, it is a good time to create functions. Indeed, the code written in the Rmarkdown will be used a second time in the Shiny application when time has come to include it. To reduce copy-pasting, you may want to take advantage of the package structure to create functions of your code and store them in the ‘R’ directory of the package. As you write your function, write its roxygen documentation and list dependencies. Also, because you created your code based on one or multiple examples, you are able to directly write unit tests for your newly created functions. Writing a proper documentation and unit tests will save you a lot of time when you will implement the different functionalities in your application. This will often allow to detect cascading modifications of the outputs during the check of the package, before you play with the graphical interface. The Rmd files are the vignette of the package. Store them in the vignette directory, so that they are built and tested when you check the package. Note that once the application is set up and functionalities included, you will surely got back to the code to debug, add new functionalities, … Continue to use the Rmarkdown files after the prototyping phase all along the development. "],
["proto-tools.html", "Chapter 11 Tools for prototyping 11.1 Fast prototyping with {shinipsum} 11.2 Using {fakir} for fake data generation", " Chapter 11 Tools for prototyping Building the User Interface first should require the least possible calculations from the server part of your application. You focus on the appearance. The UI is usually a collection of buttons, figures and tables. Some being triggered by others. When first building your interface, you may only want to focus on where you place the different boxes and graphs. You will use the different *Input from {shiny} for inputs that will later affect the server part. You will also set the place for *Output, but these outputs will be empty. To show a first overview of what will look like your interface, you can use fake data and figures to fill the blank outputs. This is where {shinipsum} and {fakir} come to help. 11.1 Fast prototyping with {shinipsum} The goal of {shinipsum} is to provide random shiny elements to simulate interface outputs. Use lorem, the long “Lorem Ipsum” text to fill in text parts. Use the random_* functions in the server part of your application in combination with the appropriate render*(). This will fill the corresponding call to *Output() in the UI. For instance: random_DT() renders a DT::datatable() output with one of existing R internal datasets. random_ggplot(type = &quot;point&quot;) renders a random {ggplot2} graph with the selected type (corresponding to geom() in {ggplot2}). random_text(nwords = 10) renders a text with the defined number of words. library(shiny) library(shinipsum) library(DT) ui &lt;- fluidPage( h2(&quot;A Random DT&quot;), DTOutput(&quot;data_table&quot;), h2(&quot;A Random Plot&quot;), plotOutput(&quot;plot&quot;), h2(&quot;A Random Text&quot;), tableOutput(&quot;text&quot;) ) server &lt;- function(input, output, session) { output$data_table &lt;- DT::renderDT({ random_DT(5, 5) }) output$plot &lt;- renderPlot({ random_ggplot() }) output$text &lt;- renderText({ random_text(nwords = 50) }) } shinyApp(ui, server) Find out more in the corresponding website: https://thinkr-open.github.io/shinipsum/ 11.2 Using {fakir} for fake data generation {fakir} was primarily created to provide fake datasets for R tutorials and exercises. “Fake support ticket dataset” is built using fake_ticket_client() and “Fake questionnaire on mean of transport / goal dataset” is built using fake_sondage_answers(). They contain dates, numeric and character variables, with missing values allowing multiple exercises on data cleaning and graph building. They can also be joined with the included {sf} geographical dataset fra_sf allowing for maps creation. Fake datasets created with {fakir} can be used to build light examples on the use of the inputs, for filters or interactive maps for instance. When building your application inside a R package, as recommended in this book using {golem}, you may want to build small reproducible examples of your functions, to be presented in the vignettes and tested in the unit tests, prior to building the Shiny Apps itself. You can create these examples using {fakir}. Find out more in the corresponding website: https://thinkr-open.github.io/fakir/ "],
["stepbuild.html", "Chapter 12 Building app with {golem} 12.1 Using {golem} 12.2 dev/01_start.R 12.3 Day to Day Dev with {golem} 12.4 Launching the app 12.5 dev/02_dev.R 12.6 Adding these external resources to your app 12.7 Documentation 12.8 Using {golem} dev functions", " Chapter 12 Building app with {golem} Now the UI and the features are set, time to work on the backend. This part is pretty standard — everybody can now work on the implementation of the functions that process the app inputs, in their own modules. As the UI, functionalities and modules have been defined in the previous steps, everyone (well, in theory) knows what they have to work on. And also, as said before, there should be no “surprise implementation”, as the app has been well defined before. 12.1 Using {golem} 12.1.1 Create a package Once the package is installed, you can got to File &gt; New Project… in RStudio, and choose “Package for Shiny App Using golem” input. If you want to do it through command line, you can use: golem::create_shiny_template(path = &quot;path/to/package&quot;) This command allows you to create “illegally-named” package (for example, 1234) by passing the check_name argument to FALSE. Note that this is not recommended and should only be done if you know what you are doing. Once you’ve got that, a new RStudio project will be launched. Here is the structure of this project: DESCRIPTION ¦--dev/ ¦--01_start.R ¦--02_dev.R ¦--03_deploy.R ¦--run_dev.R ¦--inst/ ¦--app ¦--server.R ¦--ui.R ¦--www/ ¦--favicon.ico ¦--man/ ¦--run_app.Rd NAMESPACE myapp.Rproj ¦--R/ ¦--app_server.R ¦--app_ui.R ¦--run_app.R If you’re already familiar with R packages, most of these files will appear very familiar to you. That’s because a {golem} app IS a package. DESCRIPTION &amp; NAMESPACE: Package meta-data. dev/: Scripts that will be used along the process of developing your app. inst/app: You’ll add external dependencies in www (images, css, etc). Don’t touch app_ui and app_server. man: Package doc, to be generated by R. myapp.Rproj: RStudio project. R/app_server.R, R/app_ui.R: Top level UI and server elements. R/run_app.R: a function to configure and launch the application. 12.2 dev/01_start.R Once you’ve created your project, the first file that opens is dev/01_start.R. This file contains a series of commands to run once, at the start of the project. 12.2.1 Fill the DESC First, fill the DESCRIPTION by adding information about the package that will contain your app: golem::fill_desc( pkg_name = &quot;shinyexample&quot;, # The Name of the package containing the App pkg_title = , # The Title of the package containing the App pkg_description = , # The Description of the package containing the App author_first_name = , # Your First Name author_last_name = , # Your Last Name author_email = , # Your Email repo_url = NULL) # The (optional) URL of the GitHub Repo 12.2.2 Set common Files If you want to use the MIT licence, README, code of conduct, lifecycle badge, and news usethis::use_mit_license(name = &quot;Your Name&quot;) # You can set another licence here usethis::use_readme_rmd() usethis::use_code_of_conduct() usethis::use_lifecycle_badge(&quot;Experimental&quot;) usethis::use_news_md() 12.2.3 Add a data-raw folder If you have data in your package usethis::use_data_raw() 12.2.4 Init Tests Create a template for tests: golem::use_recommended_tests() 12.2.5 Use Recommended Package This will add “shiny”, “DT”, “attempt”, “glue”, “htmltools”, and “golem” as a dependecy to your package. golem::use_recommended_dep(&quot;&quot;) 12.2.6 Add various tools These two functions add a file with various functions that can be used along the process of building your app. See each file in details for a description of the functions. golem::use_utils_ui() golem::use_utils_server() 12.2.7 If you want to change the default favicon golem::use_favicon( path = &quot;path/to/favicon&quot;) You’re now set! You’ve successfully initiated the project and can go to dev/02_dev.R. rstudioapi::navigateToFile(&quot;dev/02_dev.R&quot;) 12.3 Day to Day Dev with {golem} Now that you’re all set with your project init, time to move to development :) App development should happen through the dev/02_dev.R file, which contains common commands for developping. 12.4 Launching the app To run the app, go to the dev/run_dev.R file, and run the all thing. 12.5 dev/02_dev.R 12.5.1 Add modules The golem::add_module() functions creates a module in the R folder. The file and the modules will be named after the name parameter, by adding mod_ to the R file, and mod_*_ui and mod_*_server to the UI and server functions. golem::add_module(name = &quot;my_first_module&quot;) # Name of the module The new file will contain: # mod_UI mod_my_first_module_ui &lt;- function(id){ ns &lt;- NS(id) tagList( ) } mod_my_first_module_server &lt;- function(input, output, session){ ns &lt;- session$ns } ## To be copied in the UI # mod_my_first_module_ui(&quot;my_first_module_1&quot;) ## To be copied in the server # callModule(mod_my_first_module_server, &quot;my_first_module_1&quot;) In order not to make errors when putting these into your app, the end of the file will contain code that has to be copied and pasted inside your UI and server functions. 12.5.2 Add dependencies To be called each time you need a new package as a dependency: usethis::use_package(&quot;pkg&quot;) 12.5.3 Add tests Add more tests to your application: usethis::use_test(&quot;app&quot;) 12.5.4 Add a browser button Learn more about this: https://rtask.thinkr.fr/blog/a-little-trick-for-debugging-shiny/ golem::browser_button() 12.5.5 Add external files These functions create external dependencies (JavaScript and CSS). add_js_file() creates a simple JavaScript file, while add_js_handler() adds a file with a skeleton for shiny custom handlers. golem::add_js_file(&quot;script&quot;) golem::add_js_handler(&quot;script&quot;) golem::add_css_file(&quot;custom&quot;) 12.6 Adding these external resources to your app You can add any external resource (JS, css) into inst/app/www. Then, You’ll need to point to these external resources in golem_add_external_resources(). For example, if you’ve created a CSS file with golem::add_css_file(&quot;custom&quot;), you can add the file with: tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;) Also, you can list here the use of other packages, for example useShinyalert() from the {shinyalert} package. Note: we’ve chosen to leave it “raw”, in the sense that there is a addResourcePath and a tags$head. If you’re comfortable with {htmltools}, you can build a htmltools::htmlDependency. 12.7 Documentation 12.7.1 Vignette usethis::use_vignette(&quot;shinyexample&quot;) devtools::build_vignettes() 12.7.2 Code coverage usethis::use_travis() usethis::use_appveyor() usethis::use_coverage() 12.8 Using {golem} dev functions There’s a series of tools to make your app behave differently whether it’s in dev or prod mode. Notably, the app_prod() and app_dev() function tests for options( &quot;golem.app.prod&quot;) (or return TRUE if this option doesn’t exist). Setting this options at the beginning of your dev process allows to make your app behave in a specific way when you are in dev mode. For example, printing message to the console with cat_dev(). options( &quot;golem.app.prod&quot; = TRUE) golem::cat_dev(&quot;hey\\n&quot;) options( &quot;golem.app.prod&quot; = FALSE) golem::cat_dev(&quot;hey\\n&quot;) hey You can then make any function being “dev-dependant” with the make_dev() function: log_dev &lt;- golem::make_dev(log) log_dev(10) [1] 2.302585 options( &quot;golem.app.prod&quot; = TRUE) log_dev(10) "],
["step-secure.html", "Chapter 13 Build yourself a safety net 13.1 Testing your app 13.2 A reproducible environment", " Chapter 13 Build yourself a safety net “Don’t fuck over Future You” JD Securing your app means two things: testing, and locking the application environment. 13.1 Testing your app // TODO So first, be sure to include tests all along the building process — just like any other R code. As the app is contained in a package, you can use standard testing tools for testing the business logic of your app — as said in the first part, it’s important to split the backend functions and algorithm from the user interface. That means that these backend functions can run outside of the application. And yes, if they can run outside of the app, they can be tested the standard way, using {testthat}. When it comes to testing the front end, you can try the {shinytest} package from RStudio, if you need to be sure there is no visual regression all along the project development. {shinyloadtest}, on the other hand, tests how an application behaves when one, two, three, twenty, one hundred users connect to the app, and gives you a visual report about the connection and response time of each session. One other tool I like to use is Katalon Studio. It’s not R related, and can be used with any kind of web app. How it works is quite simple: it opens your browser where the Shiny app runs, and record everything that happens. Once you stop the recording, you can relaunch the app and it will replay all the events it has recorded. And of course, you can specify your own scenario, define your own events, etc. It’s not that straightforward to use, but once you get a good grasp of how it works, it’s a very powerful tool. 13.2 A reproducible environment // TODO Secondly, secure your app means that it can be deployed again any time in the future — in other words, you have to ensure you’ve got a proper handle on the required R version, and of the package versions which are required to run your app. That means that you have to be aware that upgrading a package might break your app — so, provide an environment that can prevent your app from breaking when a package gets updated. For that, there is, of course, Docker, R specific tools like {packrat} or {renv}, or deploying custom CRAN repositories or package manager. "],
["secure.html", "Chapter 14 Secure your work 14.1 Using Version Control with git 14.2 Git integration 14.3 CI and testing", " Chapter 14 Secure your work 14.1 Using Version Control with git “Friends don’t let friends work on a coding project without version control.” You might have heard this before, without really considering what this means. Or maybe you’re convinced about this saying, but haven’t had the opportunity to use git, GitHub or Gitlab for versioning your applications. If so, now is the time for a workflow change! 14.1.1 Why Version Control? Have you ever experience a piece of code disappearing? Or the unsolvable problem of integrating changes when several people have been working on the same piece of code? Or the inability to find back something you’ve written a while back? If so, you might have been craving for Version Control (now shortened VC). In this chapter, we’ll be focusing on git, but you should be aware that other VC system exist, but they are less popular than git. Git was designed to handle collaboration on code projects26 where potentially a lot of people have to interact and make changes to the codebase. Git might feel a little bit daunting at first, and even seasoned developers still misuse it, or don’t understand it completely. But don’t give up: the benefits from learning it really outweigh the (apparent) complexity. There are many advantages to VC, and here is a non-exhaustive list: You can get back in time. With a VC system like git, every change is recorded (well, every committed change), meaning that you can potentially get back in time to a previous version of a project. Crucial if you accidentally made changes that break your application, or if you deleted a feature you thought you’d never need. Several people can work on the same file. Git relies on a system of branches. Within this branch pattern, there is one main branch, called “Master”, which contains the stable, main version of the code-base. By “forking” this branch (or any other branch actually), developers will have a copy of the base branch, where they can safely work on changing (and breaking) things, without impacting the origin branch. This allows to try things in a safe environment, without touching what is working. You can safely track changes. Every time a developer records something to git, changes are listed. In other words, you can see what changes are made to a specific file in your code base. It centralizes the code base. You can use git locally, but its strength also relies on the ability to synchronize your local project with one on a server. This also means that several people can synchronize with this server and collaborate on a project. That way, changes on a branch on a server can be downloaded (it’s called pull in git terminology) by all the members of the team. 14.1.2 Git basics: commit - push - pull These are the three main actions you’ll be performing in git, and if you just need to learn the minimum to get started, they are the three essential ones. 14.1.2.1 commit A commit is a photography of a codebase at a given moment in time. Every commits is associated with two things: a sha1, which is a unique reference in the history and that allows you to identify this precise state when you need to get back in time, and a message, which is a piece of text that describes the commit27. Note that message are mandatory: you can’t commit without them. Don’t overlook these messages: they might seem like a constraint at first but they are a life save when you need to understand the history of a project. There is no strict rule about what and when to commit. Just keep in mind that commits are what allow you to get back in time, so a commit is a complete state of your code base to which it would make sense to get back to. 14.1.2.2 push Once you’ve get a set of commits ready, you’re ready to push it to the server. In other word, you’ll permanently record these commits (so the series of changes) to the server. Making a push implies two things: Other people in the team will be able to retrieve the changes you’ve made These changes will be recorded permanently in the project history28. 14.1.2.3 pull Once changes have be recorded in the main server, everybody synchronized with the project can pull the commits to their local project. 14.1.3 About branches Branches are git way to organize work and ideas, and notably when several people are collaborating on the same project (which might be the case when building large web applications with R). How does it work? When your start a project, you’re in the main branch, which is called the “Master”. In a perfect world, you never work directly on this branch: it should always contain a working, deployable version of the application. One Other branches are to be thought as work areas, where developers fix bugs or add features. The modifications made in these dev branches will then be transferred (directly or indirectly) to the master branch. // TODO image about branching In practice, you might want to use a workflow where each branch is designed to fix a small issue or implement a feature, so that it’s easier to separate each small part of the work. 14.1.4 Issues If you are working with a remote tool like GitHub or GitLab, there’s a good change you’ll be using issues. Issues are “notes” that can be used to track a bug or to suggest a feature. This tools is crucial when it comes to project management: they are the perfect spot for organizing and discussing ideas, but also to have an overview of what has been done, what is currently done and what’s left to be done. Issue can also be used as a discussion medium with beta testers, clients or sponsors. One other valuable feature of issues is that they can be referenced inside commits. In other words, when you send code to the centralized server, you can link this code to one or more issues. 14.2 Git integration 14.2.1 With RStudio Git is very well integrated to the Rstudio IDE, and while working on your app using git can be as simple as clicking on a button from time to time. If you are using RStudio, you’ll find a pull/push button, a stage &amp; commit interface, a tool for visualizing diff in files. Everything you need to get started is there. 14.2.2 As part of a larger world Git is not reserved for team work: even if you are working alone on a project, using git is definitely worth the effort. Using git, and particularly issues, helps you organize your train of thoughts, especially upfront when you need to plan what you’ll be doing. And of course, remember that git isn’t reserved to Shiny Applications: it can be used for any other R related projects, and at the end of the day for any code related projects, making it a valuable skill to have in your toolbox, whatever language you’ll be working with in 10 years! 14.2.3 About git-flow // TODO 14.2.4 Further readings on git Git can be used in different ways and different approaches exist. The comprehensiveness of the different possible approaches is beyond the scope of this book, and other resources exist as well. We invite you to follow these different links: https://happygitwithr.com/ https://git-scm.com/book https://www.git-tower.com/blog/git-cheat-sheet/ 14.3 CI and testing Testing is central for making your application survive in the long run. The {testthat} package can be used to test the “business logic” side of your app, while the application features can be tested with packages like {shinytest}, or software like Katalon. // TO DO: more info about the tools + link to resources. It was first developed by Linus Torvalds, the very same man behind Linux↩ For example: “Added a graph in the analysis tab”, or “Fixed the docx export bug”↩ Well, it’s technically possible to erase things from the server history, but it’s dangerous to do so and generally accepted as a bad practice.↩ "],
["stepdeploy.html", "Chapter 15 Send your app to production 15.1 Where to deploy your app 15.2 Before deployment Check-list", " Chapter 15 Send your app to production 15.1 Where to deploy your app // TODO 15.2 Before deployment Check-list 15.2.1 What to check on the app // TODO 15.2.2 What to check in the production envionment // TODO "],
["deploy-golem.html", "Chapter 16 Deploy with {golem} 16.1 Local deployment 16.2 Deploying Apps with {golem} 16.3 RStudio Environments 16.4 Docker", " Chapter 16 Deploy with {golem} 16.1 Local deployment // TODO 16.2 Deploying Apps with {golem} The dev/03_deploy.R file contains function for deploying on various plateforms. 16.3 RStudio Environments // TODO 16.4 Docker // TODO "],
["when-optimize.html", "Chapter 17 The Need for Optimization 17.1 Build first, then optimize 17.2 Tools for profiling", " Chapter 17 The Need for Optimization 17.1 Build first, then optimize // TODO 17.2 Tools for profiling // TODO "],
["optim-caveat.html", "Chapter 18 Common Application Caveats 18.1 Reactivity anti-patterns 18.2 R does too much", " Chapter 18 Common Application Caveats 18.1 Reactivity anti-patterns // TODO 18.2 R does too much // TODO "],
["optimizing-shiny-code.html", "Chapter 19 Optimizing Shiny Code 19.1 Reading data 19.2 Caching elements", " Chapter 19 Optimizing Shiny Code 19.1 Reading data // TODO 19.2 Caching elements // TODO "],
["optimjs.html", "Chapter 20 Using JavaScript 20.1 A quick introduction to JavaScript 20.2 Client-side JavaScript 20.3 JavaScript &lt;-&gt; Shiny communication 20.4 About {golem} js functions 20.5 Learn more about JavaScript", " Chapter 20 Using JavaScript At its core, building a Shiny app is building a JavaScript app that can talk with an R session. This process is invisible to most Shiny developers, who usually do everything in R. And in the end, this is the case: most of the Shiny apps out there are written with R. In fact, when you are writing UI elements in Shiny, what you are actually doing is building a series of HTML tags, which are then linked to JavaScript events. Later on, when the app is running, these JavaScript events will communicate with R, in the sense that they will send data to R, and receive data from R. Most of the time, when these JavaScript events are receiving data, they modify the page the user sees. What happens under the hood is a little bit complex and out of scope for this book, but the general idea is: R talks to your browser through a web socket (that you can imagine as a small “phone line” with both software modules listening at each end29), and this browser talks to R through the same web socket. // TODO: create here a simple Flowchart // R -&gt; (Web Socket) -&gt; JS // R &lt;- (Web Socket) &lt;- JS It’s important to note here that the communication happens in both ways: from R to JavaScript, and from JavaScript to R. In fact, when we write a piece of code like sliderInput(&quot;plop&quot;, &quot;this&quot;, 1, 10, 5), what we are doing is creating a binding between JavaScript and R, where JavaScript listens to any event happening in the browser on the slider with the id &quot;plop&quot;, and whenever JavaScript detects that something happens to this element, something (most of the time its value) is sent back to R. With output$bla &lt;- renderPlot({}), what we are doing is making the two communicate the other way around: we are telling JavaScript to listen to any incoming data from R for the id &quot;bla&quot;, and whenever JavaScript sees incoming data from R, it puts it into the proper HTML tag (here, JavaScript inserts in the page the image received from R). So even if everything is written with R, we are writing a web application, i.e. HTML, CSS and JavaScript elements. Once you’ve realized that, the possibilities are endless: in fact almost anything doable in a “classic” web app can be done in Shiny. What this also implies is that getting (even a little bit) better at writing HTML, CSS, and especially JavaScript will make your app better, lighter, and more user-friendly, as JavaScript is a language that has been designed to interact with a web page: change element appearances, hide and show things, click somewhere, show alerts and prompts… Knowing just enough JavaScript can improve the quality of your app: especially when you’ve been using R to render some complex UIs: think conditional panels, simulating a button click from the server, hide and show elements… All these things are good examples of where you should be using JavaScript instead of building more or less complex renderUI or insertUI patterns in your server. Moreover, the number of JavaScript libraries available on the web is tremendous ; and the good news is that Shiny has everything it needs to bundle external JavaScript libraries inside your application30. This is what this section of the book aims at: giving you just enough JavaScript knowledge to lighten your Shiny App, in order to improve the global user and developer experience. In this part, we’ll first review some JavaScript basics which can be used “client-side” only, i.e. only in your browser, or by making R &amp; JS communicate with each other. In this section, we’ll also explore common patterns for JavaScript in Shiny. Finally, we’ll quickly present some of the functions from {golem} which are built on top of JavaScript. Note that this chapter is not supposed to be a comprehensive JavaScript course. External resources are linked all throughout this chapter and at the end if you want to dive deeper into JavaScript. 20.1 A quick introduction to JavaScript JavaScript is a programming language which has been designed to work in the browser31. There are three ways to include the JavaScript code inside your web app: As an external file, which is served to the browser alongside your main application page Inside a &lt;script&gt; HTML tag inside your page On a specific tag, for example by adding an onclick event straight on the tag Note that the good practice when it comes to include JavaScript is to add the code inside an external file. If you’re working with {golem}, including a JavaScript file is achieved via two functions: golem::add_js_file(&quot;name&quot;), which adds a standard JavaScript file, i.e. one which is not meant to be used to communicate with R. We’ll see in the first part of this chapter how to add JavaScript code there. golem::add_js_handler(&quot;name&quot;), which creates a file with a skeleton for Shiny handlers. We’ll see this second type of elements in the JavaScript &lt;-&gt; Shiny communication part. OK, good, but what do we do now? 20.1.1 Understanding html, class, and id You have to think of a web page as a tree, where the top of the webpage is the root node, and every element in the page is a node in this tree (this tree is called a DOM, for Document Object Model). You can work on any of these HTML nodes with JavaScript: modify it, bind to it and/or listen to events, hide and show… But first, you have to find a way to identify these elements: either as a group of elements or as a unique element inside the whole tree. That’s what html semantic elements, classes, and ids are made for. Consider this piece of code: library(shiny) fluidPage( titlePanel(&quot;Hello Shiny&quot;), actionButton(&quot;go&quot;, &quot;go&quot;) ) &lt;div class=&quot;container-fluid&quot;&gt; &lt;h2&gt;Hello Shiny&lt;/h2&gt; &lt;button id=&quot;go&quot; type=&quot;button&quot; class=&quot;btn btn-default action-button&quot;&gt;go&lt;/button&gt; &lt;/div&gt; This {shiny} code creates a piece of HTML code containing three nodes: a div with a specific class (a BootStrap container), an h2, which is a level-two header, and a button which has an id and a class. Both are included in the div. Let’s detail what we’ve got here: HTML tags, which are the building blocks of the “tree”: here div, h2 and button are HTML tags. The button has an id, which is short for “identifier”. This id has to to be unique: this reference allows to refer to this exact element, and more specifically, it allows JavaScript and R to talk to each other: if you click on a button, you have to be sure you are referring to this specific button, and only that one. Elements can have a class which can apply to multiple elements. This can be used in JavaScript, but it’s also very useful for styling elements in CSS. 20.1.2 About jQuery &amp; jQuery selectors The jQuery framework is natively included in Shiny. jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use API that works across a multitude of browsers. .right{ text-align: right;} jQuery home page jQuery is a very popular JavaScript library which is designed to manipulate the DOM, its events and its elements. It can be used to do a lot of things, like hide and show, change class, click somewhere… And to be able to do that, it comes with the notion of selectors, which will be put between $(). You can use, for example: $(&quot;#plop&quot;) to refer to the element with the id plop $(&quot;.pouet&quot;) to refer to element(s) of class pouet $(&quot;button:contains('this')&quot;) to refer to the buttons with a text containing 'this' You can also use special HTML attributes, which are specific to a tag. For example, the following HTML code: &lt;a href = &quot;https://thinkr.fr&quot; data-value = &quot;panel2&quot;&gt;ThinkR&lt;/a&gt; contains the href &amp; data-value attributes. You can refer to these with [] after the tag name. $(&quot;a[href = 'https://thinkr.fr']) refers to link(s) with href being https://thinkr.fr $('a[data-value=&quot;panel2&quot;]') refers to link(s) with data-value being &quot;panel2&quot; These and other selectors are used to identify one or more node(s) in the big tree which is a web page. Once we’ve identified these elements, we can either extract or change data contained in these nodes, or invoke methods contained within these nodes. Indeed JavaScript, as R, can be used as a functional language, but most of what we do is done in an object-oriented way. In other words, you’ll interact with objects from the web page, and these objects will contain data and methods. Note that this is not specific to jQuery: elements can also be selected with standard JavaScript. jQuery has the advantage of simplifying selections and actions and to be cross-platform, making it easier to ship applications that can work on all major browsers. And it comes with Shiny for free! 20.2 Client-side JavaScript It’s hard to give an exhaustive list of what you can do with JavaScript inside Shiny. As a Shiny app is part JavaScript, part R, once you’ve got a good grasp of JavaScript you can quickly enhance any of your applications. That being said, a few common things can be done that would allow you to immediately optimize your application: i.e. small JavaScript functions that will prevent you from writing complex algorithmic logic in your application server. 20.2.1 Common patterns $('#id').show(); and $('#id').hide(); show and hide one or more elements that match the given selector. For example, this can be use to replace: output$ui &lt;- renderUI({ if (this){ tags(...) } else { NULL } }) alert(&quot;message&quot;) uses the built-in alert-box mechanism from the user’s browser (i.e., the alert() function is not part of jQuery but it’s built inside the user’s browser). It works well as it relies on the browser instead of relying on R or on a specific JavaScript library. You can use this functionality to replace a call to {shinyalert}: the result is a little less aesthetically pleasing, but that’s easier to implement and maintain. var x = prompt(&quot;this&quot;, &quot;that&quot;); this function opens the built-in prompt, which is a text area where the user can input text. With this code, when the user clicks “OK”, the text is stored in the x variable, which you can then send back to R (see further part down this chapter for more info on how to do that). This can replace something like the following: mod &lt;- function() { modalDialog( tagList( textInput(ns(&quot;info&quot;), &quot;Your info here&quot;) ), footer = tagList( modalButton(&quot;Cancel&quot;), actionButton(ns(&quot;ok&quot;), &quot;OK&quot;) ) ) } observeEvent(input$show, { showModal(mod()) }) observeEvent(input$ok, { removeModal() }) $('#id').css('color', 'green'); changes the CSS attributes of the selected element(s). Here, we’re switching to green on the #id element. $(&quot;#id&quot;).text( &quot;this&quot; ); changes the text content to “this”. This can be used to replace output$ui &lt;- renderUI({ if (this){ tags$p(&quot;First&quot;) } else { tags$p(&quot;Second&quot;) } }) $(&quot;#id&quot;).remove(); completely removes the element from the DOM. IT can be used as a replacement for shiny::removeUI(), or as a conditional UI. 20.2.2 Where to put them - introduction to JavaScript events OK, now that we’ve got some ideas about JS code that can be used in Shiny, where do we put them? HTML and JS have a concept called events, which are… well events that happen when the user manipulates the webpage: when the user clicks, hovers (the mouse goes over an element), presses the keyboard… All these events can be used to trigger a JavaScript function. Here are some examples of adding JavaScript functions to DOM events: +onclick The onclick attribute can be added straight inside the HTML tag when possible: tags$button( &quot;Show&quot; onclick = &quot;$(&#39;#plot&#39;).show()&quot; ) Or with shiny::tagAppendAttributes: plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alert(&#39;hello world&#39;)&quot; ) Here is for example a small Shiny app that implements this behavior: library(shiny) library(magrittr) ui &lt;- function(request){ fluidPage( plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alert(&#39;iris plot!&#39;)&quot; ) ) } server &lt;- function(input, output, session){ output$plot &lt;- renderPlot({ plot(iris) }) } shinyApp(ui, server) You can find a real Life example of this tagAppendAttributes in the {tidytuesday201942} app: R/mod_dataviz.R#L109, where the click on the plot generates the creation of a Shiny input (we’ll see this below) That, of course, works well with very small JavaScript code. For longer JavaScript code, you can write a function inside and external file, and add it to your app. In {golem}, this works by launching the add_js_file(&quot;name&quot;), which will create a .js file. You’ll then need to add this function using tags$script(src=&quot;www/name.js&quot;) inside golem_add_external_resources() in R/app_ui.R file. This, for example, could be: inst/app/www/script.js function alertme(id){ // Asking information var name = prompt(&quot;Who are you?&quot;); // Showing an alert alert(&quot;Hello &quot; + name + &quot;! You&#39;re seeing &quot; + id); } Then: plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alertme(&#39;plot&#39;)&quot; ) Inside this inst/app/www/script.js, you can also attach a new behavior with jQuery to one or several elements. For example, you can add this alertme / onclick behavior to all plots of the app: function alertme(id){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! You&#39;re seeing &quot; + id); } /* We&#39;re adding this so that the function is launched only when the document is ready */ $(function(){ // Selecting all Shiny plots $(&quot;.shiny-plot-output&quot;).on(&quot;click&quot;, function(){ /* Calling the alertme function with the id of the clicked plot */ alertme(this.id); }); }); Then, all the plots from your app will receive this on-click event32. Note that there is a series of Shiny events which are specific to Shiny but that can be used just like the one we’ve just seen: function alertme(){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! Welcome to my app&quot;); } $(function(){ // Waiting for Shiny to be connected $(document).on(&#39;shiny:connected&#39;, function(event) { alertme(); }); }); See JavaScript Events in Shiny for the full list of JavaScript events available in Shiny. 20.3 JavaScript &lt;-&gt; Shiny communication Now that we’ve seen some client-side optimization, i.e. R doesn’t do anything with these events when they happen (in fact R is not even aware they happened), let’s now see how we can make these two communicate with each other. 20.3.1 From R to JavaScript Calling JS from the server side (i.e from R) is done by defining a series of CustomMessageHandler: these are functions with one argument that can then be called using the session$sendCustomMessage() method from the server. You can define them using this skeleton: $( document ).ready(function() { Shiny.addCustomMessageHandler(&#39;fun&#39;, function(arg) { }) }); This skeleton is the one generated by golem::add_js_handler(&quot;plop&quot;). Then, it can be called from server-side with: session$sendCustomMessage(&quot;fun&quot;, list()) Note that the list() argument from your function will be converted to JSON, and read as such from JS. In other words, if your have an argument called x, and you call the function with list(a = 1, b = 12), then in JS you’ll be able to use x.a and x.b. For example: In inst/app/www/script.js Shiny.addCustomMessageHandler(&#39;computed&#39;, function(mess) { alert(&quot;Computed &quot; + mess.what + &quot; in &quot; + mess.sec + &quot; secs&quot;); }) Then in R: observe({ deb &lt;- Sys.time() # Do the computation for id Sys.sleep( sample(1:5, 1) ) session$sendCustomMessage( &quot;computed&quot;, list( what = &quot;plop&quot;, sec = round(Sys.time() - deb) ) ) }) 20.3.2 From JavaScript to R How to do the other way around (from JS to R)? Shiny apps, in the browser, contain an object called Shiny, which can be used to send values to R, by creating an IputValue. For example, with: Shiny.setInputValue(&quot;rand&quot;, Math.random()) you’ll bind an input that can be caught from the server side with: observeEvent( input$rand , { print( input$rand ) }) This Shiny.setInputValue can of course be used inside any JavaScript function. Here is a small example wrapping some of the things we’ve seen previously: In inst/app/www/script.js function alertme(){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! Welcome to my app&quot;); Shiny.setInputValue(&quot;username&quot;, name) } $(function(){ // Waiting for Shiny to be connected $(document).on(&#39;shiny:connected&#39;, function(event) { alertme(); }); $(&quot;.shiny-plot-output&quot;).on(&quot;click&quot;, function(){ /* Calling the alertme function with the id of the clicked plot */ Shiny.setInputValue(&quot;last_plot_clicked&quot;, this.id); }); }); These events (getting the user name and the last plot clicked), can then be caught from the server side with: observeEvent( input$username , { cli::cat_rule(&quot;User name:&quot;) print(input$username) }) observeEvent( input$last_plot_clicked , { cli::cat_rule(&quot;Last plot clicked:&quot;) print(input$last_plot_clicked) }) Which will give: &gt; golex::run_app() Loading required package: shiny Listening on http://127.0.0.1:5495 ── User name: ───────────────────────────────────────────────────── [1] &quot;Colin&quot; ── Last plot clicked: ───────────────────────────────────────────── [1] &quot;plota&quot; ── Last plot clicked: ───────────────────────────────────────────── [1] &quot;plopb&quot; Important note: if you’re using modules, you’ll need to pass the namespacing of the id to be able to get it back from the server. This can be done using the session$ns function, which comes by default in any golem-generated module. In other words, you’ll need to write something like: $( document ).ready(function() { Shiny.addCustomMessageHandler(&#39;whoareyou&#39;, function(arg) { var name = prompt(&quot;Who are you?&quot;) Shiny.setInputValue(arg.id, name); }) }); mod_my_first_module_ui &lt;- function(id){ ns &lt;- NS(id) tagList( actionButton( ns(&quot;showname&quot;), &quot;Enter your name&quot; ) ) } mod_my_first_module_server &lt;- function(input, output, session){ ns &lt;- session$ns observeEvent( input$showname , { session$sendCustomMessage( &quot;whoareyou&quot;, list( id = ns(&quot;name&quot;) ) ) }) observeEvent( input$name , { cli::cat_rule(&quot;Username is:&quot;) print(input$name) }) } 20.4 About {golem} js functions {golem} comes with a series of JavaScript functions that you can call from the server. These functions are added by default with golem::activate_js() in app_ui. Then they are called with golem::invoke_js(&quot;function&quot;, &quot;element&quot;). This element can be one of a series of elements (most of the time scalar elements) which can be used to select the DOM node you want to interact with. It can be a full jQuery selector, an id or a class. Note that you can pass multiple elements, with invoke_js ... parameters 20.4.1 golem::invoke_js() showid &amp; hideid, showclass &amp; hideclass show and hide elements through their id or class. golem::invoke_js(&quot;showid&quot;, ns(&quot;plot&quot;)) showhref &amp; hidehref hide and show a link by trying to match the href content. golem::invoke_js(&quot;showhref&quot;, &quot;panel2&quot;) clickon click on the element. You have to use the full jQuery selector. show &amp; hide show and hide elements, using the full jQuery selector. See ?golem::activate_js for a full list of built-in functions. 20.5 Learn more about JavaScript We have written an online, freely available bbok about Shiny &amp; JavaScript. You’ll find it at http://connect.thinkr.fr/js4shinyfieldnotes/ Here is a list of external resources to learn more about JavaScript: 20.5.1 JavaScript basics Mozilla JavaScript w3schools JavaScript Free Code Camp JavaScript For Cats Learn JS 20.5.2 jQuery jQuery Learning Center w3schools jQuery 20.5.3 Intermediate / advanced JavaScript Eloquent JavaScript You Don’t Know JS Yet See this dev.to post for a quick introduction to the general concept of web socket↩ This can also be done by wrapping a JS libraries inside a package, which will later be used inside an application. See for example {glouton}, which is a wrapper around the js-cookie JavaScript library.↩ You can now work with JavaScript in a server with Node.JS, but this is out of scope of this book. See linked resources to learn more.↩ This click behavior can also be done through $(&quot;.shiny-plot-output&quot;).click(...). We chose to display the on(&quot;click&quot;) pattern as it can be generalized to all DOM events.↩ "]
]
