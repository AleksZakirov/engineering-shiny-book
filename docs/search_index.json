[
["index.html", "Building Big Shiny Apps - A Workflow Chapter 1 Disclaimer 1.1 Motivation 1.2 Book structure 1.3 Wanna help? 1.4 Other resources", " Building Big Shiny Apps - A Workflow Colin Fay 2019-04-07 Chapter 1 Disclaimer This book is still at a Work in Progress stage. 1.1 Motivation This book will not get you started with Shiny, nor talk about how to deploy into production and scale your app. What we’ll see is the process of building the app. Why? Lots of blog posts and books talk about starting to use shiny or putting apps in production. Very few (if any) talk about this grey area between getting started and pushing into production. So this is what this book is going to talk about: building Shiny application. We’ll focus on the process, the workflow, and the tools we use at ThinkR when building big Shiny Apps. Hence, if you’re starting to read this book, we assume you have a working knowledge of how to build a small application, and want to know how to go one step further. 1.2 Book structure Part 1 (Building big Shiny Apps) gives a general context about what is a big Shiny Apps and what challenges arise when you’re dealing with a big application. Part 2 (Step by Step) describes a series of steps you can take when you want to build a big Shiny App. Part 3 (Tools) introduces various tools you can use: notably the {golem} package. Part 4 (Optimizing) tackles the question of optimization, first by presenting some common caveats of big Shiny Apps, and then showing how to optimize R code, and use JavaScript to lighten R work. 1.3 Wanna help? Any feedbacks on the book is very welcome. Feel free to open an issue, or to make a PR if you spot a typo (I’m not a native english speaker, so there might be some waiting to be found ;) ). 1.4 Other resources 1.4.1 Getting started with Shiny Learn Shiny with RStudio Getting Started with Shiny (WIP) Mastering Shiny A gRadual intRoduction to Shiny 1.4.2 Shiny into production Shiny in production: Principles, practices, and tools Shiny in Production Suggest a Resource! "],
["bigshinyapp.html", "Chapter 2 About Big Shiny Apps 2.1 What’s a big Shiny App?", " Chapter 2 About Big Shiny Apps If you’re reading this page, chances are you already know what a Shiny App is — a web application that communicates with R, built in R, and working with R. Almost anybody can create a prototype for a small data product in a matter of hours. And no knowledge of HTML, CSS or JavaScript is required, making it really easy to use — you can rapidly create a POC. But what to do now you want to build a big Shiny App? 2.1 What’s a big Shiny App? Well, first, one that includes several thousand lines of code (R and others). It’s also one that is potentially developed by several coders, working on the same application at the same time. It’s an application where scaling matters. Maintainability and ease of upgrading are important. In many cases, Shiny Apps in production are not used by “tech literate” people. People rely on this application for making real-world decisions, with real consequences. "],
["challenges.html", "Chapter 3 Challenges 3.1 Designing the UI 3.2 Working as a team 3.3 Making the app production ready", " Chapter 3 Challenges 3.1 Designing the UI Choosing a UI is hard — we have a natural tendency, as coders, to be focused on the backend, i.e the algorithmic part of the application. But let’s state the truth: no matter how complex and innovative your backend can be, your application is bad if your UI is bad. That’s the hard truth. If people can’t understand how to use your application, your application doesn’t work. No matter how incredible the backend is. Try to find a simple, and efficient UI. One that people can understand and use in a matter of seconds. Don’t implement features or visual elements that are not actually needed, just “in case”. And spend time working on that UI, really thinking about what visual elements you are implementing. // TODO: Find resources about simplicity in UI/UX design 3.2 Working as a team Big Shiny Apps usually mean that several people will work on the application. For example, at ThinkR, 3 to 4 people usually work on the application. So, how do we organize that? 3.2.1 From the tools point of view: Use version control (not sure I have to expand on that topic ;) ) Think of your shiny app as a tree, and divide it as much as possible into little pieces. Then, create one Shiny module by piece. This allows you to split the work, and also to have smaller files — it’s easier to work on 20 files of 200 lines than on one big app.R file. 3.2.2 From the organisational point of view Define one person in charge of having the big picture of the app. This person will kick off the project, and write the skeleton of the app, with the good modules and files structure. This person will also be in charge of accepting new merge requests from other developers, and to orchestrate the master and dev branches. List the tasks, and open one issue for each task on your version control system. Each issue will be solved in a separate branch. Finally, assign one module to one developer — if it seems that working on one module is a two-person job, divide again into two other submodules. This is a relatively complex task, as the output of one module influences the input of another, so be sure to assign them well. 3.3 Making the app production ready 3.3.1 Scaling This includes two things: scaling and maintaining. As said in the disclaimer, I won’t expand on the topic of scaling, as many have written about that, but here is one piece of advice: make the R process running the app do as little as possible, and in particular prevent it from doing what it’s not supposed to do. Which includes: use JavaScript so that the client browser renders things (instead of making R do the work — basic JS is easy to learn), use parallelization and async, and if possible, make the heavy lifting be done outside the R session running the app. // TODO: link to resources. 3.3.2 Maintaining Maintainance, on the other hand, is something to think about from the beginning. It includes being able to ensure that the application will work in the long run, and that new features can be easily implemented. Working in the long run: separate the code with “business logic” (aka the data manipulation and the algorithm, that can work outside the context of the app) from the code building the application. That way, you can write regression tests for these functions to ensure they are stable. Implement new elements: as we are working with modules, it’s easy to insert new elements inside the global application. // TO DO: be more precise on the tooling. "],
["step-design.html", "Chapter 4 Step 1: Designing", " Chapter 4 Step 1: Designing Don’t rush into coding. I know you want to, because it’s what we like to do and what we are good at. But before entering the coding marathon, take time to think about the application and the way it will be deployed and used. Take a pen and a piece of paper and draw the app. Talk about it with the people who will use the app, just to decipher what they actually need. Take a moment to talk with the IT. Here are some questions you can ask: “Who are the end users of the app?” — This will help you know if the end users are tech literate or not, and what they aim to achieve with the app. “How frequently will they use the app?” — The small details of the design &amp; the UI of an app you use on a daily basis is more crucial than when the app is used once a month. “What level of complexity and personalization do the users really need?” — People writing app specifications sometimes want more functionalities than what is actually needed by the users. “What level of interactivity do you want, and to what extent is it central?” — People love interactive graphs and like when things automatically sync with each other. Yet these two can make the app slower, without any significant gain. For example, being reactive to a selectInput() or a sliderInput() can lead to too much computation: maybe the user will not succeed to choose the right input the first, second or third time… So let them do their choice, and add a button so that they can validate when they are ready. “How important is it that the app is fast?” — Should you spend a lot of time optimizing the little things? etc. Asking questions, taking notes, and drawing the app help you have a good idea of what is expected and what you have to do now. So, next step! "],
["step-protopype.html", "Chapter 5 Step 2: Prototype", " Chapter 5 Step 2: Prototype I like to go “UI first”. For two main reasons: Once the UI is set, there is no “surprise implementation”. Once we agree on what elements there are in the app, there is no sudden “oh the app needs to do that now”. A pre-defined UI allows every person involved in the coding to know which part of the app they are working on. In other words, when you start working on the backend, it’s much easier to work on a piece you can visually identify and integrate in a complete app scenario. So yes, spend time writing a front-end prototype in lorem ipsum. And good news, we’ve got a tool for you: it’s called {shinipsum}. The main goal of this package is to create random Shiny elements that can be used to draw a UI, without actually doing any heavy lifting in the backend. Hence, once you’ve got a draft of your app on a piece of paper, you can then move to the “ipsum-UI” stage: building the front-end of the app, and filling it with random Shiny elements, with functions like random_ggplot() or random_DT(). Another package that can be used to do that is {fakir}. This package is designed to create fake data frames, primarily for teaching purposes, but it can also be used for inserting data into a shiny prototype. "],
["step-build.html", "Chapter 6 Step 3: Build", " Chapter 6 Step 3: Build Now the UI and the features are set, time to work on the backend. This part is pretty standard — everybody can now work on the implementation of the functions that process the app inputs, in their own modules. As the UI, functionalities and modules have been defined in the previous steps, everyone (well, in theory) knows what they have to work on. And also, as said before, there should be no “surprise implementation”, as the app has been well defined before. "],
["step-secure.html", "Chapter 7 Step 4: Secure", " Chapter 7 Step 4: Secure Securing your app means two things: testing, and locking the application environment. So first, be sure to include tests all along the building process — just like any other R code. As the app is contained in a package, you can use standard testing tools for testing the business logic of your app — as said in the first part, it’s important to split the backend functions and algorithm from the user interface. That means that these backend functions can run outside of the application. And yes, if they can run outside of the app, they can be tested the standard way, using {testthat}. When it comes to testing the front end, you can try the {shinytest} package from RStudio, if you need to be sure there is no visual regression all along the project development. {shinyloadtest}, on the other hand, tests how an application behaves when one, two, three, twenty, one hundred users connect to the app, and gives you a visual report about the connection and response time of each session. One other tool I like to use is Katalon Studio. It’s not R related, and can be used with any kind of web app. How it works is quite simple: it opens your browser where the Shiny app runs, and record everything that happens. Once you stop the recording, you can relaunch the app and it will replay all the events it has recorded. And of course, you can specify your own scenario, define your own events, etc. It’s not that straightforward to use, but once you get a good grasp of how it works, it’s a very powerful tool. Secondly, secure your app means that it can be deployed again any time in the future — in other words, you have to ensure you’ve got a proper handle on the required R version, and of the package versions which are required to run your app. That means that you have to be aware that upgrading a package might break your app — so, provide an environment that can prevent your app from breaking when a package gets updated. For that, there is, of course, Docker, R specific tools like {packrat}, or deploying custom CRAN repositories or package manager. "],
["step-deploy.html", "Chapter 8 Step 5: Deploy", " Chapter 8 Step 5: Deploy Tools for deployment are not the subject of this blog post so I won’t talk about this in detail (remember, we are talking about building 😉 ), but our two tools of choice are Docker &amp; ShinyProxy, and RStudio Connect. // TODO: link to resources. "],
["golem.html", "Chapter 9 Using Golem 9.1 Getting started with {golem} 9.2 dev/01_start.R 9.3 Day to Day Dev with {golem} 9.4 Launching the app 9.5 dev/02_dev.R 9.6 Documentation 9.7 Using {golem} dev functions 9.8 Deploying Apps with {golem} 9.9 Using {golem} js functions", " Chapter 9 Using Golem Ok, that’s a lot of things to process. Is there a tool that can help us simplify this workflow? Of course there is, and it’s called {golem}. It can be found at https://github.com/ThinkR-open/golem For now, {golem} can only be found on GitHub (but it should be on CRAN soon), so you have to install it with: remotes::install_github(&quot;Thinkr-open/golemn&quot;) {golem} is an R package that implements an opinionated framework for building production-ready Shiny apps. It all starts with an RStudio project, which contains a predefined setup for building your app. The idea is that with {golem}, you don’t have to focus on the foundation of your app, and can spend your time thinking about what you want to do, not about how to do it. It’s built on top of the working process we’ve developed at ThinkR, and tries to gather in one place the functions and tools we’ve created for building applications designed for production. 9.1 Getting started with {golem} Note before using {golem}: A {golem} app is contained inside a package, so knowing how to build a package is highly recommended. A {golem} app works better if you are working with shiny modules, so knowing how modules work is heavily recommended. In the rest of the Vignettes, we’ll assume you’re working in RStudio. 9.1.1 Create a package Once the package is installed, you can got to File &gt; New Project… in RStudio, and choose “Package for Shiny App Using golem” input. If you want to do it through command line, you can use: golem::create_shiny_template(path = &quot;path/to/package&quot;) This command allows you to create “illegally-named” package (for example, 1234) by passing the check_name argument to FALSE. Note that this is not recommanded and should only be done if you know what you are doing. Once you’ve got that, a new RStudio project will be launched. Here is the structure of this project: DESCRIPTION ¦--dev/ ¦--01_start.R ¦--02_dev.R ¦--03_deploy.R ¦--run_dev.R ¦--inst/ ¦--app ¦--server.R ¦--ui.R ¦--www/ ¦--favicon.ico ¦--man/ ¦--run_app.Rd NAMESPACE myapp.Rproj ¦--R/ ¦--app_server.R ¦--app_ui.R ¦--run_app.R ] If you’re already familiar with R pacakges, most of these files will appear very familiar to you. That’s because a {golem} app IS a package. DESCRIPTION &amp; NAMESPACE: Package meta-data. dev/: Scripts that will be used along the process of developping your app. inst/app: You’ll add external dependencies in www (images, css, etc). Don’t touch app_ui and app_server. man: Package doc, to be generated by R. myapp.Rproj: RStudio project. R/app_server.R, R/app_ui.R: Top level UI and server elements. R/run_app.R: a function to configure and launch the application. 9.2 dev/01_start.R Once you’ve created your project, the first file that opens is dev/01_start.R. This file contains a series of commands to run once, at the start of the project. 9.2.1 Fill the DESC First, fill the DESCRIPTION by adding information about the package that will contain your app: golem::fill_desc( pkg_name = &quot;shinyexample&quot;, # The Name of the package containing the App pkg_title = , # The Title of the package containing the App pkg_description = , # The Description of the package containing the App author_first_name = , # Your First Name author_last_name = , # Your Last Name author_email = , # Your Email repo_url = NULL) # The (optional) URL of the GitHub Repo 9.2.2 Set common Files If you want to use the MIT licence, README, code of conduct, lifecycle badge, and news usethis::use_mit_license(name = &quot;Your Name&quot;) # You can set another licence here usethis::use_readme_rmd() usethis::use_code_of_conduct() usethis::use_lifecycle_badge(&quot;Experimental&quot;) usethis::use_news_md() 9.2.3 Add a data-raw folder If you have data in your package usethis::use_data_raw() 9.2.4 Init Tests Create a template for tests: golem::use_recommended_tests() 9.2.5 Use Recommended Package This will add “shiny”, “DT”, “attempt”, “glue”, “htmltools”, and “golem” as a dependecy to your package. golem::use_recommended_dep(&quot;&quot;) 9.2.6 Add various tools These two functions add a file with various functions that can be used along the process of building your app. See each file in details for a description of the functions. golem::use_utils_ui() golem::use_utils_server() 9.2.7 If you want to change the default favicon golem::use_favicon( path = &quot;path/to/favicon&quot;) You’re now set! You’ve successfully initiated the project and can go to dev/02_dev.R. rstudioapi::navigateToFile(&quot;dev/02_dev.R&quot;) 9.3 Day to Day Dev with {golem} Now that you’re all set with your project init, time to move to development :) App development should happen through the dev/02_dev.R file, which contains common commands for developping. 9.4 Launching the app To run the app, go to the dev/run_dev.R file, and run the all thing. 9.5 dev/02_dev.R 9.5.1 Add modules The golem::add_module() functions creates a module in the R folder. The file and the modules will be named after the name parameter, by adding mod_ to the R file, and mod_*_ui and mod_*_server to the UI and server functions. golem::add_module(name = &quot;my_first_module&quot;) # Name of the module The new file will contain: # mod_UI mod_my_first_module_ui &lt;- function(id){ ns &lt;- NS(id) tagList( ) } mod_my_first_module_server &lt;- function(input, output, session){ ns &lt;- session$ns } ## To be copied in the UI # mod_my_first_module_ui(&quot;my_first_module_1&quot;) ## To be copied in the server # callModule(mod_my_first_module_server, &quot;my_first_module_1&quot;) In order not to make errors when putting these into your app, the end of the file will contain code that has to be copied and pasted inside your UI and server functions. 9.5.2 Add dependencies To be called each time you need a new package as a dependency: usethis::use_package(&quot;pkg&quot;) 9.5.3 Add tests Add more tests to your application: usethis::use_test(&quot;app&quot;) 9.5.4 Add a browser button Learn more about this: https://rtask.thinkr.fr/blog/a-little-trick-for-debugging-shiny/ golem::browser_button() 9.5.5 Add external files These functions create external dependencies (JavaScript and CSS). add_js_file() creates a simple JavaScript file, while add_js_handler() adds a file with a skeleton for shiny custom handlers. golem::add_js_file(&quot;script&quot;) golem::add_js_handler(&quot;script&quot;) golem::add_css_file(&quot;custom&quot;) 9.6 Documentation 9.6.1 Vignette usethis::use_vignette(&quot;shinyexample&quot;) devtools::build_vignettes() 9.6.2 Code coverage usethis::use_travis() usethis::use_appveyor() usethis::use_coverage() 9.7 Using {golem} dev functions There’s a series of tools to make your app behave differently whether it’s in dev or prod mode. Notably, the app_prod() and app_dev() function tests for options( &quot;golem.app.prod&quot;) (or return TRUE if this option doesn’t exist). Setting this options at the beginning of your dev process allows to make your app behave in a specific way when you are in dev mode. For example, printing message to the console with cat_dev(). options( &quot;golem.app.prod&quot; = TRUE) golem::cat_dev(&quot;hey\\n&quot;) options( &quot;golem.app.prod&quot; = FALSE) golem::cat_dev(&quot;hey\\n&quot;) ## hey You can then make any function being “dev-dependant” with the make_dev() function: log_dev &lt;- golem::make_dev(log) log_dev(10) ## [1] 2.302585 options( &quot;golem.app.prod&quot; = TRUE) log_dev(10) 9.8 Deploying Apps with {golem} The dev/03_deploy.R file contains function for deploying on various plateforms. 9.8.1 RStudio Connect To create an app.R ready to be deployed on RStudio Connect, run: golem::add_rconnect_file() 9.8.2 Docker You can create a generic Dockerfile, or one which is plateform specific (for now, only ShinyProxy and Heroku are supported). # If you want to deploy via a generic Dockerfile golem::add_dockerfile() # If you want to deploy to ShinyProxy golem::add_shinyproxy_dockerfile() # If you want to deploy to Heroku golem::add_heroku_dockerfile() 9.9 Using {golem} js functions {golem} comes with a series of JavaScript functions that you can call from the server. These functions are added by default with golem::js() in app_ui. Then they arer called with session$sendCustomMessage(&quot;fonction&quot;, &quot;ui_element&quot;). This ui_element define the UI element to interact with. It can be a full jQuery selector, an id or a class. 9.9.1 golem::js() showid &amp; hideid, showclass &amp; hideclass show and hide elements through their id or class. session$sendCustomMessage(&quot;showid&quot;, ns(&quot;plot&quot;)) showhref &amp; hidehref hide and show a link by trying to match the href content. session$sendCustomMessage(&quot;showhref&quot;, &quot;panel2&quot;) clickon click on the element. You have to use the full jQuery selector. show &amp; hide show and hide elements, using the full jQuery selector. 9.9.2 About jQuery selectors #plop: the element with the id plop .pouet: elements of class pouet &quot;button:contains('this')&quot;: buttons with a text containing 'this' Note that in html, tags contains attributes. For example: &lt;a href = &quot;https://thinkr.fr&quot; data-value = &quot;panel2&quot;&gt;ThinkR&lt;/a&gt; contains href &amp; data-value. You can refer to these attributes with [] after the tag name. a[href = &quot;https://thinkr.fr&quot;]: link with href being https://thinkr.fr a[data-value=&quot;panel2&quot;]: link with data-value being &quot;panel2&quot; "],
["proto.html", "Chapter 10 Prototyping 10.1 {shinipsum} 10.2 {fakir}", " Chapter 10 Prototyping These two tools allow you to prototype a Shiny App and to go “UI first”. Learn more: 10.1 {shinipsum} // TODO https://github.com/ThinkR-open/shinipsum 10.2 {fakir} // TODO https://github.com/ThinkR-open/fakir "],
["tooling.html", "Chapter 11 Other tools 11.1 Package 11.2 Git 11.3 Shiny modules 11.4 CI and testing", " Chapter 11 Other tools 11.1 Package We believe that Shiny Apps are to be put into a package. Why? Because it allows them to be documented, tested, and can be installed in several environments. Also, think about your last Shiny app that wasn’t in a package. It’s an app.R, maybe with a folder you’re sourcing and which contains functions (let’s say in aR/ folder). Maybe you’ve written some meta information (let’s call it a DESCRIPTION), and some tests you’ve put in a tests/ folder. Also, as you want to be sure to do the things right, you’ve put documentation in your functions. Do you see where I’m heading? Yes, you’ve written an R package. 11.2 Git Friends don’t let friends work on a coding project without version control. // TO DO 11.3 Shiny modules Shiny modules are crucial tools when it comes to building big shiny apps: they allow to collaborate, to split the work into pieces, they facilitate testing, and they allow implementation of new features to be made more easily. // TO DO: develop more and link to resources 11.4 CI and testing Testing is central for making your application survive in the long run. The {testthat} package can be used to test the “business logic” side of your app, while the application features can be tested with packages like {shinytest}, or software like Katalon. // TO DO: more info about the tools + link to resources. "],
["optim-caveat.html", "Chapter 12 Common Application Caveats", " Chapter 12 Common Application Caveats // TODO "],
["optim-r.html", "Chapter 13 Optimizing Shiny Code", " Chapter 13 Optimizing Shiny Code // TODO "],
["optim-js.html", "Chapter 14 Using JavaSript", " Chapter 14 Using JavaSript // TODO "]
]
