[
["index.html", "Engineering Production-Grade Shiny Apps Introduction Motivation Book structure About the authors Want to help? Other resources Acknowledgments", " Engineering Production-Grade Shiny Apps Colin Fay, Vincent Guyader, Cervan Girard, Sébastien Rochette 2020-02-09 Introduction img.left { float: left; margin-right: 1em; } This book is currently under development. It will be published in 2020 in the R Series by Chapman &amp; Hall. Motivation This book will not get you started with Shiny, nor talk about how to deploy into production and scale your app. What we’ll see is the process of building the app. Why? Lots of blog posts and books talk about starting to use shiny or putting apps in production. Very few (if any) talk about this grey area between getting started and pushing into production. So this is what this book is going to talk about: building Shiny application. We’ll focus on the process, the workflow, and the tools we use at ThinkR when building big Shiny Apps. Hence, if you’re starting to read this book, we assume you have a working knowledge of how to build a small application, and want to know how to go one step further. Book structure Part 1 (Building big Shiny Apps) gives a general context about what is a successful Shiny Apps and what challenges arise when you’re dealing with a large scale application. It also introduces the {golem} package and more general concept about organising your workflow. This first part will be light on code: you’ll read more about conceptual ideas and organisation strategy. Part 2 to 6 describes a series of steps you can take when you want to build a Shiny App, and the tooling associated with each step. Part 7 (Optimizing) tackles the question of optimization, first by presenting some common caveats of Shiny Apps, and then showing how to optimize R code, and use JavaScript to lighten R work. About the authors // TODO Colin Fay Vincent Guyader Cervan Girard Sébastien Rochette Want to help? Any feedbacks on the book is very welcome. Feel free to open an issue, or to make a PR if you spot a typo (I’m not a native english speaker, so there might be some waiting to be found ;) ). Other resources Getting started with Shiny Learn Shiny with RStudio Getting Started with Shiny (WIP) Mastering Shiny A gRadual intRoduction to Shiny Shiny into production Shiny in production: Principles, practices, and tools Shiny in Production Suggest a Resource! Acknowledgments Contributors to this book Liz Roten, for proofreading chapter 1 and helping us with writing advices. Dan S. Reznik, for proof-reading the JavaScript chapter. // TODO : "],
["successfulshinyapp.html", "Chapter 1 About Successful Shiny Apps 1.1 A (very) short introduction to Shiny 1.2 What is a complex Shiny Application? 1.3 What is a successful Shiny App?", " Chapter 1 About Successful Shiny Apps I Too Like to Live Dangerously .right{ text-align: right;} Austin Powers 1.1 A (very) short introduction to Shiny If you are reading this page, chances are you already know what a Shiny application (“Shiny app”) is — a web application that communicates with R, built in R, and working with R. The beauty of {shiny} is that it makes it easy for anybody to create a small app in a matter of hours. With small and minimal Shiny apps, no knowledge of HTML, CSS or JavaScript is required. With very little training, you can rapidly create a proof-of-concept (POC) for a data-product and showcase an algorithm or present your results in an elegant and accessible to build user interface. The first version of {shiny} was published in 2012. Since then, it has been one of the top project of the RStudio team. At the time of writing these lines (January 2020), there are more than 4600 commits in the master branch of the main GitHub repository, made by 46 contributors. It is now downloaded around 400K times a month, according to cranlogs, and has 711 reverse dependencies (package that depends on it) according to devtools::revdep(&quot;shiny&quot;). If you are very new to Shiny, this book might feel a little bit complex. Indeed, it relies on the assumption that you already know how to build (at least basic) Shiny applications and that you want to push your Shiny skills to the next level. If you are very new to Shiny, we suggest you start with the Mastering Shiny book before reading the present book. Ready to get started with complex Shiny App? 1.2 What is a complex Shiny Application? One of the unfortunate things about reality is that it often poses complex problems that demand complex solutions .right{ text-align: right;} The Art of Unix Programming 1.2.1 Reaching the cliff of complexity After a few hours of practice, things seems quite straightforward when it comes to small prototypes or proof of concepts. But things change when your application reaches “the cliff of complexity”1. But what do we mean by complexity? Getting a clear definition is not an easy task2 as it very depends on who is concerned and who you are talking to. A good definition is the one from The Art of Unix Programming: “Complex software is harder to think about, harder to test, harder to debug, and harder to maintain — and above all, harder to learn and use.” But let us try to come with a definition that will serve us in the context of engineering Shiny applications. When building software, we can think of complexity from two points of view: the complexity as it is seen by the coder, and the complexity as it is seen by the customer / end user.3 With great complexity comes great responsibility When your program reaches this state, there is a lot of potential for failure, be it from a developer or user perspective. For the code, bugs are harder to anticipate: it is hard to think about all the different paths the software can follow and difficult to detect bugs because they are deeply nested in the numerous routines the app is doing. It is also hard to think about what the state of your app is at a given moment because of the numerous inputs and outputs your app contains. From the user perspective, the more complex an app is, the steeper the learning curve. Indeed, the user will have to invest more time learning how the app works, and will be even more disappointed if ever they realize this time has been a waste. 1.2.1.1 Developers complexity An app is to be considered complex when it is big enough in terms of size and functionality that it makes it impossible to reason about it at once, and you must rely on tools to understand and handle this complexity. This type of complexity is called implementation complexity. One of the goal of this book is to present you a methodology and toolkit that will help you reduce this form of complexity. 1.2.1.2 Customers and users complexity Customers and end user see complexity as interface complexity. Interface complexity can be driven by a lot of elements, for example the probability of making an error while using the app, the difficulty to understand the logical progression in the app, the presence of unfamiliar behaviour or terms, visual distractions… This book will also bring you strategy to help you cope with the need for simplification when it comes to designing interface. 1.2.2 Balancing complexities Designing an app means taking decisions to find a good balance between implementation and interface complexity, i.e. between developers and users sources of complexity. Lowering one source of complexity usually means to increase the other. Drawing a line between the two very much depends on the kind of project you are working on, and on the kind of users that will use your app. This usually requires to restrain yourself from implementing too much, and still create an application that is easy to use. For example, there is something common with Shiny: what we can call “the too much reactivity pattern”. In some cases, coders try to make everything reactive: e.g., three sliders and a dropdown input, all updating a single plot. This behavior lowers the interface complexity: users do not have to think a lot about what they are doing, they move sliders, change the input and the plot updates. But this kind of pattern can make the app compute too many things: users rarely go to the slider value they need on their first try. They usually miss what they actually want to select in an input. Each time a slider or an input has changed, R will calculate a new plot. Thus, a lot of not necessary computation for R. One solution can be to delay reactivity or to cache things so that R computes fewer things. But that comes with a cost: handling delayed reactivity and caching elements increases implementation complexity. Another solution is to add an “update plot” button, which updates the plot only when the user clicks on it. This pattern makes it easier to control reactivity from an implementation side. But this complexify the interface for the users who have to perform another action in addition to changing their inputs. Another good example is {shiny}’s dateRangeInput() function. This function requires the user to choose a starting date and an ending date. However, the function allows to choose a start posterior to the end (which is the behavior of the JavaScript plugin used in {shiny} to create this input). If theses dates are used to filter data upper tjan starting date and lower than ending date, this behaviour will be problematic for your application. Handling this special case is doable: with a little bit of craft, you can watch what the user inputs and throw an error if the start is after the end.4 That solution increases implementation complexity, while leaving it as is requires the user to think about whether or not the starting date is before the ending date, thus increasing the interface complexity. 1.2.3 Assessing code complexity On the developer side, you need to reduce code complexity to be able to create a mental model of the functionning of your application so that you can add functionnalities, debug, test and maintain your code for production. Before starting the project, you can try to identify potential sources of complexities and identify spots where complexity will not be necessary. Some prior questions can help you in this way (we will develop that later in this book). Your knowledge will help you spot asked features that will be hard, long to implement. But are they all necessary ? As the developer responsible of the project, you will have to ask some questions to users about how much the application will be used, how frequently, by what kind of users, what is the main purpose of the app, how critical is the success of the app for the customer… Thus you can propose alternatives that will balance complexity between user and developers. But at some point, you will start writing code and will have to write unit tests, check the consequences of all the inputs of the Shiny interface on your code, integrate changes… To be able to build a successful Shiny application, the main developers will have to have a mental representation of the entire code, which will not be possible if there is too much complexity. Some tools and measures may help warn you about the complexity of the code you are developing. 1.2.3.1 Codebase size The total number of lines of code or the number of files may be good indices of potential complexity if used as an order of magnitude (100, 1000, 10000 lines), but do not reduce number of lines at the cost of readability. R is very permissive when it comes to indentation and line breaks, and, unlike JavaScript or CSS, it is generally not minified5. Number of lines of code depends on your coding style and the packages you are using. Consider this piece of valid R code: iris[ 1 : 5, &quot;Species&quot; ] [1] setosa setosa setosa setosa setosa Levels: setosa versicolor virginica Six lines of code for something that could also be written in one line. iris[1:5, &quot;Species&quot;] [1] setosa setosa setosa setosa setosa Levels: setosa versicolor virginica In other words, using this kind of writing style can make the code base larger in term of lines, without really adding complexity to the general program. Another drawback of this metric is that it focuses on numbers instead of readability, and in the long run, yes, readability matters.6 For example, {tidyverse} packages encourage the use of the pipe (%&gt;%)7 with one function by line. This eases readability, but produces many lines in the end code. Still, this metric can be useful to reinforce what you have learned from other metrics. It is rather unlikely that you will find this “extreme” coding style we showed above, and even if it might not make sense to compare two code base that just differ by 1 or 2 % of lines of code, it is very likely that a code base which is ten, one hundred, one thousand times larger is a more complex software. Another good sign related to this metric is the number of files in the project: R developers tend to split their functions into several files, so the more files you will find in a project, the larger the code base is. Numerous files can also be a sign of maintenance complexity. It may be harder to reason about an app logic split into several files than about something that fits into one linear code inside one file. Altough, you can define files that respect the visual structure of the application, with explicit filenames. If you want to use the number of lines metric, you can directly use R with the {cloc} package, available at https://github.com/hrbrmstr/cloc. if (!requireNamespace(&quot;cloc&quot;)){ remotes::install_github(&quot;hrbrmstr/cloc&quot;) } For example, let us compare a rather big package ({shiny}) with a small one ({attempt}): library(cloc) library(dplyr) shiny_cloc &lt;- cloc_cran(&quot;shiny&quot;, .progress = FALSE, repos = &quot;http://cran.irsn.fr/&quot; ) attempt_cloc &lt;- cloc_cran(&quot;attempt&quot;, .progress = FALSE, repos = &quot;http://cran.irsn.fr/&quot; ) clocs &lt;- bind_rows( shiny_cloc, attempt_cloc ) # Counting lines of code clocs %&gt;% group_by(pkg) %&gt;% summarise( loc = sum(loc) ) # A tibble: 2 x 2 pkg loc &lt;chr&gt; &lt;int&gt; 1 attempt 4011 2 shiny 71478 # Counting files clocs %&gt;% group_by(pkg) %&gt;% summarise( files = sum(file_count) ) # A tibble: 2 x 2 pkg files &lt;chr&gt; &lt;int&gt; 1 attempt 35 2 shiny 269 Here, with these two metrics, we can safely assume that {shiny} is a more complex package than {attempt}. 1.2.3.2 Cyclomatic complexity Cyclomatic complexity is a software engineering measure which allows to define the number of different linear paths a piece of code can take, the higher the number of paths through one function, the harder is the mental model build. Cyclomatic complexity is computed based on a control-flow graph8 representation of an algorithm. The complexity number is then computed by taking the number of nodes, and subtracting the number of edges plus two times the number of connected components of this graph: \\(M = E − N + 2P\\), where \\(M\\) is the measure, \\(E\\) the number of edges, \\(N\\) the number of nodes and \\(2P\\) is 2 time the number of connected components. We will not go deep into this topic, as there are a lot things going on in this computation and you can find many documentation about this online. Please refer to the bibliography for further readings about the theory behind this measurement. In R, the cyclomatic complexity is computed with the {cyclocomp} package, which can be installed from CRAN with: install.packages(&quot;cyclocomp&quot;) The cyclocomp package comes with three main functions: cyclocomp(), cyclocomp_package(), and cyclocomp_package_dir(). The one we will be interested in is cyclocomp_package_dir(): building successful shiny apps with the {golem} framework (we will get back on that later) means you will be building your app as a package. You can then use cyclocomp_package_dir() to compute the complexity of your app. Here is for example the cyclomatic complexity of the default golem template: library(cyclocomp) cyclocomp_package(&quot;golex&quot;) %&gt;% head() name cyclocomp 1 app_server 1 2 app_ui 1 3 golem_add_external_resources 1 4 run_app 1 And the one from another small application: cyclocomp_package(&quot;tidytuesday201942&quot;) %&gt;% head() name cyclocomp 24 mod_dataviz_ui 8 23 mod_dataviz_server 7 35 rv 6 14 display 4 39 undisplay 4 37 tagRemoveAttributes 3 And, finally, the one for {shiny}: cyclocomp_package(&quot;shiny&quot;) %&gt;% head() name cyclocomp 507 untar2 75 119 diagnoseCode 54 399 runApp 50 155 find_panel_info_non_api 37 381 renderTable 37 105 dataTablesJSON 34 And, bonus, this cyclocomp_package() function can also be used to retrieve the number of functions inside the package. So, as The Clash said, “what are we gonna do now?” Splitting things into smaller pieces lower the local cyclomatic complexity as passing twice into the same block of code is reduce with wisely chosen unit pieces. Leveraging the strength of S3 methods to split elements: if you have a function that behave differently based on the type of the input, generics and methods are easier to reason about than if statements inside a larger function. But that is not a magic solution: (A) because the global complexity of the app is not lowered by splitting things into pieces, (B) because the deeper the call stack, the harder it can be to reason about the big picture. 1.2.3.3 Other measures for code complexity Complexity can come from other sources: unsufficient code coverage leading to bugs that are hard to spot, dependencies that breaks the implementation, old package, or a lot of other things. We can use the {packageMetrics2} package to spot multiple metrics like the number of dependencies, the code coverage, the number of releases. This also includes number of lines of R code and cyclomatic complexity. library(packageMetrics2) frame_metric &lt;- function(pkg){ metrics &lt;- package_metrics(pkg) tibble::tibble( n = names(metrics), val = metrics, expl = list_package_metrics()[names(metrics)] ) } frame_metric(&quot;golem&quot;) %&gt;% knitr::kable() Metrics: ARR ATC DWL DEP DPD CCP FLE FRE LIB LLE LNC LNR LRE NAT NTF NUP OGH SAP SEM SEQ SWD VIG n val expl ARR 0 Number of times = is used for assignment ATC NA Author Test Coverage DWL 7818 Number of Downloads DEP 27 Num of Dependencies DPD 1 Number of Reverse-Dependencies CCP 2.33898305084746 Cyclomatic Complexity FLE 16.8833333333333 Average number of code lines per function FRE 2019-08-05T14:50:02+00:00 Date of First Release LIB 0 Number of library and require calls LLE 26 Number of code lines longer than 80 characters LNC 0 Number of lines of compiled code LNR 1464 Number of lines of R code LRE 2019-08-05T14:50:02+00:00 Date of Last Release NAT 0 Number of attach and detach calls NTF 0 Number of times T/F is used instead of TRUE/FALSE NUP 0 Updates During the Last 6 Months OGH 1 Whether the package is on GitHub SAP 1 Number of sapply calls SEM 0 Number of trailing semicolons in the code SEQ 0 Number of 1:length(vec) expressions SWD 18 Number of setwd calls VIG 4 Number of vignettes frame_metric(&quot;shiny&quot;) %&gt;% knitr::kable() Metrics: ARR ATC DWL DEP DPD CCP FLE FRE LIB LLE LNC LNR LRE NAT NTF NUP OGH SAP SEM SEQ SWD VIG n val expl ARR 14 Number of times = is used for assignment ATC 29.2461947330273 Author Test Coverage DWL 12107245 Number of Downloads DEP 22 Num of Dependencies DPD 722 Number of Reverse-Dependencies CCP 3.79710144927536 Cyclomatic Complexity FLE 24.2420168067227 Average number of code lines per function FRE 2012-12-01T07:16:17+00:00 Date of First Release LIB 1 Number of library and require calls LLE 424 Number of code lines longer than 80 characters LNC 0 Number of lines of compiled code LNR 24737 Number of lines of R code LRE 2019-10-10T11:50:02+00:00 Date of Last Release NAT 0 Number of attach and detach calls NTF 0 Number of times T/F is used instead of TRUE/FALSE NUP 1 Updates During the Last 6 Months OGH 1 Whether the package is on GitHub SAP 10 Number of sapply calls SEM 1 Number of trailing semicolons in the code SEQ 0 Number of 1:length(vec) expressions SWD 6 Number of setwd calls VIG 0 Number of vignettes If you are building you Shiny application with {golem}, a framework for building shiny apps, you can use the DESCRIPTION file, the one that contains the list of dependencies, as a starting point to explore these metrics for your dependencies: desc::desc_get_deps(&quot;golex/DESCRIPTION&quot;) type package version 1 Imports shiny * 2 Imports golem * # See also attachment::att_from_description(&quot;golex/DESCRIPTION&quot;) [1] &quot;golem&quot; &quot;shiny&quot; 1.2.4 Production Grade Software Engineering The use of R has evolved since its initial version released in 1995, using it 25 years later, as a tool to build softwares released in production, is a challenge. Complexity is still frowned upon by a lot of developers, notably because it has been seen as something to avoid according to the Unix philosophy. But there are dozens of reasons why an app can become complex: for example, the question your app is answering is quite complicated and involves a lot of computation and routines. The resulting app is rather ambitious and implements a lot of features, etc. So yes, there is a chance that if you are reading this page, you are working or are planning to work on a complex Shiny app. And this is not necessarily a bad thing! Shiny apps can definitely be used to implement production-grade9 software, but production-grade software implies production-grade software engineering. To make your project a success, you need to use tools that reduce the complexity of your app and ensure that your app is resilient to aging. In other words, production-grade Shiny apps requires working with a software engineering mindset, which is not always an easy task in the R world. Many developers in the R world have learned R as a tool for data analysis, building model, making statistics, not really as a tool for building softwares. Before {shiny}, a few graphical interfaces were built using {tcltk}, as tools for decision-making for instance. But the arrival of {shiny} has drastically increased the potential of R for software building. Its accessibility is also one of the sources of its success in multiple fields, in particular out of the academics, source of the R development. This changing context requires different mindsets, skills, and tools. With {shiny}, as we said before, it is quite easy to prototype a simple app, without any “hardcore” software engineering skills. And when we are happy with our little proof of concept, we are tempted to add something new. And another. And another. And without any structured methodology, we are almost certain to reach the cliff of complexity very soon and end up with a code base that is hardly (if ever) ready to be refactored to be sent to production. The good news is that building a complex app with R (or with any other language) is not an impossible task. But this requires planning, rigor, and correct engineering. This is what this book is about: how to organise your Shiny App in a way that is time and code efficient, and how to use correct engineering to make your app a success. 1.3 What is a successful Shiny App? Your application does not have to be complex to be successful. Even more, in a world where “less is more”, the more you can reduce your application complexity, the more you will be prepared for success. So what is a successful Shiny app? Defining such a metric is not an easy a task, but we can extract some common patterns when it comes to applications that would be considered successful. 1.3.1 It exists First of all, an app is successful if it was delivered. In other words, the developer team was able to move from specification to implementation, testing then delivering. This is a very engineering-oriented definition of success, but it is a pragmatic one: an app that never reaches the state of usability is not a successful app, as something along the way has blocked the process of finishing the code. This implies a lot of things. Mostly it implies that the team was able to organise itself in an efficient way, so that they were able to work together in making the project a success. Anybody that has already worked on a code base as a team knows it is not an easy task. 1.3.2 It is accurate The app was delivered, and it answers the question it is supposed to answer, or serves the purpose it is supposed to serve. Delivering is not the only thing to keep in mind: you can deliver a working app but it might not work in the way it is supposed to work. Just as before, accuracy means that between the moment the idea appears in someone’s mind and the moment the app is actually ready to be used, everybody was able to work together toward a common goal. 1.3.3 It is usable The app was delivered, it serves the purpose, and it is user-friendly. Unless you are coding for the sake of the art, there will always be one or more end users. And if these people cannot use the app because it is too hard to use, too hard to understand, because it is too slow or there is no inherent logic in how the user experience is designed, then it is inappropriate to call the app is a success. 1.3.4 It is immortal Of course this is a little bit far fetched, but when designing the app, you should set the ground for robustness in time and aim at a (theoretical) immortality of the app. Planning for the future is a very important component of a successful Shiny App project. Once the app is out, it is successful if it can exist in the long run, with all the hazards that implies: new package versions that potentially break the code base, implementation of new features in the global interface, changing key features of the UI or the back-end, and not to mention passing the code base along to someone who has not worked on the first version, and who is now in charge of developing the next version. And this, again, is hard to do without effective planning and efficient engineering. In fact, this new person might simply be you, a month from now. And &quot;You’ll be there in the future too, maintaining code you may have half forgotten under the press of more recent projects. When you design for the future, the sanity you save may be your own.10 from The Art of Unix Programming, “Chapter 13: Speaking of Complexity”↩ see shiny/issues/2043#issuecomment-525640738 for an example↩ “Pressure to keep the codebase size down by using extremely dense and complicated implementation techniques can cause a cascade of implementation complexity in the system, leading to an un-debuggable mess.”, from The Art of Unix Programming, “Chapter 13: Speaking of Complexity”↩ By production-grade, we mean a software that can be used in a context where people use it for doing their job, and where failures or bugs have real-life consequences↩ The Art of Unix Programming, Eric Steven Raymond↩ "],
["planning.html", "Chapter 2 Planning Ahead 2.1 Working with a “long-term” mindset 2.2 Working as a team: tools &amp; organisation", " Chapter 2 Planning Ahead 2.1 Working with a “long-term” mindset “Rome ne fut pas faite toute en un jour” French proverb 2.1.1 Prepare for success Whatever are your ambitions for your Shiny application, you should take a little time to set robust foundations that will save a lot of time in the future. A common thing you will hear about Shiny is that it is a good prototyping tool. This can not be denied. Building a Proof of Concept (POC) for an app is relatively easy if you compare to what it needs when building applications in other languages. With Shiny, you can build a “it works on my machine” web application in a couple of hours, and show it to your team, your boss, your investors… Thanks to the way Shiny is built, you do not have to care about websocket, ports, html, JavaScript, libraries, and all the things that are elegantly bundled straight into Shiny. Hence, you can have a quick, hacky application that will work on your machine, and that, very rapidly. But that is not the way you should start. Indeed, starting with hacky foundations will lead to two possibilities: You will have to rewrite everything from scratch to have a robust application for production. If you do not want to do that, you will get stucked with a legacy code base for the app that is built on top of hacky functions. The idea there is that even if Shiny is a good tool for prototyping, there is no harm in starting your application on solid ground, even for a prototype. In this book, we will present a framework called {golem}, which is a toolbox for building production-grade Shiny applications. Even if {golem} is focused on production, there is no reason not to use it for your proof of concepts: starting a new {golem} project is relatively straightforward, and even if you do not use the advanced features, you can use it for very small apps. That way, you are getting ready for complexity, and if, one day, you need to turn this small app into a production app, the foundations are there. 2.1.2 Develop with the KISS principle The KISS principle, as “Keep It Simple, Stupid”, should drive the implementation of features in the application to allow anyone in the future, including original developers, to take over on the development. Deeply rooted in the Unix Philosophy, the KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided. .right{ text-align: right;} KISS principle The story behind this principle is supposed to be that Kelly Johnson, lead engineer at the Lockheed Skunk Works, gave his workers a set of very common tools and said that the airplanes should be repairable with these tools, and these tools only. The idea behind this being that repairing an aircraft should be possible for any average engineer. This should be a principle to keep in mind when building application. Indeed, large scale Shiny projects can lead to many people working on the code base, for a long period of time. Many people means a variety of skills, with some common ground in Shiny development. So when choosing how and what to implement, try to make a rule to go for the simplest solution11, i.e. the one that any common Shiny Developer would be able to understand and maintain. If you go for an exotic solution or a complex technology, be sure that you are doing it for a good reason: unknown or hard to grasp technology reduce the chance of finding someone that will be able to maintain that piece of code in the future. 2.2 Working as a team: tools &amp; organisation Working as a team, whatever the coding project, requires adequate tools, discipline and organisation. Complex Shiny Apps usually imply that several people will work on the application. For example, at ThinkR, 3 to 4 people usually work in parallel on the same application, but there might be more people involved on larger projects. The choice of tools and organisation is crucial for a successful application. 2.2.1 From the tools point of view 2.2.1.1 Version Control &amp; Test all the things To get informed about a code break during development, you will need to write tests for your app, and use continuous integration (CI) so that you are sure this is automatically detected12. When you are working on a complex application, chances are that you will be working on it for a significant period of time, meaning that you will write code, modify it, use it, go back to it after a few weeks, change some other things, and probably break things. Breaking things is a natural process of software engineering, notably when working on a piece of code during a long period. Remember the last chapter where we defined that complex applications are too large to be understood fully? Adding code that breaks the codebase will happen with complex app, so the sooner you take measure to solve code break, the better. As you can not prevent code to break, you should at least get the tooling to: Be informed that the code has broken: this is the role of tests combined with CI Be able to identify changes between versions, and potentially, get back in time to a previous code base: this is the role of version control We will go deeper into testing and version control in chapter 14. 2.2.1.2 Small is beautiful Building an application with multiple small and independant pieces will lighten your development process and your mental load. Previous chapter introduced the notion of complexity in size, where the app grows so large that it is very hard to have a good grasp of it. A large code base implies that the safe way to work is to split the app into pieces as much as possible. Splitting a Shiny project is made possible by following two techniques: Split your app into Shiny Modules, so that your app can be though of as a tree, making it possible for every developer to concentrate on one node, and only one, instead of having to think about the global infrastructure when implementing features Extract your core “non-reactive” functions, that we will also call the “business logic”, and include them in external files, so that you can work on these outside of the app. Working on independent static files to implement features will prevent you to relaunch the whole application every time you need to add something new. We will get back to Shiny module and how to organized your project in the next chapter. 2.2.2 From the organisational point of view We recommend to define two kind of developers: a unique person (or maybe two) to be in charge of supervising the whole project and developers of single functionalities. Management of the project and the communication between the two developers types will be defined around the tools, like git and its graphical interfaces. 2.2.2.1 A person in charge As the person in charge of the development, you will have an overview of the entire project and manage the team so that all developers create pieces of the application that correctly fit together. It is hard to have the complete picture of what the app is doing everywhere. Most of the time, it is not necessary for all developers to have this complete picture. Defining a unique person in charge mentally loads a unique developer. You will have to get the whole picture: what each part of the software is doing, how to make everything working together, avoid development conflicts, and of course check that, at the end of the day, the results returned by the complete application are the correct ones. You will be the one that kicks off the project and write the first draft of the application. If you follow the workflow we will describe in this book, you will create a {golem} project, fill the information, and define the application structure by providing the main modules and the prototype of the app. Once the skeleton of the app is created, list a series of small tasks to be accomplished. We strongly suggest to use git with a graphical interface (Gitlab, Github, Bitbucket, …). Versionning with git can easily be integrated with R. The graphical interface of these services will help you manage the project. The small tasks are defined as issues in the git graphical interface and will be closed during development, while referred to specific modifications of the code (through commits). You will also be able to set continuous integration, as recommended above, to test developers work before integration in the main development branch. If you follow a git flow (described in chapter \\@(ref: secure)) version control workflow, you will also be in charge of reviewing and accepting the pull/merge requests to the main dev branch if they solve the associated issues. Note that you can also be part of the developers. This may indeed be a recommendation as you will directly face difficulties if they arise. However, you will need to be careful in the code review process by assigning someone else to check your work. Do not worry if this sounds like a foreign language to you, we will get back to this method later in this book (chapter \\@(ref: secure)). Note that other management tools can be used there: for example redmine, jira, or any issue tracking software can play this role. 2.2.2.2 Developers As a developer, you will focus on small functionnalities, make sure to protect your work with tests and verify that your implementations do not break others work. If the person in charge correctly splitted the work between developers of the team, you will probably be focusing on one or more parts of the application, but you do not need to know every single bit of what the application is doing. In a perfect world, the application is split in various Shiny Modules, one module equals one file and each member of the team will be assigned a safe development of one or more modules. It is simpler to work in this context where one developer is assigned to one module, although we know that in reality it may be a little more complex, and several members of the team might go back and forth working on a common module. But, the person in charge will be there to help make all the pieces to fit together. "],
["structure.html", "Chapter 3 Structuring your Project 3.1 Shiny App as a Package 3.2 Using Shiny Modules 3.3 Structuring your app", " Chapter 3 Structuring your Project 3.1 Shiny App as a Package In the next chapter you’ll be introduced to the {golem} package, which is an opinionated framework for building production-ready Shiny Applications. This framework starts by creating a package skeleton waiting to be filled. But, in a world where Shiny Applications are mostly created as a series of files, why bother with a package? 3.1.1 What’s in a Shiny App? OK, so let’s ask the question the other way round. Think about your last Shiny which was created as a single-file (app.R) or two files app (ui.R and server.R). You’ve got these two, and you put them into a folder. So, let’s have a review of what you’ll need next for a robust application. First, metadata. In other words, the name of the app, the version number (which is crucial to any serious, production-level project), what the application does, who to contact if something goes wrong. Then, you need to find a way to handle the dependencies. Because you know, when you want to push your app into production, you can’t have this conversation with IT: IT: Hey, I tried to ‘source(“app.R”)’ but I’ve got an error. R-dev: What’s the error? IT: It says “could not find package ‘shiny’”. R-dev: Ah yes, you need to install {shiny}. Try to run ‘install.packages(“shiny”)’. IT: OK nice. What else? R-dev: Let me think, try also ‘install.packages(“DT”)’… good? Now try ‘install.packages(“ggplot2”)’, and … […] IT: Ok, now I source the ‘app.R’, right? R-dev: Sure! IT: Ok so it says ‘could not find function runApp()’ R-dev: Ah, you’ve got to do library(shiny) at the beginning of your script. And library(purrr), and library(jsonlite)*. * Which will lead to a Namespace conflict on the flatten() function that can cause you some debugging headache. So, hey, it would be cool if we could have a Shiny app that only imports specific functions from a package, right? So yes, dependencies matter. You need to handle them, and handle them correctly. Now, let’s say you’re building a big app. Something with thousands of lines of code. Handling a one-file or two-file shiny app with that much lines is just a nightmare. So, what to do? Let’s split everything into smaller files that we can call! And finally, we want our app to live long and prosper, which means we need to document it: each small pieces of code should have a piece of comment to explain what these specific lines do. The other thing we need for our application to be successful on the long term is tests, so that we are sure we’re not introducing any regression. Oh, and that would be nice if people can get a tar.gz and install it on their computer and have access to a local copy of the app! OK, so let’s sum up: we want to build an app. This app needs to have metadata and to handle dependencies correctly, which is what you get from the DESCRIPTION + NAMESPACE files of the package. Even more practical is the fact that you can do “selective namespace extraction” inside a package, i.e you can say “I want this function from this package”. Also, this app needs to be split up in smaller .R files, which is the way a package is organized. And I don’t need to emphasize how documentation is a vital part of any package, so we solved this question too here. So is the testing toolkit. And of course, the “install everywhere” wish comes to life when a Shiny App is in a package. 3.1.2 The other plus side of Shiny as a Package 3.1.2.1 Testing Nothing should go to production without being tested. Nothing. Testing production apps is a wide question, and I’ll just stick to tests inside a Package here. Frameworks for package testing are robust and widely documented. So you don’t have to put any extra-effort here: just use a canonical testing framework like {testthat}. Learning how to use it is not the subject of this chapter, so feel free to refer to the documentation. See also Chapter 5 of “Building a package that lasts”. What should you test? First of all, as we’ve said before, the app should be split between the UI part and the back-end (or ‘business logic’) part. These back-end functions are supposed to run without any interactive context, just as plain old functions. So for these ones, you can do classical tests. As they are back-end functions (so specific to a project), {golem} can’t provide any helpers for that. For the UI part, remember that any UI function is designed to render an HTML element. So you can save a file as HTML, and then compare it to a UI object with the golem::expect_html_equal(). library(shiny) ui &lt;- tagList(h1(&quot;Hello world!&quot;)) htmltools::save_html(ui, &quot;ui.html&quot;) golem::expect_html_equal(ui, &quot;ui.html&quot;) # Changes ui &lt;- tagList(h2(&quot;Hello world!&quot;)) golem::expect_html_equal(ui, &quot;ui.html&quot;) This can for example be useful if you need to test a module. A UI module function returns an HTML tag list, so once your modules are set you can save them and use them inside tests. my_mod_ui &lt;- function(id){ ns &lt;- NS(&quot;id&quot;) tagList( selectInput(ns(&quot;this&quot;), &quot;that&quot;, choices = LETTERS[1:4]) ) } my_mod_ui_test &lt;- tempfile(fileext = &quot;html&quot;) htmltools::save_html(my_mod_ui(&quot;test&quot;), my_mod_ui_test) # Some time later, and of course saved in the test folder, # not as a temp file golem::expect_html_equal(my_mod_ui(&quot;test&quot;), my_mod_ui_test) {golem} also provides two functions, expect_shinytag() and expect_shinytaglist(), that test if an object is of class &quot;shiny.tag&quot; or &quot;shiny.tag.list&quot;. Testing package launch: when launching golem::use_recommended_tests(), you’ll find a test built on top of {processx} that allows to check if the application is launch-able. Here’s a short description of what happens: # Standard testthat things context(&quot;launch&quot;) library(processx) testthat::test_that( &quot;app launches&quot;,{ # We&#39;re creating a new process that runs the app x &lt;- process$new( &quot;R&quot;, c( &quot;-e&quot;, # As we are in the tests/testthat dir, we&#39;re moving # two steps back before launching the whole package # and we try to launch the app &quot;setwd(&#39;../../&#39;); pkgload::load_all();run_app()&quot; ) ) # We leave some time for the app to launch # Configure this according to your need Sys.sleep(5) # We check that the app is alive expect_true(x$is_alive()) # We kill it x$kill() } ) Note: this specific configuration will possibly fail on Continuous integration platform as Gitlab CI or Travis. A workaround is to, inside your CI yml, first install the package with remotes::install_local(), and then replace the setwd (...) run_app() command with myuberapp::run_app(). For example: in .gitlab-ci.yml: test: stage: test script: - echo &quot;Running tests&quot; - R -e &#39;remotes::install_local()&#39; - R -e &#39;devtools::check()&#39; in test-golem.R: testthat::test_that( &quot;app launches&quot;,{ x &lt;- process$new( &quot;R&quot;, c( &quot;-e&quot;, &quot;datuberapp::run_app()&quot; ) ) Sys.sleep(5) expect_true(x$is_alive()) x$kill() } ) 3.1.2.2 Documenting Documenting packages is a natural thing for any R developer. Any exported function should have its own documentation, hence you are “forced” to document any user facing-function. Also, building a Shiny App as a package allows you to write standard R documentation: A README at the root of your package Vignettes that explain how to use your app A {pkgdown} that can be used as an external link for your application. 3.1.3 Deploy 3.1.3.1 Local deployment As your Shiny App is a standard package, it can be built as a tar.gz, sent to your colleagues, friends, and family, and even to the CRAN. It can also be installed in any R-package repository. Then, if you’ve built your app with {golem}, you’ll just have to do: library(myuberapp) run_app() to launch your app. 3.1.3.2 RStudio Connect &amp; Shiny Server Both these platforms expect a file app configuration, i.e an app.R file or ui.R / server.R files. So how can we integrate this “Shiny App as Package” into Connect or Shiny Server? Using an internal package manager like RStudio Package Manager, where the package app is installed, and then you simply have to create an app.R with the small piece of code from the section just before. Uploading the package folder to the server. In that scenario, you use the package folder as the app package, and upload the whole thing. Then, write an app.R that does: pkgload::load_all() shiny::shinyApp(ui = app_ui(), server = app_server) And of course, don’t forget to add this file in the .Rbuildignore! This is the file you’ll get if you run golem::add_rconnect_file(). 3.1.3.3 Docker containers In order to dockerize your app, simply install the package as any other package, and use as a CMD R -e 'options(&quot;shiny.port&quot;=80,shiny.host=&quot;0.0.0.0&quot;);myuberapp::run_app()'. Of course changing the port to the one you need. You’ll get the Dockerfile you need with golem::add_dockerfile(). 3.1.4 Resources R packages “Building a package that lasts” Writing R Extensions R package primer - a minimal tutorial 3.2 Using Shiny Modules 3.2.1 Small is beautiful Modules are one of the most powerful tool for building Shiny Application. But what are they? Shiny modules address the namespacing problem in Shiny UI and server logic, adding a level of abstraction beyond functions .right{ text-align: right;} Modularizing Shiny app code Let’s first untangle this quote with a simple example about what is shiny namespace problem. 3.2.1.1 One million “Validate” buttons Shiny needs its outputs and inputs to have a unique id. And unfortunately, we can’t bypass that: when you send a plot from R to the browser, i.e from the server to the ui, the browser needs to know exactly where to put this element. This “exactly where” is handled through the use of an id. Ids are not a Shiny specific concept: they are at the very root of the way web pages work. Understanding all of this is not the purpose of this chapter: just remember that Shiny inputs and outputs ids have to be unique, so that the browser knows where to put what it receives from R, and R knows what to listen to from the browser. The need to be unique is made a little bit complex by the way Shiny handles the names, as it share a global pool for all the id names, with no native way to use namespaces. Namespaces are a computer science concept which has been designed to handle a common issue: how to share the same name for a variable in various place of your program without them conflicting. In other words, how to use an object called foo several times in the program, and still be sure that it’s correctly used depending on the context. R itself has a system for namespaces ; that’s what packages do and why you can have purrr::flatten and jsonlite::flatten: the function name is the same, but the two live in different namespaces, and they can mean two different things, as the symbol is evaluated inside two different namespaces. If you want to learn more about namespaces, please refer to the 7.4 Special environments chapter from Advanced R. So, that’s what modules are made for: creating small namespaces where you can safely define ids without conflicting with other ids in the app. Why do we need to do that? Think about the number of times you’ve created a “OK” or “validate” button. How do you handle that? By creating validate1, validate2, and so on and so forth. And if you think about it, you’re mimicking a namespacing process: a validate in namespace 1, another in namespace 2. Consider this piece of code: library(shiny) ui &lt;- function(request){ fluidPage( sliderInput(&quot;choice1&quot;, &quot;choice 1&quot;, 1, 10, 5), actionButton(&quot;validate1&quot;, &quot;Validate choice 1&quot;), sliderInput(&quot;choice2&quot;, &quot;choice 2&quot;, 1, 10, 5), actionButton(&quot;validate2&quot;, &quot;Validate choice 2&quot;) ) } server &lt;- function( input, output, session ){ observeEvent( input$validate1 , { print(input$choice1) }) observeEvent( input$validate2 , { print(input$choice2) }) } shinyApp(ui, server) This, of course, is an approach that works. Well, it works as long as your code base is small. But how can you be sure that you’re not creating validate6 on line 55 and another on line 837? How can you be make sure that you’re deleting the correct combination of UI/server components if they are named that way? Also, how do you work smoothly in a context where you have to scroll from sliderInput(&quot;choice1&quot; to observeEvent( input$choice1 , { which might be separated by thousands of lines? 3.2.1.2 A bite-sized code base And of course, you know the saying that “if you copy and paste something more than twice, you should make a function”, so how do we refactor this piece of code so that it’s reusable? Yes, you guessed right: using shiny modules. Shiny modules aim at three things: simplifying id namespacing, split the code base into a series of functions, and allow UI/Server parts of your app to be reused. Most of the time, modules are used to do the two first: I’d say that 90% of the module I write are never reused13 ; they are here to allow me to split the code base into smaller, more manageable pieces. With Shiny modules, you’ll be writing a combination of UI and server functions. Think of them as small, standalone Shiny apps, which output and handle a fraction of your global application. If you’ve been developing R packages, you’d probably trying to split your functions into series of smaller functions, that’s the exact same thing: you are, with just a little bit of tweaking, doing the same thing. That is to say creating smaller functions that are easier to understand, develop and maintain. 3.2.2 A practical walk through 3.2.2.1 Your first Shiny Module So, here is how you’d refactor the example from before with modules: name_ui &lt;- function(id){ ns &lt;- NS(id) tagList( sliderInput(ns(&quot;choice&quot;), &quot;Choice&quot;, 1, 10, 5), actionButton(ns(&quot;validate&quot;), &quot;Validate Choice&quot;) ) } name_server &lt;- function(input, output, session){ ns &lt;- session$ns observeEvent( input$validate , { print(input$choice) }) } library(shiny) ui &lt;- function(request){ fluidPage( name_ui(&quot;name_ui_1&quot;), name_ui(&quot;name_ui_2&quot;) ) } server &lt;- function( input, output, session ){ callModule(name_server, &quot;name_ui_1&quot;) callModule(name_server, &quot;name_ui_2&quot;) } shinyApp(ui, server) Let’s stop for a minute and decompose what we’ve got here. The server function is pretty much the same as before: you’ll just be using the same code as the one you’ve been using so far. The ui function has some new things in it. Well, two new things, which are ns &lt;- NS(id) and ns(inputId). That’s where the namespacing happens. You can think about this function as a way to add a namespace to your id: you’ve been doing validate1 and validate2 before, now you’re doing this with the function created by ns &lt;- NS(id). You’ll find this little piece of code on top of all the module ui functions. To understand what it does, let’s try and run it outside of Shiny: id &lt;- &quot;name_ui_1&quot; ns &lt;- NS(id) ns(&quot;choice&quot;) [1] &quot;name_ui_1-choice&quot; And here it is, our namespaced id! And of course, calling it with various id will create various namespaces for the id, preventing you from id conflicts14. All you have to do now is to make sure that ids are unique at the “upper” levels. Then you can have as many validate input as you want in your app: as long as this validate is unique inside your module you’re good to go. The app_ui contains a series of call to module_ui_function(unique_id, ...) with potential parameters: name_ui &lt;- function(id, butname){ ns &lt;- NS(id) tagList( actionButton(ns(&quot;validate&quot;), butname) ) } name_ui(&quot;name_ui_1&quot;, &quot;Validate Choice&quot;) name_ui(&quot;name_ui_2&quot;, &quot;Validate Choice, again&quot;) &lt;button id=&quot;name_ui_1-validate&quot; type=&quot;button&quot; class=&quot;btn btn-default action-button&quot;&gt;Validate Choice&lt;/button&gt; &lt;button id=&quot;name_ui_2-validate&quot; type=&quot;button&quot; class=&quot;btn btn-default action-button&quot;&gt;Validate Choice, again&lt;/button&gt; The app_server side contains a series of callModule(module_server_function, unique_id, ...), with potential parameters. 3.2.2.2 Passing args to your modules Shiny modules will potentially be reused. It’s not the general pattern, but they can. In that case, you’ll potentially be using extra arguments to generate the UI and server conditionally. Let’s for example have a look at mod_dataviz.R from the {tidytuesday201942} Shiny application. This application contains 6 tabs, 4 of them being pretty much alike: a side bar with inputs, an a main panel with a button and the plot. This is a typical case where you should reuse modules: if two or more parts are relatively similar, it’s easier to bundle it inside a reusable module, and condition the ui/server with function arguments. Here, are some examples of how it works in the UI: mod_dataviz_ui &lt;- function(id, type = c(&quot;point&quot;, &quot;hist&quot;, &quot;boxplot&quot;, &quot;bar&quot;)){ h4( sprintf( &quot;Create a geom_%s&quot;, type ) ), if (type == &quot;boxplot&quot; | type ==&quot;bar&quot;) { selectInput( ns(&quot;x&quot;), &quot;x&quot;, choices = names_that_are(c(&quot;logical&quot;, &quot;character&quot;)) ) } else { selectInput( ns(&quot;x&quot;), &quot;x&quot;, choices = names_that_are(&quot;numeric&quot;) ) } } And in the server: mod_dataviz_server &lt;- function(input, output, session, type){ if (type == &quot;point&quot;){ x &lt;- rlang::sym(input$x) y &lt;- rlang::sym(input$y) color &lt;- rlang::sym(input$color) r$plot &lt;- ggplot( big_epa_cars, aes(!!x, !!y, color = !!color) ) + geom_point() + scale_color_manual( values = color_values( 1:length(unique(pull(big_epa_cars, !!color))), palette = input$palette ) ) } } Then, the app server is: app_server &lt;- function(input, output,session) { #callModule(mod_raw_server, &quot;raw_ui_1&quot;) callModule(mod_dataviz_server, &quot;dataviz_ui_1&quot;, type = &quot;point&quot;) callModule(mod_dataviz_server, &quot;dataviz_ui_2&quot;, type = &quot;hist&quot;) callModule(mod_dataviz_server, &quot;dataviz_ui_3&quot;, type = &quot;boxplot&quot;) callModule(mod_dataviz_server, &quot;dataviz_ui_4&quot;, type = &quot;bar&quot;) } And the UI: app_ui &lt;- function() { # [...] tagList( fluidRow( id = &quot;geom_point&quot;, mod_dataviz_ui(&quot;dataviz_ui_1&quot;, &quot;point&quot;) ), fluidRow( id = &quot;geom_hist&quot;, mod_dataviz_ui(&quot;dataviz_ui_2&quot;, &quot;hist&quot;) ) ) } 3.2.3 Communication between modules One of the hardest part about modules is sharing data across them. There are at least two approaches: returning reactive, or the “stratégie du petit r” (to be pronounced with a french accent). 3.2.3.1 Returning values from the module One common approach is return a reactive from one module, and to pass it to another. name_ui &lt;- function(id){ ns &lt;- NS(id) tagList( sliderInput(ns(&quot;choice&quot;), &quot;Choice&quot;, 1, 10, 5) ) } name_server &lt;- function(input, output, session){ ns &lt;- session$ns return( reactive({ input$choice }) ) } name_b_ui &lt;- function(id){ ns &lt;- NS(id) tagList( actionButton(ns(&quot;validate&quot;), &quot;Print&quot;) ) } name_b_server &lt;- function(input, output, session, react){ ns &lt;- session$ns observeEvent( input$validate , { print(react()) }) } library(shiny) ui &lt;- function(request){ fluidPage( name_ui(&quot;name_ui_1&quot;), name_b_ui(&quot;name_ui_2&quot;) ) } server &lt;- function( input, output, session ){ res &lt;- callModule(name_server, &quot;name_ui_1&quot;) callModule(name_b_server, &quot;name_ui_2&quot;, react = res) } shinyApp(ui, server) That works well, but for large Shiny Apps it might be hard to handle large list of reactive outputs / inputs. It might also create some reactivity issues, as they are harder to control. 3.2.3.2 The “stratégie du petit r” With this strategy, instead of passing reactives as function input, we’ll be creating a global reactive list which is passed along other modules. The idea is that it allows us to be less preoccupied about what your module takes as input. Here, we will be creating a “global” reactiveValues() that we will pass downstream. name_ui &lt;- function(id){ ns &lt;- NS(id) tagList( sliderInput(ns(&quot;choice&quot;), &quot;Choice&quot;, 1, 10, 5) ) } name_server &lt;- function(input, output, session, r){ ns &lt;- session$ns observeEvent( input$choice , { r$choice &lt;- input$choice }) } name_b_ui &lt;- function(id){ ns &lt;- NS(id) tagList( actionButton(ns(&quot;validate&quot;), &quot;Print&quot;) ) } name_b_server &lt;- function(input, output, session, r){ ns &lt;- session$ns observeEvent( input$validate , { print(r$choice) }) } library(shiny) ui &lt;- function(request){ fluidPage( name_ui(&quot;name_ui_1&quot;), name_b_ui(&quot;name_ui_2&quot;) ) } server &lt;- function( input, output, session ){ r &lt;- reactiveValues() callModule(name_server, &quot;name_ui_1&quot;, r) callModule(name_b_server, &quot;name_ui_2&quot;, r) } shinyApp(ui, server) The plus side of this method is that whenever you’re add something in one module, it’s immediately available in the other modules. The down side is that it can be harder to reason about the app, as the input / content of the r is not specified anywhere: as you don’t pass any arguments to your function other than r, you don’t really know what’s inside. Also, not that if you want to share your module, for example in a package, you should document the structure of the r. For example: #&#39; @param r a `reactiveValues()` with a `choice` element in it. This `r$choice` will be printed to the R console. 3.2.3.3 A third way There is another way to share data across modules, which is creating an R6 object which is then pass along the modules. In the spirit, it’s more or less the same as passing the r list, except that it is not a reactive object, making it more robust to the complexity of handling reactivity invalidation across modules. This methods is explain in the chapter Reactivity anti-patterns of this book. 3.2.3.4 When should you modularize? From the very beginning. The overhead of writing a module compared to putting everything inside the app function is relatively low: it’s even simpler if you are working in a framework like {golem}, which promotes the use of modules from the very beginning of your application. &quot;Yes but I just want to write a small app, nothing fancy Production apps almost always started as a small POC. Then the small POC becomes an interesting idea. Then this idea becomes a strategical asset. And before you know it your ‘not-that-fancy’ app needs to become larger 3.3 Structuring your app 3.3.1 Business logic &amp; application logic If you think of the how your application is composed, there are two main things that make it run: Application logic, which are the things that make your Shiny app interactive: structure, buttons, table, interactivity, etc. These application logic is not specific to your core business: you could use it for any other line of work. Most of the time, these functions have no other use case than your interactive application: they are not meant to be used outside your app, and could work in a lot of other professional context. Business logic, which are the core algorithms and functions that make your application specific to your area of work. You can recognize these as they can be run outside any interactive context. For example, if you’ve been making specific computation and algorithm, if you have a custom plot or geom for {ggplot2}, if your doing specific calls to a database, etc. These two families of functions do not have to live together, and they shouldn’t if you want to keep your sanity when you’ll be building an app—you’ll end up having to rerun the app from scratch and spend 3 minutes clicking everywhere just to be sure you’ve correctly set the color palette for the graph on the last tabPanel(). Trust us, we’ve been there, and it’s not pretty. So what’s the way to go? Extract the business function from the reactive functions. Literally. Compare this pattern: library(shiny) library(dplyr) ui &lt;- function(request){ tagList( tableOutput(&quot;tbl&quot;) ) } server &lt;- function( input, output, session ){ output$tbl &lt;- renderTable({ mtcars %&gt;% # [...] %&gt;% # [...] %&gt;% # [...] %&gt;% # [...] %&gt;% # [...] %&gt;% top_n(10) }) } shinyApp(ui, server) To this one: library(shiny) library(dplyr) top_this &lt;- function(tbl){ tbl %&gt;% # [...] %&gt;% # [...] %&gt;% # [...] %&gt;% # [...] %&gt;% top_n(10) } ui &lt;- function(request){ tagList( tableOutput(&quot;tbl&quot;) ) } server &lt;- function( input, output, session ){ output$tbl &lt;- renderTable({ top_this(mtcars) }) } shinyApp(ui, server) They both do the exact same thing. The difference being that the first can be easily explored without having to relaunch the app. It also can be tested, documented, and reused outside the app. And the other benefit you’ll get from that approach is that it lower the cognitive load when debugging: you are either debugging an application issue, or a business logic issue, but never debugging both of them at the same time. So put them in a separate file, so that you’ll be able to work and test them without having to relaunch your whole app for the 300th time of the day. And if you want to be even more strict about this, you can write a package for these functions, so that they are neatly separated from the package containing the Shiny application. 3.3.2 Small is beautiful (bis repetita) There is nothing harder to maintain than a Shiny app which is only made of one 1000 lines long app.R. Well, there still is the 10 000 lines long app.R, but you’ve got the idea. Long scripts are almost always synonym of complexity when it comes to building an application. Of course, small and numerous scripts don’t systematically prevent from codebase complexity but they simplify collaboration and maintenance, and of course divide the application logic into smaller, easier to understand bits of code. So yes, big files are complex to handle and make development harder. Indeed, here is what happens when you’re working on a production application: You’ll be working during a long period of time (either in one run or split across several months) on your codebase, meaning that you’ll have to get back to pieces of code you have written a long time ago. You’ll possibly be developing with others. Maintaining a code base when several persons are working on the files is already a complex thing: from time to time you might be working on the same file separately, a situation where you’ll have to be careful about what and how you merge things when changes are implemented. Of course, it’s almost impossible to work on one same file all along the project without losing your mind: even more if this file is thousands of lines long. You’ll be implementing numerous features. Numerous features imply a lot of UI &amp; server interaction. And in an app.R file of thousands of line, it’s very hard to match the UI element with its server counterpart: when the UI is on line 50 and the server on line 570, you’ll be scrolling a lot when working on that element. So yes, there are a lot of reasons for splitting your application into smaller pieces: it’s easier to maintain, easier to decipher, and of course it facilitates collaboration. 3.3.3 Conventions matter So, now that we’ve talk about the benefits of splitting files, let’s think about how to do that. Splitting files is good, splitting files using a defined convention is better. Why? Because using a common convention for your files helps the other developers (and potentially you) to know exactly what is contained in a specific file, and that way it helps everybody know where to look for debugging / implementing new features. For example, if you follow {golem}’s convention, you’ll know that a file starting with mod_ contains a module, so if I take over a project, look in the R/ folder and see files starting with these three letters, I’ll know immediately what these files contain. That’s what we’ll see in this part: a proposition for a convention on how to split your application into smaller pieces. First of all, put everything into an R/ folder. If you’re building your app using the {golem} framework, this is already what you’re doing: using this package convention to hold the functions for your application. Once you’ve got this, here is the {golem}-specific convention for organizing your files: app_*.R (typically app_ui.R and app_server.R) should contain the top level functions which are used to defined your user interface and your server function. fct_* are files that contains business logic, potentially large functions. They are the backbone of the app but are potentially not specific to a given module. They can be added in {golem} with the add_fct(&quot;name&quot;) function. mod_* are files that contain ONE module. As many shiny apps contains a series of tabs, or at least a tab-like pattern, we suggest that you number then according to their step in the application. And as tabs are almost always named, you can use the tab-name as the file name. For example, if you’re building a dashboard and the first tab is called “Import”, your should name your file mod_01_import.R, which you can create with golem::add_module(&quot;01_import&quot;). Note that when building a module file with {golem}, you can add a fct_ and utils_ specific file, that will hold functions and utilities for this specific modules. For example, golem::add_module(&quot;01_import&quot;, fct = &quot;readr&quot;, utils = &quot;ui&quot;) will create R/mod_01_import.R, R/mod_01_import_fct_readr.R and R/mod_01_import_utils_ui.R. utils_* are files that contain utilities, which are small helper functions. For example, you might want to have a not_na, which is not_na &lt;- Negate(is.na), a not_null, or small tools that you’ll be using application-wide. Note that you can also create utils for a specific module. *_ui_*, for example utils_ui.R, relates to the user interface. Anything back-end can be noted using *_server_*, for example fct_connection_server.R will contain functions that are related to the connection to a database, and which are specifically used from the server side. Of course, as with any convention, you might be deviating from time to time from this pattern. Your app may not have that many functions, or maybe the functions can all fit into one utils_ file. But be it one or thousands of file, it’s always a good practice to stick to a formalized pattern. "],
["golem.html", "Chapter 4 Introduction to {golem} 4.1 Getting started with {golem} 4.2 Understanding {golem} app structure", " Chapter 4 Introduction to {golem} OK, that’s a lot of things to process. Is there a tool that can help us simplify this workflow? Of course there is, and it’s called {golem}, a framework for building production-grade Shiny Application. 4.1 Getting started with {golem} {golem} is an R package that can be thought as a toolkit for simplifying the creation, development and deployment of Shiny applications. A lot of things in this book reflect the way {golem} and the packages from the “golem-verse” are designed. We advice to use {golem} if you plan on following the workflow described in this book, but of course the workflow will still be valid of you plan on not using {golem}. The stable release can be found on CRAN, and installed with: install.packages(&quot;golem&quot;) {golem} dev version can be found on GitHub and you’ll have to install it with: remotes::install_github(&quot;Thinkr-open/golem&quot;) The current version of the package on CRAN is: library(dplyr, warn.conflicts = FALSE) tools::CRAN_package_db() %&gt;% filter(Package == &quot;golem&quot;) %&gt;% select(Version) Version 1 0.1 While the current version of the dev version is: x &lt;- tempfile() download.file(&quot;https://raw.githubusercontent.com/ThinkR-open/golem/dev/DESCRIPTION&quot;, x) desc::desc_get_version(x) [1] &#39;0.1.0.9700&#39; {golem} is an R package that implements an opinionated framework for building production-ready Shiny apps. The motivation behind {golem} is that building a proof-of-concept application is easy, but things change when the application becomes larger and more complex, and especially when it comes to sending that app to production. And until recently there hasn’t been any real framework for building and deploying production-grade Shiny Apps. This is where {golem} comes into play: offering Shiny developers a toolkit for making a stable, easy-to-maintain, and robust for production web application with R. {golem} has been developed to abstract away the most common engineering tasks (for example, module creation, addition of external CSS or JavaScript file, …), so you can focus on what matters: building the application. And once your application is ready to be deployed, {golem} guides you through testing, and brings you tool for deploying to common platforms. Some things to keep in mind before using {golem}: A {golem} application is contained inside a package, so knowing how to build a package is recommended but not necessary. The good news is also that everything you know about package development can be applied to {golem}. A {golem} app works better if you are working with shiny modules, so knowing how modules work is also recommended but not necessary. 4.2 Understanding {golem} app structure When starting a new project with {golem} (here on an app called golex), you’ll start with this specific architecture. fs::dir_tree(&quot;golex&quot;) golex ├── DESCRIPTION ├── NAMESPACE ├── R │ ├── app_server.R │ ├── app_ui.R │ └── run_app.R ├── dev │ ├── 01_start.R │ ├── 02_dev.R │ ├── 03_deploy.R │ └── run_dev.R ├── inst │ └── app │ └── www │ ├── favicon.ico │ └── plop.js └── man └── run_app.Rd If you are familiar with packages, this structure will look familiar to you. And that’s for a good reason: an app built with {golem} IS a package. Let’s focus on these various elements for a moment in order to be sure you understand what part each file plays and how you can use (or not use) each of them. 4.2.1 DESCRIPTION &amp; NAMESPACE The DESCRIPTION and NAMESPACE are standard package files (i.e. they are not {golem}-specific). In the first, you’ll find a series of metadata about your package, for example who wrote the package, what’s the package version, what is its goal, who to complain to if things go wrong, and also information about external dependencies, the license, the encoding…. This DESCRIPTION file will be filled automatically by the first function you’ll run in dev/01_start.R, and by other functions from the dev/ scripts. In other words, most of the time you won’t interact with it directly, but through wrappers from {golem} and {usethis}. The NAMESPACE file is one of the most important file in your package. It’s also the one you’ll NEVER edit by end! R uses this one to define how to interact with the rest of the library: what function to import and from which package and what function to export, i.e what functions are available when you do library(golex). This file will be built when running the documenting process in your R package: {roxygen2} will scan all your .R files, and build the man/ + the NAMESPACE, by scanning the roxygen tags there. Explaining how these files are to be filled and how to document your functions is out of the scope of this book, as we hope if you’re reading this lines you’re already familiar with how to build a package. If you’d like to learn more about these, here are some resources you can refer to: Writing R Extensions - The DESCRIPTION file Writing R Extensions - Package namespaces R Packages - Package metadata R Packages - Namespace Building a package that lasts — eRum 2018 workshop 4.2.2 R/ The R/ folder is also the standard folder where you’ll be putting all your app functions. When you start your app project, this folder is pre-populated with three .R: app_server.R, app_ui.R, and run_app.R. During the process of building your application, all the core functionalities of your app will go there: you’ll put there the content of your modules (with golem::add_modules()) and the utilitarian / business logic functions you’ll build with golem::add_utils() and golem::add_fct(). If you want to add a standard file (that is to say out of {golem} nomenclature), you can call usethis::use_r(&quot;name&quot;), which create a R/name.R file. All your .R file should go there, with the only exception of the files you’ll create when deploying to RStudio products: these processes needing an app.R at the root of the project, the golem::add_rstudioconnect_file() will bypass this “.R only in R/” rule to add a file at your package root. Good news is that {golem} also knows that a package with an app.R at its root can’t build, so this file is added to the .Rbuildignore. If you’ve been building classic Shiny Apps, you’ve been use to source() your R files at the beginning of your app.R or ui.R/server.R. Keep in mind that, as we are building a package, we don’t need to source files from one place to another: {golem}, be it in the dev/run_dev.R, app.R for RStudio products, or running the run_app() function, leverages the package structure to allow you to have access to other functions from inside the whole R/ folder15. Note also that this folder can’t contain sub-folders. 4.2.2.1 app_server.R #&#39; @import shiny app_server &lt;- function(input, output,session) { # List the first level callModules here } This first function contains your server logic. If you’re familiar with the classic ‘ui.R / server.R’ methodology, this function can be thought of as a drop in replacement for the content of the function you’ve got in your server.R. Building a complex Shiny application commonly implies using Shiny modules. If so, you’ll be adding there a series of callModule(), the ones you’ll get on the very bottom of the file created with golem::add_module(). You’ll also find there global elements from your server-logic: top reactiveValues, connections to databases, options setting… 4.2.2.2 app_ui.R #&#39; @import shiny app_ui &lt;- function() { tagList( # Leave this function for adding external resources golem_add_external_resources(), # List the first level UI elements here fluidPage( h1(&quot;golex&quot;) ) ) } This piece of the app_ui.R is designed to received the counterpart of what you put in your server. Everything here is to be put after the # List the first level UI elements here line. Just as with their server counterparts, the UI side of these elements are the one from the bottom of the file you’re creating with golem::add_module(). By default, {golem} uses a fluidPage(), which is {shiny}’s most commonly used template. If ever you want to use navBarPage(), this is where you’ll define this: replace one with the other, and you’ll be good to go. You can also define any other template page, for example with an htmlTemplate(). Keep in mind that removing the fluidPage() here implies that there is no available CSS / JS template to be used anymore, and you’ll need to be adding your own there. #&#39; @import shiny golem_add_external_resources &lt;- function(){ addResourcePath( &#39;www&#39;, system.file(&#39;app/www&#39;, package = &#39;golex&#39;) ) tags$head( golem::activate_js(), golem::favicon() # Add here all the external resources # If you have a custom.css in the inst/app/www # Or for example, you can add shinyalert::useShinyalert() here #tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;) ) } The second part of this file contains the golem_add_external_resources() function, which is used to add, well, external resources. You may have noticed that this function is to be found above in the file, in the app_ui() function. This function is used for linking to external files inside your applications: notably the files you’ll create with golem::add_css_file() and friends. In golem_add_external_resources(), you can also define custom resourcesPath. The first line (the one with addResourcePath()) is the one allowing the inst/app/www folder to mounted and be available at www with your app when you launch it. That’s why later on, when creating CSS or JS files, you’ll be asked to add there tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;). The other part of this function, starting with tags$head, creates a &lt;head&gt; tag for your application. This &lt;head&gt; tag is a pretty standard tag, which is used in HTML to define a series of metadata about your app. We encourage you to add any new external file (e.g pictures) in this inst/app/www folder, so that you can later use it in the UI with the common www prefix. An other common pattern would be: Adding images in inst/app/img Calling addResourcePath( 'img', system.file('app/img', package = 'golex') ) Adding elements to your UI with tags$img(src = &quot;img/name.png&quot;). 4.2.2.3 run_app.R #&#39; Run the Shiny Application #&#39; #&#39; @export #&#39; @importFrom shiny shinyApp #&#39; @importFrom golem with_golem_options run_app &lt;- function(...) { with_golem_options( app = shinyApp(ui = app_ui, server = app_server), golem_opts = list(...) ) } This run_app()function is the one that you’ll use to launch the app16. The body of this function is wrapped inside with_golem_options(), which allows you to pass arguments to the run_app() function, which will later be callable with golem::get_golem_options(). Some example of passing arguments include run_app(prod = FALSE) or something in the like of run_app(user = &quot;admin). 4.2.3 inst/app/www/ The inst/app/www/ folder contains all the files which are gonna be made available at application run time. Any web application has external files that allows it to run17. For example, {shiny} and its fluidPage() bundles a series of CSS and JavaScript files, notably the Boostrap library, or jQuery. These external files enhance your app: CSS for the design part, and JavaScript for the interactive part (more or less). On top of that, you can add your own files: your own design with CSS, or your own JavaScript content (as we’ll see in the last chapters of this book). In order to work, you have to include, somewhere in the UI, a link to these files. That’s what the links in the golem_add_external_resources() are made for: linking the external resources that you’ll build with the following functions. golem::add_css_file() golem::add_js_file() golem::add_js_handler() golem::use_favicon() Be aware that these files are available under the www/ at application run time, i.e. that the www/ folder is available by your browser, not by R when it runs / generate your application. In other words, you can use the www prefix in the HTML generated in your UI, which is read by your browser, not from the R/server side. If you want to link to a file that is read during application generation, you’ll need to do, for example, includeMarkdown( system.file(&quot;app/www/plop.md&quot;, package = &quot;golex&quot;) ). 4.2.4 man/ This man/ folder includes the package documentation. It’s a common folder that is automatically filled when you document your app: notably when running the dev/run_dev.R script and the document_and_reload() function. As with the NAMESPACE and DESCRIPTION, these two files are out of scope of this book (and to be honest, you’ll probably never have to interact with them directly). To know more about documentation and how to build it, here are some external links: R Packages - Object documentation Building a package that lasts — eRum 2018 workshop "],
["workflow.html", "Chapter 5 The workflow 5.1 Part 1: Design 5.2 Part 2: Prototype 5.3 Part 3: Build 5.4 Part 4: Secure 5.5 Part 5: Deploy", " Chapter 5 The workflow The recommended workflow for building successful Shiny Apps happens in five parts: Design, Prototype, Build, Secure and Deploy. 5.1 Part 1: Design The Design part is the time when you think about how you will conceive the application, before actually writing any line of code. It’s not Shiny nor R specific: it’s something software engineers have been doing for any software or web application: discuss with the clients, the end-users, and the developers that will work on the project. In this first part, you’ll discover some tools that will help you define how the application will be build, that is to say somewhere between users’ dreams, what’s technically possible, and the time you’ve got for building it. 5.2 Part 2: Prototype The Prototype step is the one during which you’ll be building the front-end and the back-end, but separately. As you may know, a Shiny application is an interface used to communicate information to the end-users. The general appearance, position of the inputs and outputs as well as graphical interactions need to be chosen with care. On the other hand, the back-end should be built carefully: people will potentially make decision based on what they learn from your app. That’s why you should take extra care building the UI, but also building the back-end. In this part, we will be talking about two processes: A ‘UI-first’ approach, with tools to build the skeleton of the application before engineering its core. A ‘Rmd-first’ approach, which focuses on the actual computation of the outputs. The idea here is to prototype the outputs outside of the application reactivity. This ‘Rmd first’ method is designed to help you focus on the core of the application outside of any reactive context, and also to develop functions and write the documentation with visual outputs and example data. Here, we are building the two sides of the app separately: the core back-end can be outputted to HTML documents that can be sent and validated by the clients, and the front-end can be tested without actual implementation of the back-end. 5.3 Part 3: Build The Build step is the one where you’ll be working on combining the business (or back-end) logic with the front-end. In this step 3, you’ll be working on the core engine of the application. If you’re planning on building a robust Shiny application, you’ll have to start using the correct development tools. In this part, you’ll see how you can upgrade your development workflow using {golem}, a package which has been created to help you design a robust and maintainable Shiny application. 5.4 Part 4: Secure Securing your app is ensuring your application will last forever. This might seem like a hard task, but some good practices will help you all along life-cycle of the app. In this part, we will go through unit tests, reproducible development environment, version control and continuous integration in the context of Shiny applications. 5.5 Part 5: Deploy To Deploy is to send your application to production. Being exhaustive here is an impossible task as there are numerous ways to make your application accessible to its targeted users. But we’ll try to provide some! In this part, we will quickly present a series of methods to deploy your application on various environments, and show how you can use {golem} to make this task easier. "],
["matters.html", "Chapter 6 UX Matters 6.1 Simplicity is Gold 6.2 The danger of feature-creep 6.3 Web Accessibility Title", " Chapter 6 UX Matters We have a natural tendency, as R-coders, to be focused on the back-end, i.e the server part of the application18. Which is perfectly normal—chances are you didn’t come to R to design front-ends.19 But let’s state the truth: no matter how complex and innovative your backend is, your application is bad if your User Experience (UX) is bad. That’s the hard truth. If people can’t understand how to use your application, your application isn’t successful, no matter how incredible the backend is. This natural taste for back-end / server logic can deserve you on the long run: by neglecting the UI and the UX, you’ll make your application less likely to be adopted among your users. Which is a good way to fail your application project. 6.1 Simplicity is Gold “Simplify, then add lightness” Colin Chapman CBE, Founder of Lotus Cars There are mainly two contexts where you’ll be building a web app with R: one for professional use (i.e people will rely on this app to do their job), or for fun (i.e people will just use the app as a distraction). But in both cases, people will want the app to be usable, and easily usable. If people use your app in a professional context, they don’t want to fight with your interface, read complex manuals, or lose time understanding what they are supposed to do and how they are supposed to use your application. In other words, they want an efficient tool: something that, beyond being accurate, is easy to grasp. In a professional context, when it comes to “Business applications”, remember that the easier the learning curve the better the user experience. Think about all the professional applications and softwares that you’ve been ranting about during your professional life, all these cranky user interfaces you haven’t understand and/or you need to relearn every time you use them. You don’t want your app to be one of these applications. And on the other end, if users open your app for fun, they are not going to fight your app into submission: they are just going to give up if it’s too complex to be used. Even a game has to appear easy to use when the users open it. Aiming for simplicity is a hard thing, but following some rules will help you start on a solid ground. In this section, we’ll review two general principals: the “don’t make me think” principle, which states that interfaces should be as self-explanatory as possible, and the “Rule of least surprise”, stating that elements should behave the way they are commonly expected to behave. These two rules aim at solving one issue: the bigger the cognitive load of your app is, the harder it will be for the end-user to use your app on a daily basis. And of course, the less a success your project will be. 6.1.1 How we read the web: scanning content One big lie we tell ourselves as developer is that end-user will use the app the way we designed it to be used. We love to think that when faced to our app, the users will carefully read the instructions, make a rational decision based on careful examination of the inputs, before doing what we expect them to do. But the harsh truth is that it’s not how what happens. First of all, user rarely read carefully all the instructions: they scan, and perform the first action that more or less match what they need to do, i.e the satisfice. FROM ‘Don’t make me think’, Steve Krug For example, let’s have a look at the user interface of hexmake, a Shiny app for building hex stickers, available at https://connect.thinkr.fr/hexmake/ What will be your reading pattern for this application? What is the first thing you’ll do when using this app? There is an inherent logic in the application: each submenu is designed to handle one specific part of your sticker. The last-but-one menu is the one used to download the sticker, and the last one the menu to open the “how to” of the app. When opening this app, will your fist move be to open the how to? Will you open all the sub-menu and select the most “logical” one to start with? Chances are that reading this line, you think you’ll do that. But in reality, we behave less rationally that we’d like to think. What we most of the time do is click on the first thing that matches what we are here to do. For example, most of the time we will first change the package name, or upload an image, before even opening the about section of this app. Once user have scanned the page, they perform the first action that seems reasonable. Or as coined in “Rational Choice and the Structure of the Environment” by Herbert A. Simon, &quot; organisms adapt well enough to “satisfice”; they do not, in general, “optimize.”“. In other words, ”As soon as we find a link that seems like it might lead to what we’re looking for, there’s a very good chance that we’ll click it&quot; (’Don’t make me think’, Steve Krug). What that also means is that user might perform what you’d expect to be “irrational” choices. As they are scanning your webpage, they might do something unexpected, or use a part of your app in a way that you wouldn’t expect it to be used. For example, if you are creating an app that is designed to take as input data that comes under a specific form, you need to check that this requirement is fulfill, or you’ll end up debugging errors on uncommon datasets. This is a pretty common thing about apps and about software in general: you have to expect users to use your product in ways you wouldn’t have expect, in way that might seem absurd to you. For example, consider this small app: library(shiny) ui &lt;- function(request){ tagList( selectInput( &quot;species&quot;, &quot;Choose one or more species&quot;, choices = unique(iris$Species), multiple = TRUE, selected = unique(iris$Species)[1] ), plotOutput(&quot;plt&quot;) ) } server &lt;- function( input, output, session ){ output$plt &lt;- renderPlot({ plot( iris[ iris$Species %in% input$species, ] ) }) } shinyApp(ui, server) What’s wrong with this app? Probably nothing from a developer point of view: there’s a label expliciting that one should select one or more element from the dropdown, and then something is plotted. Pretty standard. But what happen if the dropdown is empty? Our first conception would be that this would never happen, as it’s explicitly specified that there should be one or more elements selected. In fact, chances are that even with this label, users will eventually end up with an empty selectInput, leading to the printing of an error where the plot should be. What should we do? Adopt a defensive programming mindset. Every time you create interactive elements, inputs and outputs, or things the user might interact with, ask yourself: “what if [that crazy thing] happens? How do I handle the case where the minimal viable requirements for my app are not met?”. And in fact, you shouldn’t be focusing on that only for the user side: the backed should also be examined for potential unexpected behavior. For example, if your Shiny app relies on a database connection, you should check gracefully that the connection is possible, and if it’s not, send a message to your user that the database is not reachable, and that they should either restart the app or come back in a few minutes. In fact, this is a crucial thing when it comes to making your app successful: you should always fail gracefully and informatively. That means that when your R code fails, the whole app shouldn’t fail. If the R code fails for some reason, the user should get back either nothing or an informative bug message, not be faced with a grey page over the application. Because of the way Shiny is designed, a lot of R errors will make the Shiny app fail completely. If you haven’t think about this upfront, that means that a user might use the app for say 10 minutes, do a series of specifications, enter parameters and data, and at some point the app completely crashes. Then the user has to restart from scratches, because there is no native way, from there, to restart from where the app has crashed. This is a very important thing to keep in mind when building Shiny app: once the app has failed, there is no easy way to get it back to the moment just before it crashed, meaning that your users might lose a significant amount of time they have spent configuring the app. 6.1.2 A self-evident app (or at least self-explanatory) One of the goal of a usable app is to make it self-evident, and fall back to a self explanatory app if the first option is too complex a goal. What’s the difference between the two? self-evident : “Not needing to be demonstrated or explained; obvious.” lexico.com self-explanatory : “Easily understood; not needing explanation.” https://www.lexico.com/en/definition/self_explanatory So the first is that the app is designed in such a way that there is no learning curve to using it. A self-explanatory app has a small learning curve, but it’s designed in a way that will make the user understand it in a matter of seconds. Let’s for example get back to our {tidytuesday201942} application available at connect.thinkr.fr/tidytuesday201942 By itself, this application is not self-evident: you need to have a series of background knowledge before understanding what this application was designed for. For example, you might need to have a vague sense of what tidytuesday is. If you don’t, you’ll have to read the home text, which will help you understand what this is. Then, if we have a look at the menu, we see that these are a series of functions from {ggplot2}: without any background about the package, you might find it difficult understanding what this app actually does. Yet, if you want to understand what this app is designed for, you’ll find enough information either on the home page or in the About section, with external links if needed. And of course, when building apps, context matters. The {tidytuesday201942} app is one that has been developed in the context of tidytuesday, an online weekly event for learning data analysis, mainly through the use of {tidyverse} packages. So there is a good chance visitors of the app will already know what is {ggplot2} when visiting the app. 6.1.2.1 The “Rule of Least Surprise” Also know as “Principle of Least Astonishment.” Rule of Least Surprise: In interface design, always do the least surprising thing. .right{ text-align: right;} 'Basic of the Unix Philosophy', Eric Steven Raymond When we are browsing the web, we have a series of pre-conception about what things are and what they do. For example, we expect an underline text to be clickable: so there’s a good chance that if you use underline text inside your app, the user will try to click on it. Usually, the link is also colored differently from the rest of the text. Same goes for the pointer of the mouse, which usually switch from an arrow to a small hand with a finger up. A lot of other conventions exist on the web, and you should endeavor to follow them: a clickable link should have at least one of the properties we just described—and if it’s neither underlined nor colored nor changing the pointer when it’s hovered, chances are that the user won’t click on it. Just imagine for a second if our “Download” button in the {tidytuesday201942} app didn’t actually download the graph you had generated. Even more, imagine if this button didn’t download the graph but something else. How would you feel about this experience? And it’s not just about links: almost every visual elements on a web page is surrounded by conventions. Buttons should have borders. Links should appear clickable. Bigger texts are headers. Elements “visually nested” are related. Etc. Weirdly enough, that’s an easy thing to spot when we arrive on a webpage / an app: it can either feel “natural”, or you can immediately see that something is off. The hard thing is that it’s something you spot when you are a new-comer: developing the app makes us so familiar with the app that we might miss when something is not used the way it’s conventionally used20. Let’s exemplify this with the “Render” button from the {tidytuesday201942} application. This app is built on top of Bootstrap 4, which has no CSS class for {shiny} action button21. Result: without any further CSS, the buttons don’t come out as buttons, making it harder to decipher they are actually buttons. Compare this native design: To the one with a little bit of CSS (which is the one online): Yes, it’s subtle, yet the second version of the button is clearer to understand. Least surprise is crucial to make the user experience a good one: users rarely think that if something is behaving unexpectedly on an app it’s because of the app—they’ll usually think it’s their fault. When users are astonished they usually assume that they have made a mistake; they are unlikely to realize that the page has astonished them. They are more likely to feel that they are at fault for not anticipating the page. Don’t take advantage of this; making users feel stupid is not endearing. .right{ text-align: right;} The cranky user: The Principle of Least Astonishment 6.1.2.2 Think about the progression If there is a progression in your app, you should have designed a clear pattern of moving forward. If you need to bring your user from step 1 to step 7, you need to guide them through the whole process, and it can be as simple as putting “Next” buttons on the bottom of each page. Inside your app, this progression has to be clear, even more if step n+1 relies on the inputs from n. A good and simple way to do that is to hide elements at step n+1 until all the requirements are fulfilled at step n. Indeed, you can be sure that if step 2 relies on step 1 and you didn’t hide step 2 until you have everything you need, users will go to step 2 too soon. Another way to help this readability is to ensure some kind of linear logic through the app: step 1, data upload, step 2, data cleaning, step 3, data visualization, step 4, exporting the report. And organised your application around this logic, from left to right / right to left, or from top to bottom. Let’s compare {tidytuesday201942} to {hexmake} — one has a clear progression, {hexmake}, and has been designed as such: the upper menus design the stickers, and then once they are filled you can download them. So there’s a progression here, from top to bottom. On the other hand, the {tidytuesday201942} doesn’t have a progression inside it: you can navigate from one tab to the other indifferently. Hence there is no visual clues of progression on that app. 6.1.2.3 Inputs and errors You’re the one developing the app, so of course you’re conscious of all the inputs that are needed to complete a specific task. But your user might be new to the app, distracted while reading, they might not clearly understand what they are doing, maybe they don’t really want to use your app but are forced to by their boss… Or maybe your app is a little bit hard to understand, so it’s hard to know what to do at first. When building your app, you should make sure that if an input is necessary, it’s made clear inside the app. One way to do this is simply by hiding UI elements that can’t be used until all the necessary inputs are there. For example, if you’re building a dashboard and tab 2 needs specific inputs from tab 1, then tab 3 specific inputs from tab 2, then be sure that tab 2 and 3 are not clickable / available until all the required inputs are filled. That way, you can help the user navigate through the app, by reducing the cognitive load of having to be sure that everything is correctly set-up: if it’s not clickable, that’s because something is missing. Think about all the time when you’re ordering something on the internet, and need to fill specific fields before being able to click on the “Validate” button. Well, apply that approach to your app, that will prevent from unwanted mistakes. Note that when using the golem::use_utils_ui() function, you’ll end with a script of UI tools, one being with_red_star, which adds a little red star at the end of the text you’re entering: with_red_star(&quot;Enter your name here&quot;) Enter your name here* Also, be generous when it comes to errors: it’s rather frustrating for a user to see an app crash without any explanation about what went wrong. So, if something fails or behaves unexpectedly, error messages are a key feature to help your user get on the right track. And, at the same time, helping them correct themselves after an error is the best way to save you time answering angry emails! Let’s refactor our app from before: library(shiny) ui &lt;- function(request){ tagList( selectInput( &quot;species&quot;, &quot;Choose one or more species&quot;, choices = unique(iris$Species), multiple = TRUE, selected = unique(iris$Species)[1] ), plotOutput(&quot;plt&quot;) ) } server &lt;- function( input, output, session ){ output$plt &lt;- renderPlot({ if (length(input$species) == 0){ shiny::showNotification( type = &quot;error&quot;, &quot;Species can&#39;t be empty&quot; ) } req(input$species) plot( iris[ iris$Species %in% input$species, ] ) }) } shinyApp(ui, server) Here, as a user, it’s way easier to understand what went wrong: we’ve moved from a red error Error: need finite 'xlim' values to a pop-up explaining what went wrong in the way the user configured the app. Perfect way to reduce your bug tracker incoming tickets! This is a way to do it natively in Shiny, but note that you can also use the {shinyAlert} package to implement alerts. It’s also possible to build your own with a little bit of HTML, CSS and JavaScript. 6.2 The danger of feature-creep 6.2.1 What’s feature-creep? Feature-creep is the process of adding features to the app that complexify the using of the product, to the point that extreme feature-creep can lead to the product being entirely unusable. This movement always starts well-intentioned: easier navigation, more information, more visualizations, modifiable elements, and so on and so forth. It can come from project managers or dev, but users can also be responsible for asking more and more features in the app. If you’re working in a context where the app specifications where designed by the users, or where you regularly meet the users for their feedbacks, they’ll most of the time be asking for more than what is efficiently implementable. Behind feature-creep, there is always a will to make the user experience better, but adding more and more things most of the time leads to a slower app, worst user experience, steeper learning curve, and all these bad states you don’t want your app to be into. Let’s take a rather common data analytic process: querying data, cleaning them, then plotting and summarizing them. And let’s say that we want to add to this a simple admin dashboard, that tracks what the users do in the app. It’s pretty tempting to think of this as a single thing an throw the whole code base into one big project and hope for the best. But let’s decompose what we’ve got there for a minute: one task is querying and cleaning, one other is analyzing, and one other is administration. What’s the point of having one big app for these three unlinked tasks? Splitting this all project into three smaller apps will keep you from having a large app which is harder to maintain, and that might be less performing. Indeed, if you put everything into the same app, you’ll have to add extra mechanisms to prevent the admin panel from loading if your user simply wants to go to the extraction step, and vice versa: a user visiting the admin panel probably doesn’t need the extraction and analysis backend to be loaded when they simply want to browse the way other users have been using the app. Or, as simply put in The Art of Unix Programing: Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do. But let’s focus on a smaller scope, and think about some things that can be thought of as feature-creeping your Shiny app. 6.2.2 Restrain reactivity When designing an app, you’ll be thinking about the way users will navigate through the app. And most of the time, we design with “correct selection” in mind. Something like: “The user will select 40 on the sliderInput() and the plot will update automatically. Then the user will select the element they need in the selectInput() and the plot will update automatically”. When the reality will be more like: &quot;The user will click on the slider, aim at 40 but will reach 45, then 37, before having the right amount of 40. Then they’ll select something in the selectInput(), but chances are not the correct one from the first time. In real life usage, people make mistakes using the app, so if the application reacts to their every moves, the experience using the app can be bad: in the example above, full reactivity means that you might get 4 “wrong” recomputation of the plot before getting it right. In the {tidytuesday201942} application example, let’s imagine all the elements on the left automatically update the plot: especially in a context of a learning tool, reacting to any configuration change will launch a lot of useless computation, slowing the app on the long run. So what should we do? Prevent ourselves from implementing “full reactivity”: instead, we’ll add a user input that will launch the computation. The simplest solution being a button so that the user signals to the application than now they are ready for the application to compute what they have parametrized. 6.2.3 Too much interactivity Users love interactive elements. Maybe too much. If you present a user with a choice between a simple graph and a dynamic one, chances are that they’ll spontaneously go for the dynamic graph. Yet, dynamic is not always the solution, and for several reasons. 6.2.3.1 Speed Dynamic elements are slower to render than fixed one. Most of the time (if not always), rendering dynamic elements means that you’ll bind some external libraries, and maybe you’ll have to make R convert data from one format to another. For example, rendering a {ggplot2} plot will be faster than rendering a ggplotly() plot, which has to convert from one format to another22. 6.2.3.2 Visual noise The more the interactivity, the less straightforward the element is. Think for a minute about the {plotly} outputs. They are awesome if you need this kind of interactivity, but for a common plot there might be too many things to understand. Instead of focusing on the data, a lot of things show: buttons to zoom, to do selection, to export in png, and things like that. With this kind of graphs, users might lose some time focusing on understanding what the buttons do and why they are there, instead of focusing what on what matters: getting insights from the data. Of course these feature are awesome if you need them: exploring data interactively is a fundamental strength when the context is right. But if there is no solid reason for using an interactive table, use a standard HTML table. In other words, don’t make things interactive if there is no value in adding interactivity ; for example, if the users don’t need to sort the table, filter, navigate in pages, DT::datatable() will add more visual noise than adding value to the application. Adding interactivity widgets (in most cases) means adding visual elements to your original content: in other words, you’re adding visual components that might distract the user from focusing on the content of the information. To sum up, a good rule to live by is that you shouldn’t add a feature for the sake of adding a feature. Less is more. .right{ text-align: right;} Ludwig Mies van der Rohe 6.3 Web Accessibility 6.3.1 About Accessibility When building professional Shiny applications, you have to keep in mind that, potentially, this app will be consume by a large audience. A large audience means that there’s a chance that your app will be used by people with visual, mobility, or maybe cognitive disabilities23. Web Accessibility deals with the process of making the web available to people with disabilities. The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location, or ability. When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability. .right{ text-align: right;} Accessibility in Context - The Web Accessibility Initiative When learning to code a web app through “canonical” courses, you’ll be introduced to web Accessibility very early. For example, you can learn about this straight from the first chapter of learn.freecodecamp.org. The first course, “Responsive Web Design Certification”, has a chapter on web accessibility just after the one on HTML and CSS. 6.3.2 Making your App Accessible 6.3.2.1 Hierarchy Headers are not just there to make your application stylish. &lt;h1&gt; to &lt;h6&gt; are there so they can create a hierarchy inside your webpage: &lt;h1&gt; being more important (hierarchically speaking) than &lt;h2&gt;. In a perfectly designed website, you’d only have one header of level 1, a small amount of level 2 headers, more header of level 3, etc. Hence, you shouldn’t rely on the header level for styling: don’t use an &lt;h1&gt; because you need a larger title somewhere in your app. If you want to increase the size of an header, use CSS, which we will see in an upcoming chapter. 6.3.2.2 HTML element: Semantic tags, and tags metadata In HTML, there are two kind of elements: the one without “meanings” like &lt;div&gt; or &lt;span&gt;, and the one which are considered meaningful, like &lt;title&gt; or &lt;article&gt;. The second ones are called “semantic tags”, as they have a specific meaning in the sens that they define what they contain. library(htmltools) tags$article( tags$h2(&quot;Title&quot;), tags$div(&quot;Content&quot;) ) Title Content One other HTML method you can use is tags attributes as metadata. Tags attributes are complementary elements you can add to a tag to add information: most of the time, you’ll be using it to add a CSS class, and identifier, or maybe some events like onclick24. But these can also be used to add, for example, an alternate text to an image: this alt being the one which is read when the image is not available, either because the page couldn’t reach the resource, or because the person navigating the app is using a screen to speech technology. library(shiny) ui &lt;- function(request){ tagList( plotOutput(&quot;plot&quot;) %&gt;% tagAppendAttributes(alt = &quot;Plot of iris&quot;) ) } server &lt;- function( input, output, session ){ output$plot &lt;- renderPlot({ plot(iris) }) } shinyApp(ui, server) What makes these two things similar (semantic tags and tags metadata) is that they are both unseen by user without any impairment: if the image is correctly rendered and the user is capable of reading images, chances are that this user will see the image. But these elements are made for people with disabilities, and especially users who might be using screen to speech technologies: these visitors use a software that scans the textual content of the page and reads it, and that helps navigate through the page. This navigation is also crucial when it comes to screen to speech technology: these softwares will be able to read the &lt;title&gt; tag, jump to the &lt;nav&gt;, or straight to the &lt;article&gt; on the page. Hence the importance of structuring the page: these technologies need the app to be built in a structured way, so that it’s possible to jump from one section to another, and other common tasks a fully capable user will commonly do. Some other tags exists and can be used for semantic purpose: for example &lt;address&gt;, &lt;video&gt;, or &lt;label&gt;. 6.3.2.3 Navigation Your app user might also have mobility impairment. For example, some with Parkinson might be using your app, or someone with a handicap making it harder for them to move their hand and click. For these users, moving an arm to grab the mouse might be challenging, and they might be navigating the web using their keyboard only. When building your app, thinking about how these users will be able to use it is crucial: maybe there are so may button they need to click that they won’t be able to use it. So, as much as possible, make everything doable with a keyboard: for example, if you have a textInput() with a validation button below, allow the user to validate by pressing the ENTER on their keyboard. library(shiny) ui &lt;- function(request){ tagList( textInput(&quot;text&quot;, &quot;title&quot;) %&gt;% tagAppendAttributes( onKeyPress = &quot;Shiny.setInputValue(&#39;keypress&#39;, {value : event.key}, {priority: &#39;event&#39;})&quot; ), actionButton(&quot;go&quot;, &quot;Go&quot;) ) } server &lt;- function( input, output, session ){ observeEvent( input$keypress , { if (input$keypress$value == &quot;Enter&quot;){ # ... } }) } shinyApp(ui, server) Note that if you need a more systemic way to do this, you can do it with the {nter} package: # Taken from https://github.com/JohnCoene/nter library(nter) library(shiny) ui &lt;- fluidPage( textInput(&quot;text&quot;, &quot;&quot;), actionButton(&quot;send&quot;, &quot;Don&#39;t click hit enter&quot;), verbatimTextOutput(&quot;typed&quot;), nter(&quot;send&quot;, &quot;text&quot;) # trigger &#39;send&#39; button when &#39;text&#39; is active. ) server &lt;- function(input, output) { txt &lt;- eventReactive(input$send, { input$text }) output$typed &lt;- renderPrint(txt()) } shinyApp(ui, server) Listening on http://127.0.0.1:6416 6.3.2.4 Color choices Color blindness is also a common impairment when it comes to web accessibility. And it’s a rather common deficiency: according to colourblindawareness.org, “color (color) blindness (color vision deficiency, or CVD) affects approximately 1 in 12 men (8%) and 1 in 200 women in the world”. Keeping in mind this prevalence of color blindness is even more important in the context of Shiny, where we are developing data science products, which most of the time include data visualization. If designed wrong, dataviz can be unreadable for some specific type of color blindness. That’s why we recommend using the viridis palette, which has been created to be readable by the most common types of color blindness. Here are for example a visualization through the lens of various type of color blindness: # Function to generate the graph with_palette &lt;- function(palette) { x &lt;- y &lt;- seq(-8 * pi, 8 * pi, len = 40) r &lt;- sqrt(outer(x^2, y^2, &quot;+&quot;)) filled.contour(cos(r^2) * exp(-r / (2 * pi)), axes = FALSE, color.palette = palette, asp = 1 ) } With the jet.colors palette from {matlab} with_palette(matlab::jet.colors) with_palette(viridis::viridis) Even without color-blindness, it’s already way more readable. But let’s now use the {dichromat} package to simulate color blindness. library(dichromat) library(purrr) Deutan with jet.colors and viridis graph &lt;- partial(dichromat, type = &quot;deutan&quot;) with_palette( compose( graph, matlab::jet.colors ) ) with_palette( compose( graph, viridis::viridis ) ) Protan with jet.colors and viridis graph &lt;- partial(dichromat, type = &quot;protan&quot;) with_palette( compose( graph, matlab::jet.colors ) ) with_palette( compose( graph, viridis::viridis ) ) Tritan with jet.colors and viridis graph &lt;- partial(dichromat, type = &quot;tritan&quot;) with_palette( compose( graph, matlab::jet.colors ) ) with_palette( compose( graph, viridis::viridis ) ) par(mfrow=c(2,1)) with_palette( compose( partial(dichromat, type = &quot;deutan&quot;), matlab::jet.colors ) ) with_palette( compose( partial(dichromat, type = &quot;deutan&quot;), viridis::viridis ) ) As you can see, the viridis palette always gives a more readable graph than the jet.colors one. And, the plus side, it looks fantastic. So don’t hesitate to try and use it! 6.3.3 Evaluating your App Accessibility &amp; Further reading Evaluating Web Accessibility, with lengthy reports and advice about checking the accessibility of your website https://www.webaccessibility.com/ has an online checker for webpage accessibility, and allows you to freely test 5 pages. {hexmake} accessibility results aka what happens in the server side of a Shiny App↩ "],
["step-design.html", "Chapter 7 Don’t rush into coding 7.1 Designing before coding 7.2 Ask questions", " Chapter 7 Don’t rush into coding 7.1 Designing before coding You have to believe that software design is a craft worth all the intelligence, creativity, and passion you can muster. Otherwise you won’t look past the easy, stereotyped ways of approaching design and implementation; you’ll rush into coding when you should be thinking. You’ll carelessly complicate when you should be relentlessly simplifying — and then you’ll wonder why your code bloats and debugging is so hard. .right{ text-align: right;} The Art of Unix Programming - Attitude Matters Too 7.1.1 The Urge to Code At the moment you receive the specifications for your app, it’s tempting to rush into coding. And that’s perfectly normal: we’re Shiny developer because we love building softwares, so as soon as a problem emerges, our brain starts thinking about technical implementation, packages, pieces of code, and all these things that we love to do when we’re building an app. Rushing into coding from the very beginning is not the safest way to go. Focusing on technical details from the very beginning can make you miss the big picture, be it for the whole app if you’re in charge of the project, or for the piece of the whole app you’ve been assigned to. Have you ever faced a situation in a coding project where you tell yourself “Oh, I wish I had realised this sooner, because now I need to refactor a lot of my code for this specific thing”? Yes, we all have been in this situation: realising too late that the thing we’ve implemented doesn’t work with another feature we discover along the road. And what about &quot;Oh I wish I had realised sooner that this package existed before trying to implement my own fonctions to do that!. Yes, same thing: we’re jumping straight into solving programming problem when someone else has open-sourced a solution to this very same problem. Of course, implementing your own solution might be a good thing in specific cases: avoiding heavy dependencies, incompatible licensing, the joy of intellectual challenge… But when building production softwares, it’s safer to go for an existing solution if it exists and fits in the project: existing packages / software benefit from wider testing, wider documentation, and a larger audience if you need to ask questions. So, before rushing into coding, take some time to conceptualise your application / module on a piece of paper. That will help you get the big picture for the piece of code you’ll be writing: what are the inputs, what are the outputs, what packages / services you can use inside your application, how it will fit in the rest of the project. 7.1.2 About Concept Map // TODO 7.2 Ask questions Before starting to code, the safe call will be to ask your team/client (depending on the project) a series of question just to get a good grasp of the whole project. Here is a (non-exhaustive) list of information you might need along the way. Side note: of course, these questions do not cover the core functionning of the application: I’m pretty sure you’ve thought about covering this already. These are more contextual questions which are not directly linked to the application itself 7.2.1 About the end users Who are the end users of your app? Are they tech-literate? In which context will they be using your app? On what machines, and in what context? Will they be using the app in their office, on their phone while driving a tractor, in a plant while wearing lab coats? That might seems like weird questions if you’re just focusing on the very technical side of the app implementation, but think about where the app will be used: the application used while driving agricultural machineries might need less interactive things, bigger fonts, simpler interface, less details and more direct information. If you’re building a Shiny app for a team of sellers who are always on the road, chances are they’ll need an app that they can browse from their mobile. And developing for mobiles requires a different kind of mindeset25. Another good reason why talking to the users is an important step is that most of the time, people writing specifications are not the end users and will ask either for too much features or not enough. Do the users really need that much interactive plots? Do they actually need that much granularity in the information? Will they really read a datatable of 15k lines? Do they really care about being able to zoom in the dygraph so that they can see the point at a minute scale? To what extent does the app has to be fast? Asking these questions is important, because building interactive wigets makes the app a little bit slower, and shoving a series of unnecessary widgets will make the user experience worse. The speed of execution of your app is also an important parameter for your application: getting a sense about the need for speed in your application will allow you to judge wether or not you’ll have to focus on optimizing code execution. On top of that, remember all these things we’ve seen in the last chapter about accessibility: some of your end users might have specific accessibility requirements. 7.2.2 Pre-existing code-base From time to time, you’re building a Shiny app on top of an existing code-base: either scripts with business logic, a package if you’re lucky, or a POC for a Shiny app. Depending on how you chose to handle it, starting from an code base that is already written can either be very much helping, or you can be shooting yourself in the foot. Most of the time, Shiny projects are not built as reproductible infrastructures: you’ll find a series of library() calls, no functions structure per se, no documentation, and no tests. In that case, I’d advice to do it “the hard way”, or at least what seems to be the hard way: throw the app out away and start from scratch. Well, not really from scratch: extract the core business logic of the app and make it a package. Take some time with the developer(s) that has built the app, so that you can make them extract the core, reactivity independent pieces of code. Write documentation for this package, work on test, and one you’re done, call it a day: you now have a solid ground for building the backend, and it’s build outside of any reactivity, is not application dependant, and most of the time it can be used outside of the app and it will actually serves analysts and data scientists that will benefit from these functions while coding. Existing Shiny projects, in most cases, have not been build by software engineers nor web developers—they have been built by data analyst/scientists who wanted to create an interactive POC for their work—so the good news is that you can expect the core algorithms to be pretty solid and innovative. But web development is not their strength: and that’s perfectly normal—it’s not their core job. All that means that most Shiny POCs take shortcuts and rely on hacks, especially when it comes to reactivity, which is a beautiful concept for small project but can be very complex to scale if you’re not in a software engineer. That’s why it’s better to split the business and app logic from the very beginning (as we’ve explained in chapter 3): it simplifies the process of refactoring a Shiny PoC into a production-grade Shiny application. 7.2.3 Deployment There are so many considerations about deployment that it will be very hard to list them all here, but keep in mind that if you don’t ask questions about where to deploy your app from the start, you might have bad surprises when you’ll send your app to production. Of course, it’s more or less solved if you’re deploying with Docker: if it works in a container on your machine, it should work in production. But that’s just the tip of the iceberg. One time, we built an app that had to do some API requests. So far so good, nothing too complicated… until we discovered that the server where the app will be deployed doesn’t have access to the internet, making it impossible to issue API requests from the server. Here, the containers worked on our machine, as they had access to the internet. Once deployed, the app stopped working, and we lose a couple of days of exchanges with the client, trying to debug our API calls, until we realised that the issue wasn’t with our app, but with the server itself. It’s even more important to thing about the IT side of your application, as the people writing specs and interacting with you might come from the Data Science team, and they might or might not have discussed with the IT team about deploying the app, so there’s a chance that they don’t have in mind all what is needed to deploy a Shiny App on their company server. For example, maybe your application has a database backend. For that, you’ll need to have access to this database, the correct port should be set, and the permission given to the process that executes the Shiny app to read, and maybe write, to the database. But, and for good reason, database managers don’t issue read and write permissions to a DB without having examined what the app wants to read, and how and where it will write. So, if you don’t want to have weeks of delay for your app deployment, start the discussion from the very beginning of the project. That way, even if the process of getting permission to write on the company database takes time, you might have it by the end of the coding marathon. "],
["css.html", "Chapter 8 A Gentle Introduction to CSS 8.1 What is CSS 8.2 Getting started with CSS 8.3 Integrate CSS files to your Shiny App 8.4 External resources", " Chapter 8 A Gentle Introduction to CSS 8.1 What is CSS 8.1.1 About CSS CSS, for Cascading Style Sheets, is one of main technologies that power the web today, along with HTML and JavaScript. HTML is a series of tags that define your web page structure, and JavaScript is a programming language that allows you to manipulate the page (well, it can do a lot more than that, but we’re simplifying to make it understandable). CSS is what handles the design, i.e. the visual rendering of the web page: the color of the header, the font, the background, and everything that makes a web page looks like it’s not from 1983 (again, we’re simplifying for the sake of clarity). On every browser, each HTML element has a default style: for example all &lt;h1&gt; have the size 2em and are in bold, and &lt;strong&gt; is in bold. But we might not be happy with what a “standard page” (with no CSS) looks like: that’s the very reason of CSS, modifying the visual rendering of the page. If you want to get an idea of the importance of CSS, try installing extensions like Web Developer for Google Chrome. Then, if you go on the extension and choose CSS, click “Disable All Style”, to see what a page without CSS looks like. For example, here is what rtask.thinkr.fr looks like: And here is what it looks like without CSS: CSS now seems pretty useful right? 8.1.2 Shiny’s default: fluidPage() In Shiny, there is a default CSS: the one from Bootstrap 4. As you can see if you have created a fluidPage() before, there is already styling applied. Compare: (no fluidPage) library(shiny) ui &lt;- function(request){ tagList( h1(&quot;Hey&quot;), h2(&quot;You&quot;), p(&quot;You rock!&quot;), selectInput(&quot;what&quot;, &quot;Do you&quot;, unique(iris$Species)) ) } server &lt;- function( input, output, session ){ } shinyApp(ui, server) Listening on http://127.0.0.1:3102 to (with fluidPage): library(shiny) ui &lt;- function(request){ fluidPage( h1(&quot;Hey&quot;), h2(&quot;You&quot;), p(&quot;You rock!&quot;), selectInput(&quot;what&quot;, &quot;Do you&quot;, unique(iris$Species)) ) } server &lt;- function( input, output, session ){ } shinyApp(ui, server) Listening on http://127.0.0.1:4017 Yes, that’s subtle, but you can see how it makes the difference on larger apps. 8.2 Getting started with CSS CSS is a descriptive language, meaning that you will have to declare the style either on a tag or inside an external file. We will see how to integrate CSS inside your Shiny application in the next section, but before that, let’s start with a short introduction to CSS26. 8.2.1 About CSS syntax CSS syntax is composed of two elements: a selector, and a declaration block. The CSS selector describes how to identify the HTML tags that will be affected by the style declared with key-value pairs in the declaration block that follows. And because an example will be easier to understand, here is a simple CSS rule: h2 { color:red; } Here, the selector is h2, meaning that the HTML tags aimed by the style are the &lt;h2&gt; tags. The declaration block contains the key-value pair telling that the color will be red. Note that each key-value pair must end with a semicolon. 8.2.2 CSS selectors CSS selectors are a wide topic, as there are many combinations of things you might want to select inside an HTML page. The first type of selectors are the “standard” ones name, id, or class. These refer to the elements composing an HTML tag: for example, with &lt;h2 id = &quot;tileone&quot; class = &quot;standard&quot;&gt;One&lt;/h2&gt;, the name is h2, the id tileone, and the class standard27. To select these three elements in CSS: Write the name as-is: h2 Prefix the id with #: #tileone Prefix the class with .: .standard You can also combine these elements, for example h2.standard will select all the h2 tags with a class standard, and h2,h3 will select the h2 and the h3. You can build more complex selectors: for example div.standard &gt; p will select all the &lt;p&gt; tags that are contained inside a div of class standard (CSS combinator), or a:hover, which dictates the style of the a tags when they are hovered by the mouse (CSS pseudo-class), div.standard::first-letter, that select the first letter of the div of class standard (CSS pseudo-elements), and h2[data-value=&quot;hey&quot;], which selects all the h2 with a data-value attribute set to &quot;hey&quot; (CSS attribute selector). As you can see, lots of complex selectors can be built with CSS, to target very specific elements of your UI. But mastering these complex selectors is not the main goal of this chapter, hence we will just be using standard selectors in the rest of the examples in this book. 8.2.3 CSS properties Now that you have selected elements, it is time to apply some styles! Between the brackets of the declaration block, you will have to define a series of key-value elements defining the properties of the style: the key here is the css property, followed by its value. For example, color: red; or text-align: center; define that for the selected HTML elements, the color will be red, or the text centered. We will not cover all the possible properties, as there hundreds of them. Feel free to refer to the CSS Reference page from Mozilla for an exhaustive list of available properties. 8.3 Integrate CSS files to your Shiny App Ok, but now you’ve got a grasp on how to getting started writing your own CSS, how do you integrate it inside your Shiny Application? There are two methods that can be used: integrating it inside a tags$script() straight into you application UI code, or by writing it into an external file. Note that the good practice is considered to be the integration of an external file. 8.3.1 Inline CSS If you need to add style to one specific element, you can write it straight inside the HTML tag: library(shiny) ui &lt;- function(request){ tagList( h2(style = &quot;color:red;&quot;, &quot;This is red&quot;) ) } server &lt;- function( input, output, session ){ } shinyApp(ui, server) Listening on http://127.0.0.1:3790 But this method loses all the advantages of CSS, notably the possibility to apply style to multiple elements. Use it with caution. 8.3.2 Writing in a tags$style() If you had a tags$style() somewhere inside your UI code (generally at the very beginning of your UI), you can then add CSS code straight to your application. Here is an example: library(shiny) ui &lt;- function(request){ tagList( tags$style( &quot;h2{ color:red; }&quot; ), h2(&quot;This is red&quot;) ) } server &lt;- function( input, output, session ){ } shinyApp(ui, server) Listening on http://127.0.0.1:8158 This works, but shouldn’t be considered as the best option: indeed, if you have a large amount of CSS code to insert to your app, it can make the code harder to read as it adds a large amount of visual noise. That’s why it’s best to go with the alternative of writing the CSS inside a separate file: it allows to separate things and to make the UI code lighter, as it’s easier to maintain a separate CSS file than CSS written straight into R code. 8.3.3 Including External Files To include an external CSS file, you will have to use another tags: tags$link(). What this tag will contain is these three elements: rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;www/custom.css&quot; The first two are standard: you do not need to change them, they are necessary to indicate to the HTML page that you are creating a stylesheet, with the type being text/css. The href is the one you will need to change: this path points to where your style file is located. If you are building your application with {golem}, the good news is that this file creation and linking is transparent: if you call golem::add_css_file(&quot;name&quot;), a file will be created at inst/app/www, and this file will be automatically linked inside your UI thanks to the bundle_resouces() function. 8.3.4 Using R packages // TODO 8.4 External resources // TODO "],
["stepprotopype.html", "Chapter 9 Building an “ipsum-app” 9.1 Prototyping is crucial 9.2 Prototyping Shiny", " Chapter 9 Building an “ipsum-app” 9.1 Prototyping is crucial // TODO Prototyping first may help keep you from investing far too much time for marginal gains. http://www.catb.org/~esr/writings/taoup/html/ch01s06.html#rule_of_optimization 9.1.1 The “UI first” approach // TODO I like to go “UI first”. For two main reasons: Once the UI is set, there is no “surprise implementation”. Once we agree on what elements there are in the app, there is no sudden “oh the app needs to do that now”. A pre-defined UI allows every person involved in the coding to know which part of the app they are working on. In other words, when you start working on the backend, it’s much easier to work on a piece you can visually identify and integrate in a complete app scenario. So yes, spend time writing a front-end prototype in lorem ipsum. And good news, we’ve got a tool for you: it’s called {shinipsum}. The main goal of this package is to create random Shiny elements that can be used to draw a UI, without actually doing any heavy lifting in the backend. Hence, once you’ve got a draft of your app on a piece of paper, you can then move to the “ipsum-UI” stage: building the front-end of the app, and filling it with random Shiny elements, with functions like random_ggplot() or random_DT(). Another package that can be used to do that is {fakir}. This package is designed to create fake data frames, primarily for teaching purposes, but it can also be used for inserting data into a shiny prototype. Building the User Interface first should require the least possible calculations from the server part of your application. You focus on the appearance. The UI is usually a collection of buttons, figures and tables. Some being triggered by others. When first building your interface, you may only want to focus on where you place the different boxes and graphs. You will use the different *Input from {shiny} for inputs that will later affect the server part. You will also set the place for *Output, but these outputs will be empty. To show a first overview of what will look like your interface, you can use fake data and figures to fill the blank outputs. This is where {shinipsum} and {fakir} come to help. 9.2 Prototyping Shiny 9.2.1 Fast prototyping with {shinipsum} The goal of {shinipsum} is to provide random shiny elements to simulate interface outputs. Use lorem, the long “Lorem Ipsum” text to fill in text parts. Use the random_* functions in the server part of your application in combination with the appropriate render*(). This will fill the corresponding call to *Output() in the UI. For instance: random_DT() renders a DT::datatable() output with one of existing R internal datasets. random_ggplot(type = &quot;point&quot;) renders a random {ggplot2} graph with the selected type (corresponding to geom() in {ggplot2}). random_text(nwords = 10) renders a text with the defined number of words. library(shiny) library(shinipsum) library(DT) ui &lt;- fluidPage( h2(&quot;A Random DT&quot;), DTOutput(&quot;data_table&quot;), h2(&quot;A Random Plot&quot;), plotOutput(&quot;plot&quot;), h2(&quot;A Random Text&quot;), tableOutput(&quot;text&quot;) ) server &lt;- function(input, output, session) { output$data_table &lt;- DT::renderDT({ random_DT(5, 5) }) output$plot &lt;- renderPlot({ random_ggplot() }) output$text &lt;- renderText({ random_text(nwords = 50) }) } shinyApp(ui, server) Find out more in the corresponding website: https://thinkr-open.github.io/shinipsum/ 9.2.2 Using {fakir} for fake data generation {fakir} was primarily created to provide fake datasets for R tutorials and exercises. “Fake support ticket dataset” is built using fake_ticket_client() and “Fake questionnaire on mean of transport / goal dataset” is built using fake_sondage_answers(). They contain dates, numeric and character variables, with missing values allowing multiple exercises on data cleaning and graph building. They can also be joined with the included {sf} geographical dataset fra_sf allowing for maps creation. Fake datasets created with {fakir} can be used to build light examples on the use of the inputs, for filters or interactive maps for instance. When building your application inside a R package, as recommended in this book using {golem}, you may want to build small reproducible examples of your functions, to be presented in the vignettes and tested in the unit tests, prior to building the Shiny Apps itself. You can create these examples using {fakir}. Find out more in the corresponding website: https://thinkr-open.github.io/fakir/ "],
["proto-rmdfirst.html", "Chapter 10 Building with RMarkdown 10.1 Define the content of the application 10.2 Fill the Rmd files 10.3 Use the ‘Rmd first’ method to document further", " Chapter 10 Building with RMarkdown Once again, we advise not to directly write in the Shiny application. We recommend using the ‘Rmd first’ method. It is important to correctly visualize the structure of your application before the build: number of pages and elements, how the different elements interact with each other, what are the inputs needed and the outputs. If you worked the ‘UI-first’, this should be clearer now. It is then time to develop the core of the different parts of the application. 10.1 Define the content of the application Put everything in Rmarkdown files. Use the Rmarkdown files as the sandbox of your application. If you work for a client, Rmd files knitted as HTML or PDF are easily shared for discussions about their expectations. When there are modifications of expectations or needs to visualize different propositions, knitting a Rmd file is usually easier than manually clicking on your Shiny application to reach the modified part and take a snapshot. Your application may contain data wrangling operations, multi-parameters based models, summary tables outputs, graphical outputs. All this manipulations do not require the interactivity of the Shiny application to be developed. We propose to divide the different parts of your Shiny application into multiple Rmarkdown files where you present and develop the content. You may want to create one Rmarkdown file for each page / tab of the graphical interface. The static development will simplify the multiple tests necessary during development to verify that algorithms output the correct results, to propose different colors combinations for your graphs, to improve the speed of operations, … You can use some dataset examples from real cases, small reproducible examples, or from fake datasets (See §??). 10.2 Fill the Rmd files Rmarkdown files are the place to write what you have in mind. As soon as it is related to your Shiny application of course. Write your questions, your objectives. Detail methods used and choices you made for your data wrangling, models, visualization. This will help you present them to your client, boss, colleagues. This will also help yourself in the future when you will want to debug some parts of your code. This will simplify discussion with other developers if you separated the work between multiple persons. Note that developing in multiple Rmd files helps the allocation of work between multiple developers and will reduce code conflicts during development. 10.3 Use the ‘Rmd first’ method to document further We recommend building Shiny Apps in a package. A package requires documentation and unit tests. While you develop the content of your application in a series of Rmarkdown files, it is a good time to create functions. Indeed, the code written in the Rmarkdown will be used a second time in the Shiny application when time has come to include it. To reduce copy-pasting, you may want to take advantage of the package structure to create functions of your code and store them in the ‘R’ directory of the package. As you write your function, write its roxygen documentation and list dependencies. Also, because you created your code based on one or multiple examples, you are able to directly write unit tests for your newly created functions. Writing a proper documentation and unit tests will save you a lot of time when you will implement the different functionalities in your application. This will often allow to detect cascading modifications of the outputs during the check of the package, before you play with the graphical interface. The Rmd files are the vignette of the package. Store them in the vignette directory, so that they are built and tested when you check the package. Note that once the application is set up and functionalities included, you will surely got back to the code to debug, add new functionalities, … Continue to use the Rmarkdown files after the prototyping phase all along the development. "],
["stepbuild.html", "Chapter 11 Building app with {golem} 11.1 Using {golem} 11.2 dev/01_start.R 11.3 Day to Day Dev with {golem} 11.4 Launching the app 11.5 dev/02_dev.R 11.6 Adding these external resources to your app 11.7 Documentation 11.8 Using {golem} dev functions", " Chapter 11 Building app with {golem} Now the UI and the features are set, time to work on the backend. This part is pretty standard — everybody can now work on the implementation of the functions that process the app inputs, in their own modules. As the UI, functionalities and modules have been defined in the previous steps, everyone (well, in theory) knows what they have to work on. And also, as said before, there should be no “surprise implementation”, as the app has been well defined before. 11.1 Using {golem} 11.1.1 Create a package Once the package is installed, you can got to File &gt; New Project… in RStudio, and choose “Package for Shiny App Using golem” input. If you want to do it through command line, you can use: golem::create_shiny_template(path = &quot;path/to/package&quot;) This command allows you to create “illegally-named” package (for example, 1234) by passing the check_name argument to FALSE. Note that this is not recommended and should only be done if you know what you are doing. Once you’ve got that, a new RStudio project will be launched. Here is the structure of this project: DESCRIPTION ¦--dev/ ¦--01_start.R ¦--02_dev.R ¦--03_deploy.R ¦--run_dev.R ¦--inst/ ¦--app ¦--server.R ¦--ui.R ¦--www/ ¦--favicon.ico ¦--man/ ¦--run_app.Rd NAMESPACE myapp.Rproj ¦--R/ ¦--app_server.R ¦--app_ui.R ¦--run_app.R If you’re already familiar with R packages, most of these files will appear very familiar to you. That’s because a {golem} app IS a package. DESCRIPTION &amp; NAMESPACE: Package meta-data. dev/: Scripts that will be used along the process of developing your app. inst/app: You’ll add external dependencies in www (images, css, etc). Don’t touch app_ui and app_server. man: Package doc, to be generated by R. myapp.Rproj: RStudio project. R/app_server.R, R/app_ui.R: Top level UI and server elements. R/run_app.R: a function to configure and launch the application. 11.2 dev/01_start.R Once you’ve created your project, the first file that opens is dev/01_start.R. This file contains a series of commands to run once, at the start of the project. 11.2.1 Fill the DESC First, fill the DESCRIPTION by adding information about the package that will contain your app: golem::fill_desc( pkg_name = &quot;shinyexample&quot;, # The Name of the package containing the App pkg_title = , # The Title of the package containing the App pkg_description = , # The Description of the package containing the App author_first_name = , # Your First Name author_last_name = , # Your Last Name author_email = , # Your Email repo_url = NULL) # The (optional) URL of the GitHub Repo 11.2.2 Set common Files If you want to use the MIT licence, README, code of conduct, lifecycle badge, and news usethis::use_mit_license(name = &quot;Your Name&quot;) # You can set another licence here usethis::use_readme_rmd() usethis::use_code_of_conduct() usethis::use_lifecycle_badge(&quot;Experimental&quot;) usethis::use_news_md() 11.2.3 Add a data-raw folder If you have data in your package usethis::use_data_raw() 11.2.4 Init Tests Create a template for tests: golem::use_recommended_tests() 11.2.5 Use Recommended Package This will add “shiny”, “DT”, “attempt”, “glue”, “htmltools”, and “golem” as a dependecy to your package. golem::use_recommended_dep(&quot;&quot;) 11.2.6 Add various tools These two functions add a file with various functions that can be used along the process of building your app. See each file in details for a description of the functions. golem::use_utils_ui() golem::use_utils_server() 11.2.7 If you want to change the default favicon golem::use_favicon( path = &quot;path/to/favicon&quot;) You’re now set! You’ve successfully initiated the project and can go to dev/02_dev.R. rstudioapi::navigateToFile(&quot;dev/02_dev.R&quot;) 11.3 Day to Day Dev with {golem} Now that you’re all set with your project init, time to move to development :) App development should happen through the dev/02_dev.R file, which contains common commands for developping. 11.4 Launching the app To run the app, go to the dev/run_dev.R file, and run the all thing. 11.5 dev/02_dev.R 11.5.1 Add modules The golem::add_module() functions creates a module in the R folder. The file and the modules will be named after the name parameter, by adding mod_ to the R file, and mod_*_ui and mod_*_server to the UI and server functions. golem::add_module(name = &quot;my_first_module&quot;) # Name of the module The new file will contain: # mod_UI mod_my_first_module_ui &lt;- function(id){ ns &lt;- NS(id) tagList( ) } mod_my_first_module_server &lt;- function(input, output, session){ ns &lt;- session$ns } ## To be copied in the UI # mod_my_first_module_ui(&quot;my_first_module_1&quot;) ## To be copied in the server # callModule(mod_my_first_module_server, &quot;my_first_module_1&quot;) In order not to make errors when putting these into your app, the end of the file will contain code that has to be copied and pasted inside your UI and server functions. 11.5.2 Add dependencies To be called each time you need a new package as a dependency: usethis::use_package(&quot;pkg&quot;) 11.5.3 Add tests Add more tests to your application: usethis::use_test(&quot;app&quot;) 11.5.4 Add a browser button Learn more about this: https://rtask.thinkr.fr/blog/a-little-trick-for-debugging-shiny/ golem::browser_button() 11.5.5 Add external files These functions create external dependencies (JavaScript and CSS). add_js_file() creates a simple JavaScript file, while add_js_handler() adds a file with a skeleton for shiny custom handlers. golem::add_js_file(&quot;script&quot;) golem::add_js_handler(&quot;script&quot;) golem::add_css_file(&quot;custom&quot;) 11.6 Adding these external resources to your app You can add any external resource (JS, css) into inst/app/www. Then, You’ll need to point to these external resources in golem_add_external_resources(). For example, if you’ve created a CSS file with golem::add_css_file(&quot;custom&quot;), you can add the file with: tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;) Also, you can list here the use of other packages, for example useShinyalert() from the {shinyalert} package. Note: we’ve chosen to leave it “raw”, in the sense that there is a addResourcePath and a tags$head. If you’re comfortable with {htmltools}, you can build a htmltools::htmlDependency. 11.7 Documentation 11.7.1 Vignette usethis::use_vignette(&quot;shinyexample&quot;) devtools::build_vignettes() 11.7.2 Code coverage usethis::use_travis() usethis::use_appveyor() usethis::use_coverage() 11.8 Using {golem} dev functions There’s a series of tools to make your app behave differently whether it’s in dev or prod mode. Notably, the app_prod() and app_dev() function tests for options( &quot;golem.app.prod&quot;) (or return TRUE if this option doesn’t exist). Setting this options at the beginning of your dev process allows to make your app behave in a specific way when you are in dev mode. For example, printing message to the console with cat_dev(). options( &quot;golem.app.prod&quot; = TRUE) golem::cat_dev(&quot;hey\\n&quot;) options( &quot;golem.app.prod&quot; = FALSE) golem::cat_dev(&quot;hey\\n&quot;) hey You can then make any function being “dev-dependant” with the make_dev() function: log_dev &lt;- golem::make_dev(log) log_dev(10) [1] 2.302585 options( &quot;golem.app.prod&quot; = TRUE) log_dev(10) "],
["step-secure.html", "Chapter 12 Build yourself a safety net 12.1 Testing your app 12.2 A reproducible environment", " Chapter 12 Build yourself a safety net “Don’t fuck over Future You” JD Strengthening your app means two things: testing, and locking the application environment. 12.1 Testing your app 12.1.1 Testing the business logic If you have been following the good practices we have listed in previous chapters, your current application has at least these two properties: The business-logic functions are separated from your interactive-logic functions. Your application is inside a package. On top of being a sane organization approach, using this separation inside a package structure allows to leverage all the tooling that has been built for testing “standard” packages. R developers have been developing packages for a long time, and at the time of writing these lines (February 2020), more than 15,000 packages are available on CRAN. To sustain these developments, a lot of tooling has been created to secure the development process, and especially in the field of creating unit tests for your package. Unit tests are a general concept in software engineering that describes the process of writing a form of assessment of your code validity. A simplified explanation is that if you write a function call meaning_of_life that returns 42, you will expect this function to always return 42, and to be alerted if ever this value changes. Using unit tests is a way to secure your work in the future, be it from future you or from collaborator: if anyone comes and change the code behind meaning_of_life so that the result is no longer 42, the developer working on this piece of code will be able to catch it. There are several packages in R that can be used to implement unit testing, and you can even implement your own tests. One of the most popular right now28 is {testthat}, by Hadley Wickham. This testing framework lets you write a series of tests and expectations, which are then launch when calling devtools::test(), either locally or in you CI system. Here is an example of testing that the meaning_of_life will alway be 42. test_that(&quot;The meaning of life is 42&quot;, { expect_equal( meaning_of_life(), 42 ) }) If you want to learn more about how to use {testthat}, you can refer to the following resources: {testthat} online documentation Chapter 10 Testing - R Packages Part 5: Test and Code Coverage - Building a package that lasts — eRum 2018 workshop 12.1.2 Testing the interactive logic // TO DO When it comes to testing the front end, you can try the {shinytest} package from RStudio, if you need to be sure there is no visual regression all along the project development. One other tool I like to use is Katalon Studio. It’s not R related, and can be used with any kind of web app. How it works is quite simple: it opens your browser where the Shiny app runs, and record everything that happens. Once you stop the recording, you can relaunch the app and it will replay all the events it has recorded. And of course, you can specify your own scenario, define your own events, etc. It’s not that straightforward to use, but once you get a good grasp of how it works, it’s a very powerful tool. 12.1.3 Testing the app load // TODO {shinyloadtest}, on the other hand, tests how an application behaves when one, two, three, twenty, one hundred users connect to the app, and gives you a visual report about the connection and response time of each session. 12.2 A reproducible environment Secondly, secure your app means that it can be deployed again any time in the future — in other words, you have to ensure you’ve got a proper handle on the required R version, and of the package versions which are required to run your app. That means that you have to be aware that upgrading a package might break your app — so, provide an environment that can prevent your app from breaking when a package gets updated. 12.2.1 {renv} 12.2.2 Docker &amp; RStudio Connect For that, there is, of course, Docker, R specific tools like {packrat} or {renv}, or deploying custom CRAN repositories or package manager. "],
["secure.html", "Chapter 13 Version Control 13.1 Using Version Control with git 13.2 Git integration 13.3 CI and testing", " Chapter 13 Version Control 13.1 Using Version Control with git “Friends don’t let friends work on a coding project without version control.” You might have heard this before, without really considering what this means. Or maybe you’re convinced about this saying, but haven’t had the opportunity to use git, GitHub or Gitlab for versioning your applications. If so, now is the time for a workflow change! 13.1.1 Why Version Control? Have you ever experience a piece of code disappearing? Or the unsolvable problem of integrating changes when several people have been working on the same piece of code? Or the inability to find back something you’ve written a while back? If so, you might have been craving for Version Control (now shortened VC). In this chapter, we’ll be focusing on git, but you should be aware that other VC system exist, but they are less popular than git. Git was designed to handle collaboration on code projects29 where potentially a lot of people have to interact and make changes to the codebase. Git might feel a little bit daunting at first, and even seasoned developers still misuse it, or don’t understand it completely. But don’t give up: the benefits from learning it really outweigh the (apparent) complexity. There are many advantages to VC, and here is a non-exhaustive list: You can get back in time. With a VC system like git, every change is recorded (well, every committed change), meaning that you can potentially get back in time to a previous version of a project. Crucial if you accidentally made changes that break your application, or if you deleted a feature you thought you’d never need. Several people can work on the same file. Git relies on a system of branches. Within this branch pattern, there is one main branch, called “Master”, which contains the stable, main version of the code-base. By “forking” this branch (or any other branch actually), developers will have a copy of the base branch, where they can safely work on changing (and breaking) things, without impacting the origin branch. This allows to try things in a safe environment, without touching what is working. You can safely track changes. Every time a developer records something to git, changes are listed. In other words, you can see what changes are made to a specific file in your code base. It centralizes the code base. You can use git locally, but its strength also relies on the ability to synchronize your local project with one on a server. This also means that several people can synchronize with this server and collaborate on a project. That way, changes on a branch on a server can be downloaded (it’s called pull in git terminology) by all the members of the team. 13.1.2 Git basics: commit - push - pull These are the three main actions you’ll be performing in git, and if you just need to learn the minimum to get started, they are the three essential ones. 13.1.2.1 commit A commit is a photography of a codebase at a given moment in time. Every commits is associated with two things: a sha1, which is a unique reference in the history and that allows you to identify this precise state when you need to get back in time, and a message, which is a piece of text that describes the commit30. Note that message are mandatory: you can’t commit without them. Don’t overlook these messages: they might seem like a constraint at first but they are a life save when you need to understand the history of a project. There is no strict rule about what and when to commit. Just keep in mind that commits are what allow you to get back in time, so a commit is a complete state of your code base to which it would make sense to get back to. 13.1.2.2 push Once you’ve get a set of commits ready, you’re ready to push it to the server. In other word, you’ll permanently record these commits (so the series of changes) to the server. Making a push implies two things: Other people in the team will be able to retrieve the changes you’ve made These changes will be recorded permanently in the project history31. 13.1.2.3 pull Once changes have be recorded in the main server, everybody synchronized with the project can pull the commits to their local project. 13.1.3 About branches Branches are git way to organize work and ideas, and notably when several people are collaborating on the same project (which might be the case when building large web applications with R). How does it work? When your start a project, you’re in the main branch, which is called the “Master”. In a perfect world, you never work directly on this branch: it should always contain a working, deployable version of the application. One Other branches are to be thought as work areas, where developers fix bugs or add features. The modifications made in these dev branches will then be transferred (directly or indirectly) to the master branch. // TODO image about branching In practice, you might want to use a workflow where each branch is designed to fix a small issue or implement a feature, so that it’s easier to separate each small part of the work. 13.1.4 Issues If you are working with a remote tool like GitHub or GitLab, there’s a good change you’ll be using issues. Issues are “notes” that can be used to track a bug or to suggest a feature. This tools is crucial when it comes to project management: they are the perfect spot for organizing and discussing ideas, but also to have an overview of what has been done, what is currently done and what’s left to be done. Issue can also be used as a discussion medium with beta testers, clients or sponsors. One other valuable feature of issues is that they can be referenced inside commits. In other words, when you send code to the centralized server, you can link this code to one or more issues. 13.2 Git integration 13.2.1 With RStudio Git is very well integrated to the Rstudio IDE, and while working on your app using git can be as simple as clicking on a button from time to time. If you are using RStudio, you’ll find a pull/push button, a stage &amp; commit interface, a tool for visualizing diff in files. Everything you need to get started is there. 13.2.2 As part of a larger world Git is not reserved for team work: even if you are working alone on a project, using git is definitely worth the effort. Using git, and particularly issues, helps you organize your train of thoughts, especially upfront when you need to plan what you’ll be doing. And of course, remember that git isn’t reserved to Shiny Applications: it can be used for any other R related projects, and at the end of the day for any code related projects, making it a valuable skill to have in your toolbox, whatever language you’ll be working with in 10 years! 13.2.3 About git-flow // TODO 13.2.4 Further readings on git Git can be used in different ways and different approaches exist. The comprehensiveness of the different possible approaches is beyond the scope of this book, and other resources exist as well. We invite you to follow these different links: https://happygitwithr.com/ https://git-scm.com/book https://www.git-tower.com/blog/git-cheat-sheet/ 13.3 CI and testing Testing is central for making your application survive in the long run. The {testthat} package can be used to test the “business logic” side of your app, while the application features can be tested with packages like {shinytest}, or software like Katalon. // TO DO: more info about the tools + link to resources. "],
["stepdeploy.html", "Chapter 14 Send your app to production 14.1 Where to deploy your app 14.2 Before deployment Check-list", " Chapter 14 Send your app to production 14.1 Where to deploy your app // TODO 14.2 Before deployment Check-list 14.2.1 What to check on the app // TODO 14.2.2 What to check in the production envionment // TODO "],
["deploy-golem.html", "Chapter 15 Deploy with {golem} 15.1 Local deployment 15.2 Deploying Apps with {golem} 15.3 RStudio Environments 15.4 Docker", " Chapter 15 Deploy with {golem} 15.1 Local deployment // TODO 15.2 Deploying Apps with {golem} The dev/03_deploy.R file contains function for deploying on various plateforms. 15.3 RStudio Environments // TODO 15.4 Docker // TODO "],
["when-optimize.html", "Chapter 16 The Need for Optimization 16.1 Build first, then optimize 16.2 Tools for profiling", " Chapter 16 The Need for Optimization The most powerful optimization technique in any programmer’s toolbox is to do nothing. .right{ text-align: right;} The Art of Unix Programming 16.1 Build first, then optimize 16.1.1 Identifying bottlenecks As Donald Knuth puts it “Premature optimization is the root of all evil”. What does that means? That focusing on optimizing small portions of your app before making it work fully is the best way to lose time along the way. Even more if you’re not carefully using profiling tools: say your application is a little bit slow, or using too many memory, and you’ve got a specific bottleneck in your app. // TODO: diagram of an application bottleneck This is the very thing you should be optimizing: having faster code anywhere else expect this bottleneck won’t make your app faster—you’ll just make your app reach the bottleneck faster, but there will still be this part of your app that slows everything down. But it’s something you might only realize when the app is fully built: pieces might be fast together, but slow when put together. It’s also possible that the test dataset you’ve been using from the start works just fine, but when you try your app with a bigger, more realistic dataset, or maybe you’ve been using an example dataset so that you don’t have to query the database every time you implement a new feature, and the SQL query to the database is very slow. 16.1.2 Do you need faster functions? Optimizing an app is a matter of trade-offs: of course, in a perfect world, every piece of the app would be tailored to be fast, easy to maintain, and elegant. But in our world, you have deadlines, limited times, and we’re all but humans. That means that at the end of the day, your app won’t be completely perfect: a software can always be better. No piece of code has ever reached complete perfection. But do you want to spend 5 days out of the 30 you’ve planned optimizing a function so that it runs in a quarter of a second instead of half a second, then realize the critical bottleneck of your app is actually the SQL query and not the data manipulation? Of course a function runnning two times faster is a good thing, but think about it in context: for example, how many times is this function called ? We can safely bet that if your function is only called once, making it twice faster is a little bit too much, unless you have unlimited time to work on your project. And in that case lucky you, you can spend a massive amount of time building the perfect software. 16.1.3 Don’t sacrifice readability As said in the last section, every piece of code can be rewritten to be faster, either from R to R or using a lower level language: for example C or C++. You can also rebuild data manipulation code from one package to another, use complexe data structures to optimizing memory usage, etc, etc. But that comes with a price: not keeping thing simples for the sake of local optimization makes maintainance harder, even more if you’re using a lesser known language/package, which implies that you might be the only person alive being able to maintain a portion of code, or that your colleague taking over the project will have to spend hours learning the tools you’ve been building. So think about it: is local optimization worth the extra hours you’ll have to spend correcting bugs when the app will crash and when you’ll be the only one able to correct it? For example, let’s compare both these implementations of the same function, one in R, and one in C++. Of course, the C++ function is faster than the R one—this is the very reason of using C++ with R. Though, how much faster is worth the trade-off of being sure you’ll get someone in your team to take over the maintenance if needed? Using external languages or complex data structures implies that from the start, you’ll need to think about who and how your code base will be maintain over the years. library(&quot;Rcpp&quot;) cppFunction(&quot; double mean_cpp(NumericVector x) { int j; int size = x.size(); double res = 0; for (j = 0; j &lt; size; j++){ res = res + x[j]; } return res / size; }&quot;) bench::mark( cpp = mean_cpp(1:100), native = mean(1:100), iterations = 1000 ) # A tibble: 2 x 6 expression min median `itr/sec` mem_alloc `gc/sec` &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; 1 cpp 2.77µs 6.9µs 102534. 3.32KB 0 2 native 5.62µs 9.04µs 98388. 0B 0 (Note: we’ll come back on bench::mark in the next chapter) So, to sum up, there are three ways to optimize your application &amp; R code, and the bad news is that you’ can’t optimize for all of them: Optimizing for speed Optimizing for memory Optimizing for readability Leading a successful project means that you should, as much as possible, find the perfect balance between these three. 16.2 Tools for profiling 16.2.1 Profiling R code 16.2.1.1 Identifying bottlenecks The best way to profile R code is by using the {profvis} package32, a package designed to evaluate how much time each part of a function call take. That way, you can spot the bottleneck of your function, a task which would have to be done by guessing, which will, most of the time, come with bad guesses: One of the lessons that the original Unix programmers learned early is that intuition is a poor guide to where the bottlenecks are, even for one who knows the code in question intimately. .right{ text-align: right;} The Art of Unix Programming Using a tool like {profvis} allows to have a details view of what takes a long time to run in your R code. Here is how it works: x &lt;- function(){ profvis::pause(0.1) lapply(1:10, function(x){ x * 10 }) y() } y &lt;- function(){ profvis::pause(0.2) 1e4 * 9 z() } z &lt;- function(){ profvis::pause(0.3) print(&quot;hey&quot;) } profvis::profvis({ x() }) What you see now is what is called a flame graph: it’s a detailled timing of how your function has run. What you see on top is the expression evaluated, and on the bottom a detail of the call stack, with what looks like a Gantt diagram. This result reads as such: the wider the function call, the more time it has taken R to computer this piece of code. If you hover over one of the band, you’ll get more details about the function call timing. Here it is, now you have identified bottlenecks! 16.2.1.2 Benchmarking R Code Identifying bottlenecks is a start, but what to do now? In the chapter about optimization, we’ll dive deeper into common strategies for optimizing R &amp; Shiny code. But before that, remember this rule: never start optimizing if you can’t benchmark this optimization. Why? Because developers are not perfect and some optimization technics might lead to slower code. Of course, most of the time they won’t, but in some cases adopting optimization technics leads to writting slower code, because we’ve missed a bottleneck in our new code. And of course, without a clear documentation of what we are doing, we will be missing it, relying only on our intuition as an assurance of speed gain. In other words, if you want to be sure that you’re actually doing code optimization, be sure that you have a basis to compare with. How to do that? One thing that can be done is to keep an RMarkdown file with your starting point: use this notebook to keep track of what you’re doing, by noting where you’re starting from (i.e, what’s the original function you want to optimize), and compare it with the new one. By using an Rmd, you can also document the strategies you’ve been using to optimize the code: “switched from for loop to vectorize function”, “changed from x to y”, etc. And of course, you will need to time things. To do that, you can use the {bench} package, which compares the execution time (and other metrics) of two functions. x &lt;- function(size){ res &lt;- numeric(size) for (i in 1:size){ res[i] &lt;- i * 10 } return(res) } y &lt;- function(size){ (1:size) * 10 } bench::mark( `for` = x(1000), vectorized = y(1000), iterations = 1000 ) # A tibble: 2 x 6 expression min median `itr/sec` mem_alloc `gc/sec` &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt; 1 for 50.49µs 64.6µs 11048. 30.5KB 0 2 vectorized 8.75µs 11.1µs 49983. 11.8KB 0 Here, we have an empiric evidence that one code is faster than the other: by benchmarking the speed of our code, we are able to determine which function is the fastest. And, bonus point, {bench} takes time to check that the two outputs are the same, so that you’re sure that you’re not comparing apple and oranges! 16.2.2 Profiling Shiny // TODO "],
["optim-caveat.html", "Chapter 17 Common Application Caveats 17.1 Reactivity anti-patterns 17.2 R does too much 17.3 Reading data", " Chapter 17 Common Application Caveats 17.1 Reactivity anti-patterns 17.1.1 Reactivity is awesome… until it’s not Let’s face it, reactivity is awesome… until it’s not. Reactivity is a common source of confusion for beginners, and a common source of bugs and bottlenecks, even for seasoned Shiny developers. Most of the time, issues come from the fact that there is too much reactivity, i.e. we build apps where too much things happen, and some things are updated way more than they should, and computations are performed when they shouldn’t. Of course, it’s a nice feature to make everything react instantly to changes, but when building larger apps it’s easy to create monsters, i.e complicated, messy reactive graphs where everything is updated too much and too often. Or worse, we generate endless reactive loops. And the more you work on your app, the more complex it gets, and the more you’ll be likely to end up in the reactive inferno. In this section, we’ll be speaking a little bit about reactivity and how to have more control on it, and about a way to share data across modules without relying on passing along reactive objects. 17.1.2 observe vs observeEvent One of the most common feature of reactive inferno is the use of observe() in cases where you should use observeEvent. Spoiler: you should try to use observeEvent() as much as possible, and avoid observe()as much as possible. At first, observe() seems easier to implement, and feels like a shortcut as you don’t have to think about what to react to: everything gets updated without you thinking about it. But the truth is that this stairway doesn’t lead to heaven. Let’s stop and think about observe() for a minute. This function updates every time a reactive object it contains is invalidated. Y es, this works well if you have a small amount of reactive objects in the observer, but that gets tricky whenever you start adding things inside your observe(), as you might be launching a computation 10 times if your reactive scope contains 10 reactive objects that are somehow invalidated in chain. And believe me, we’ve seen pieces of code where the observe() contains hundreds of lines of code, with reactives objects all over the place. For example, let’s start with that: ## DON&#39;T DO GLOBAL VARIABLES, IT&#39;S JUST TO SIMPLIFY THE EXAMPLE i &lt;- 0 library(shiny) library(cli) ui &lt;- function(request){ tagList( textInput(&quot;txt&quot;, &quot;txt&quot;) ) } server &lt;- function(input, output, session){ observe({ i &lt;&lt;- i + 1 cat_rule(as.character(i)) print(input$txt) }) } shinyApp(ui, server) Oh, and then, let’s add a small selectInput i &lt;- 0 library(shiny) library(cli) ui &lt;- function(request){ tagList( textInput(&quot;txt&quot;, &quot;txt&quot;), selectInput(&quot;tolower&quot;, &quot;casse&quot;, c(&quot;lower&quot;, &quot;upper&quot;)) ) } server &lt;- function(input, output, session){ observe({ i &lt;&lt;- i + 1 cat_rule(as.character(i)) if (input$tolower == &quot;lower&quot;) { print(tolower(input$txt)) } else { print(tolower(input$txt)) } }) } shinyApp(ui, server) And, as time goes by, we add another control flow to our observe(): i &lt;- 0 library(shiny) library(cli) library(stringi) ui &lt;- function(request){ tagList( textInput(&quot;txt&quot;, &quot;txt&quot;), selectInput(&quot;tolower&quot;, &quot;casse&quot;, c(&quot;lower&quot;, &quot;upper&quot;)), checkboxInput(&quot;rev&quot;, &quot;reverse&quot;) ) } server &lt;- function(input, output, session){ observe({ i &lt;&lt;- i + 1 cat_rule(as.character(i)) if (input$rev){ x &lt;- stri_reverse(input$txt) } else { x &lt;- input$txt } if (input$tolower == &quot;lower&quot;){ print(tolower(x)) } else { print(tolower(x)) } }) } shinyApp(ui, server) And it would be nice to keep the selected values into a reactive list, so that we can reuse it elsewhere. And maybe you would like to add a checkbox so that the logs are printed to the console only if checked. i &lt;- 0 library(shiny) library(cli) library(stringi) ui &lt;- function(request){ tagList( textInput(&quot;txt&quot;, &quot;txt&quot;), selectInput(&quot;tolower&quot;, &quot;casse&quot;, c(&quot;lower&quot;, &quot;upper&quot;)), checkboxInput(&quot;rev&quot;, &quot;reverse&quot;) ) } server &lt;- function(input, output, session){ r &lt;- reactiveValues() observe({ i &lt;&lt;- i + 1 cat_rule(as.character(i)) if (input$rev) { r$x &lt;- stri_reverse(input$txt) } else { r$x &lt;- input$txt } if (input$tolower == &quot;lower&quot;){ r$x &lt;- tolower(r$x) } else { r$x &lt;- toupper(r$x) } }) } shinyApp(ui, server) Ok, now can you tell how many potential invalidation points we’ve got here? Three: whenever input$txt, input$rev or input$tolower change. Of course, three is not that much, but you get the idea. Let’s pause a minute and think about why we use observe() here. To update the values inside r$x, yes. But do we need to use observe() for, say, updating r$x under dozens of conditions, each time the user types a letter? I don’t think so. We generally want our observer to update its content under a small, controlled number of inputs, i.e. with a controlled number of invalidation points. And, what we often forget is that users don’t type/select correctly on the first try. No, they usually try and miss, restart, change things, amplifying the reactivity “over-happening”. Moreover, long observe() statements are hard to debug, and they make collaboration harder when the trigger to the observe logic can potentially lives anywhere between line one and line 257 of your observe(). That’s why (well, in 99% of cases), it’s safer to go with observeEvent, as it allows to see at a glanche what are the condition under which the content is invalidated and re-evalutaed. Then, if a reactive context is invalidated, you know why. 17.1.3 Building triggers and watchers // TODO So the general pattern is that one: we create “flags” with an init function, trigger these “flags” with trigger(), and wherever we want these flags to invalidate the reactive context, we watch() these flags. The idea here is to get a full control over the reactive flow: we only invalidate contexts when we want, making the general flow of the app more predictable. init &lt;- function(name, session = getDefaultReactiveDomain()){ session$userData[[name]] &lt;- reactiveVal(0) } trigger &lt;- function(name, session = getDefaultReactiveDomain()){ session$userData[[name]]( session$userData[[name]]() + 1 ) } watch &lt;- function(name, session = getDefaultReactiveDomain()){ session$userData[[name]]() } And, bonus, as these functions use the session object, they are available across all modules. That also means that you can easily trigger an event inside a model from another one. 17.1.4 Using R6 as a data storage One pattern we’ve also been playing with is storing the app business logic inside of one or more R6 objects. Why would we want to do that? 17.1.4.1 Sharing data accross module Sharing an R6 object makes it simpler but without the complexity of sharing &amp; handling reactive objects. So basically, the idea is to hold the whole logic of your data reading / cleaning / processing / outputing inside an R6 class. You’ll then initiate an instance of this class, then pass this object through your modules and submodules. nameui &lt;- function(id){ ns &lt;- NS(id) tagList( # [...] ) } name &lt;- function(input, output, session, obj){ ns &lt;- session$ns output$that &lt;- renderThis({ obj$compute() }) } library(shiny) ui &lt;- function(request){ tagList( nameui(&quot;nameui&quot;) ) } server &lt;- function( input, output, session ){ obj &lt;- MyDataProcess$new() callModule(name, &quot;nameui&quot;, obj) } shinyApp(ui, server) Of course, this makes sense if you’re combining it with the trigger / watch from before :) 17.1.4.2 Get sure it’s tested During the process of building a robust Shiny app, we strongly suggest that you test as many things as you can. This is where using an R6 for your business logic of your app makes sense: this allows you to build the whole testing of your application logic outside of any reactive context: you simply build unit tests just as any other function. 17.2 R does too much // TODO 17.3 Reading data // TODO "],
["optimizing-shiny-code.html", "Chapter 18 Optimizing Shiny Code 18.1 Optimizing R code 18.2 Caching elements 18.3 Paralellizing Shiny", " Chapter 18 Optimizing Shiny Code 18.1 Optimizing R code // TODO 18.2 Caching elements 18.2.1 What’s caching? Caching is the process of storing resources intensive results so that when they are needed again, your programm can reuse the result again without having to redo it another time. Let’s imagine that you know that you’ll need to use a phone number many time in the day, and for the purpose of this thought experiment you’re completly unable to remember it33. What are you going to do? There are two solutions here: either every time you need it you look in the phone book or in your phone contact list, making it so that it takes a couple of seconds every time, or you use a post-it that you put on your computer screen with the number of it, so that you have direct access to it when you need it. It takes a couple of seconds the first time you look for the number, but it’s almost instantaneous the next times you need it. This is what caching do: keep the result of computation so when they are needed in the very same context, they are quickly accessible. The downside being that you only have limited space on your screen: when your screen is covered by sticky notes, you can’t store any more notes34. In the context of an interactive application in a framework like Shiny, it makes much sense to cache data structures: users tend to repeat what they do, or go back and forth between parameters. For example, if you have a graph that take 2 seconds to render (which is quite common in Shiny), you don’t want these 2 seconds to be repeated over and over again when users switch from one parameter to another and back to the first, as the two graphs will be the same for the same parameter. Same goes for queries to a database: if a query is done with the same parameters, and you know that they will return the same result, there is no need to ask the database—ask the cache to retrieve the data. 18.2.2 Using caching in R At least two packages in R implement caching of functions (also called memoization): {memoize}, and {memoise}. They both more or less work the same way: you’ll call a memoization function on another function, and cache is created for this function. Then everytime you call this function again with the same parameters, the cache is returned instead of computing again. Here is a simple example with {memoise}: library(memoise) library(tictoc) fct &lt;- function(sleep = 1){ Sys.sleep(sleep) return(Sys.time()) } mfct &lt;- memoise(fct) tic() mfct(2) [1] &quot;2020-02-09 22:07:15 CET&quot; toc() 2.008 sec elapsed tic() mfct(2) [1] &quot;2020-02-09 22:07:15 CET&quot; toc() 0.078 sec elapsed Let’s try with another example that might look more like what we can find in a Shiny App: connecting to a database con &lt;- DBI::dbConnect( RSQLite::SQLite(), dbname = &quot;:memory:&quot; ) DBI::dbWriteTable( con, &quot;diams&quot;, dplyr::bind_rows( purrr::rerun(10, ggplot2::diamonds) ) ) fct_sql &lt;- function(SQL, con){ DBI::dbGetQuery( con, SQL ) } mfct &lt;- memoise(fct_sql) tic() res_a &lt;- mfct(&quot;SELECT * FROM diams WHERE cut = &#39;Ideal&#39;&quot;, con) toc() 0.795 sec elapsed tic() res_b &lt;- mfct(&quot;SELECT * FROM diams WHERE cut = &#39;Ideal&#39;&quot;, con) toc() 0.049 sec elapsed all.equal(res_a, res_b) [1] TRUE tic() res_c &lt;- mfct(&quot;SELECT * FROM diams WHERE cut = &#39;Good&#39;&quot;, con) toc() 0.217 sec elapsed setequal(res_a, res_c) [1] FALSE Note that you can change where the cache is stored by {memoise}. Here, we’ll save it in the temp directory, but don’t do this in production. tpd &lt;- fs::path(tempdir(), paste(sample(letters, 10), collapse = &quot;&quot;)) tpd &lt;- fs::dir_create(tpd) dfs &lt;- cache_filesystem(tpd) mfct &lt;- memoise(fct_sql, cache = dfs) res_a &lt;- mfct(&quot;SELECT * FROM diams WHERE cut = &#39;Ideal&#39;&quot;, con) res_b &lt;- mfct(&quot;SELECT * FROM diams WHERE cut = &#39;Good&#39;&quot;, con) fs::dir_ls(tpd) /var/folders/5z/rm2h62lj45d332kfpj28c8zm0000gn/T/Rtmpob5gM4/uviqtfgnpw/3c4685d12a0859c1 /var/folders/5z/rm2h62lj45d332kfpj28c8zm0000gn/T/Rtmpob5gM4/uviqtfgnpw/8455612d397f9296 As you can see, I now have two cache objects inside the directory I’ve specified as a cache_filesystem. 18.2.3 Caching Shiny At the time of writing this page (January 2020), {shiny} has one caching function: renderCachedPlot(). This function behaves more or less like the renderPlot() function, except that it is tailored for caching. The extra arguments you’ll find are cacheKeyExpr and sizePolicy: the former is the list of inputs and values that allow to cache the plot—conceptually, every time these values and inputs are the same, they produce the same graph. sizePolicy is a function that returns a width and an height, and which are used to round the plot dimension in pixels, so that not every pixel combination are generated in the cache. The good news is that converting existing renderPlot() functions to renderCachedPlot() is pretty straightforward in most cases: take your current renderPlot(), and add the cache keys35. Here is an example: library(shiny) ui &lt;- function(request){ tagList( selectInput(&quot;tbl&quot;, &quot;Table&quot;, c(&quot;iris&quot;, &quot;mtcars&quot;, &quot;airquality&quot;)), plotOutput(&quot;plot&quot;) ) } server &lt;- function( input, output, session ){ output$plot &lt;- renderCachedPlot({ plot( get(input$tbl) ) }, cacheKeyExpr = { input$tbl }) } shinyApp(ui, server) Listening on http://127.0.0.1:8268 If you try this app, the first rendering of the three plots will take a little bit of time, but every subsequent rendering of the plot is almost instantaneous. And if we apply what we’ve just sen with {memoise}: con &lt;- DBI::dbConnect( RSQLite::SQLite(), dbname = &quot;:memory:&quot; ) DBI::dbWriteTable( con, &quot;diams&quot;, dplyr::bind_rows( purrr::rerun(100, ggplot2::diamonds) ) ) fct_sql &lt;- function(cut, con){ # NEVER EVER SPRINTF AN SQL CODE LIKE THAT # IT&#39;S SENSITIVE TO SQL INJECTIONS, WE&#39;RE # DOING IT FOR THE EXAMPLE DBI::dbGetQuery( con, sprintf( &quot;SELECT * FROM diams WHERE cut = &#39;%s&#39;&quot;, cut ) ) %&gt;% head() } db &lt;- cache_filesystem(&quot;cache/&quot;) fct_sql &lt;- memoise(fct_sql, cache = db) ui &lt;- function(request){ tagList( selectInput(&quot;cut&quot;, &quot;cut&quot;, unique(ggplot2::diamonds$cut)), tableOutput(&quot;tbl&quot;) ) } server &lt;- function( input, output, session ){ output$tbl &lt;- renderTable({ fct_sql(input$cut, con) }) } shinyApp(ui, server) Listening on http://127.0.0.1:7319 Warning in gzfile(file, mode): cannot open compressed file &#39;cache//358a053661e48575&#39;, probable reason &#39;No such file or directory&#39; Warning: Error in gzfile: cannot open the connection You’ll see that the first time you run this piece of code, it will take a couple of seconds to render the table for a new input$cut value. But if you re-select this input a second time, the output will show instantaneously. Caching is a nice way to make your app faster: even more if you expect your output to be stable over time: if the plot created by a series of inputs stays the same all along your app lifecycle, it’s worth thinking about implementing an on-disk caching. If your application needs “fresh” data every time it is used, for example because data in the SQL database are updated every hour, cache won’t help you here, on the contrary: the same inputs on the function will render different output. Note thought that, just like our computer screen from before, you don’t have unlimited space when it come to storing cache:storing a large amount of cache will take space on your disk. For example, from our stored cache from before: fs::dir_info(tpd)[, &quot;size&quot;] # A tibble: 2 x 1 size &lt;fs::bytes&gt; 1 462.31K 2 1.86M Managing cache at a system level is out of scope for this book, but note that the most commonly accepted rule for deleting cache is called LRU, for Least Recently Used. The underlying principle of this approach is that users tend to need what they have needed recently: hence the more a piece of data has been used recently, the more likely it is that it will be needed soon. And this can be seen with: fs::dir_info(tpd)[, &quot;access_time&quot;] # A tibble: 2 x 1 access_time &lt;dttm&gt; 1 2020-02-09 22:07:23 2 2020-02-09 22:08:00 18.3 Paralellizing Shiny // TODO "],
["optimjs.html", "Chapter 19 Using JavaScript 19.1 A quick introduction to JavaScript 19.2 Client-side JavaScript 19.3 JavaScript &lt;-&gt; Shiny communication 19.4 About {golem} js functions 19.5 Learn more about JavaScript", " Chapter 19 Using JavaScript At its core, building a Shiny app is building a JavaScript app that can talk with an R session. This process is invisible to most Shiny developers, who usually do everything in R. And in the end, this is the case: most of the Shiny apps out there are written with R. In fact, when you are writing UI elements in Shiny, what you are actually doing is building a series of HTML tags, which are then linked to JavaScript events. Later on, when the app is running, these JavaScript events will communicate with R, in the sense that they will send data to R, and receive data from R. Most of the time, when these JavaScript events are receiving data, they modify the page the user sees. What happens under the hood is a little bit complex and out of scope for this book, but the general idea is: R talks to your browser through a web socket (that you can imagine as a small “phone line” with both software modules listening at each end36), and this browser talks to R through the same web socket. // TODO: create here a simple Flowchart // R -&gt; (Web Socket) -&gt; JS // R &lt;- (Web Socket) &lt;- JS It’s important to note here that the communication happens in both ways: from R to JavaScript, and from JavaScript to R. In fact, when we write a piece of code like sliderInput(&quot;plop&quot;, &quot;this&quot;, 1, 10, 5), what we are doing is creating a binding between JavaScript and R, where JavaScript listens to any event happening in the browser on the slider with the id &quot;plop&quot;, and whenever JavaScript detects that something happens to this element, something (most of the time its value) is sent back to R. With output$bla &lt;- renderPlot({}), what we are doing is making the two communicate the other way around: we are telling JavaScript to listen to any incoming data from R for the id &quot;bla&quot;, and whenever JavaScript sees incoming data from R, it puts it into the proper HTML tag (here, JavaScript inserts in the page the image received from R). So even if everything is written with R, we are writing a web application, i.e. HTML, CSS and JavaScript elements. Once you’ve realized that, the possibilities are endless: in fact almost anything doable in a “classic” web app can be done in Shiny. What this also implies is that getting (even a little bit) better at writing HTML, CSS, and especially JavaScript will make your app better, lighter, and more user-friendly, as JavaScript is a language that has been designed to interact with a web page: change element appearances, hide and show things, click somewhere, show alerts and prompts… Knowing just enough JavaScript can improve the quality of your app: especially when you’ve been using R to render some complex UIs: think conditional panels, simulating a button click from the server, hide and show elements… All these things are good examples of where you should be using JavaScript instead of building more or less complex renderUI or insertUI patterns in your server. Moreover, the number of JavaScript libraries available on the web is tremendous ; and the good news is that Shiny has everything it needs to bundle external JavaScript libraries inside your application37. This is what this section of the book aims at: giving you just enough JavaScript knowledge to lighten your Shiny App, in order to improve the global user and developer experience. In this part, we’ll first review some JavaScript basics which can be used “client-side” only, i.e. only in your browser, or by making R &amp; JS communicate with each other. In this section, we’ll also explore common patterns for JavaScript in Shiny. Finally, we’ll quickly present some of the functions from {golem} which are built on top of JavaScript. Note that this chapter is not supposed to be a comprehensive JavaScript course. External resources are linked all throughout this chapter and at the end if you want to dive deeper into JavaScript. 19.1 A quick introduction to JavaScript JavaScript is a programming language which has been designed to work in the browser38. There are three ways to include the JavaScript code inside your web app: As an external file, which is served to the browser alongside your main application page Inside a &lt;script&gt; HTML tag inside your page On a specific tag, for example by adding an onclick event straight on the tag Note that the good practice when it comes to include JavaScript is to add the code inside an external file. If you’re working with {golem}, including a JavaScript file is achieved via two functions: golem::add_js_file(&quot;name&quot;), which adds a standard JavaScript file, i.e. one which is not meant to be used to communicate with R. We’ll see in the first part of this chapter how to add JavaScript code there. golem::add_js_handler(&quot;name&quot;), which creates a file with a skeleton for Shiny handlers. We’ll see this second type of elements in the JavaScript &lt;-&gt; Shiny communication part. OK, good, but what do we do now? 19.1.1 Understanding html, class, and id You have to think of a web page as a tree, where the top of the webpage is the root node, and every element in the page is a node in this tree (this tree is called a DOM, for Document Object Model). You can work on any of these HTML nodes with JavaScript: modify it, bind to it and/or listen to events, hide and show… But first, you have to find a way to identify these elements: either as a group of elements or as a unique element inside the whole tree. That’s what html semantic elements, classes, and ids are made for. Consider this piece of code: library(shiny) fluidPage( titlePanel(&quot;Hello Shiny&quot;), actionButton(&quot;go&quot;, &quot;go&quot;) ) &lt;div class=&quot;container-fluid&quot;&gt; &lt;h2&gt;Hello Shiny&lt;/h2&gt; &lt;button id=&quot;go&quot; type=&quot;button&quot; class=&quot;btn btn-default action-button&quot;&gt;go&lt;/button&gt; &lt;/div&gt; This {shiny} code creates a piece of HTML code containing three nodes: a div with a specific class (a BootStrap container), an h2, which is a level-two header, and a button which has an id and a class. Both are included in the div. Let’s detail what we’ve got here: HTML tags, which are the building blocks of the “tree”: here div, h2 and button are HTML tags. The button has an id, which is short for “identifier”. This id has to to be unique: this reference allows to refer to this exact element, and more specifically, it allows JavaScript and R to talk to each other: if you click on a button, you have to be sure you are referring to this specific button, and only that one. Elements can have a class which can apply to multiple elements. This can be used in JavaScript, but it’s also very useful for styling elements in CSS. 19.1.2 About jQuery &amp; jQuery selectors The jQuery framework is natively included in Shiny. jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use API that works across a multitude of browsers. .right{ text-align: right;} jQuery home page jQuery is a very popular JavaScript library which is designed to manipulate the DOM, its events and its elements. It can be used to do a lot of things, like hide and show, change class, click somewhere… And to be able to do that, it comes with the notion of selectors, which will be put between $(). You can use, for example: $(&quot;#plop&quot;) to refer to the element with the id plop $(&quot;.pouet&quot;) to refer to element(s) of class pouet $(&quot;button:contains('this')&quot;) to refer to the buttons with a text containing 'this' You can also use special HTML attributes, which are specific to a tag. For example, the following HTML code: &lt;a href = &quot;https://thinkr.fr&quot; data-value = &quot;panel2&quot;&gt;ThinkR&lt;/a&gt; contains the href &amp; data-value attributes. You can refer to these with [] after the tag name. $(&quot;a[href = 'https://thinkr.fr']) refers to link(s) with href being https://thinkr.fr $('a[data-value=&quot;panel2&quot;]') refers to link(s) with data-value being &quot;panel2&quot; These and other selectors are used to identify one or more node(s) in the big tree which is a web page. Once we’ve identified these elements, we can either extract or change data contained in these nodes, or invoke methods contained within these nodes. Indeed JavaScript, as R, can be used as a functional language, but most of what we do is done in an object-oriented way. In other words, you’ll interact with objects from the web page, and these objects will contain data and methods. Note that this is not specific to jQuery: elements can also be selected with standard JavaScript. jQuery has the advantage of simplifying selections and actions and to be cross-platform, making it easier to ship applications that can work on all major browsers. And it comes with Shiny for free! 19.2 Client-side JavaScript It’s hard to give an exhaustive list of what you can do with JavaScript inside Shiny. As a Shiny app is part JavaScript, part R, once you’ve got a good grasp of JavaScript you can quickly enhance any of your applications. That being said, a few common things can be done that would allow you to immediately optimize your application: i.e. small JavaScript functions that will prevent you from writing complex algorithmic logic in your application server. 19.2.1 Common patterns $('#id').show(); and $('#id').hide(); show and hide one or more elements that match the given selector. For example, this can be use to replace: output$ui &lt;- renderUI({ if (this){ tags(...) } else { NULL } }) alert(&quot;message&quot;) uses the built-in alert-box mechanism from the user’s browser (i.e., the alert() function is not part of jQuery but it’s built inside the user’s browser). It works well as it relies on the browser instead of relying on R or on a specific JavaScript library. You can use this functionality to replace a call to {shinyalert}: the result is a little less aesthetically pleasing, but that’s easier to implement and maintain. var x = prompt(&quot;this&quot;, &quot;that&quot;); this function opens the built-in prompt, which is a text area where the user can input text. With this code, when the user clicks “OK”, the text is stored in the x variable, which you can then send back to R (see further part down this chapter for more info on how to do that). This can replace something like the following: mod &lt;- function() { modalDialog( tagList( textInput(ns(&quot;info&quot;), &quot;Your info here&quot;) ), footer = tagList( modalButton(&quot;Cancel&quot;), actionButton(ns(&quot;ok&quot;), &quot;OK&quot;) ) ) } observeEvent(input$show, { showModal(mod()) }) observeEvent(input$ok, { removeModal() }) $('#id').css('color', 'green'); changes the CSS attributes of the selected element(s). Here, we’re switching to green on the #id element. $(&quot;#id&quot;).text( &quot;this&quot; ); changes the text content to “this”. This can be used to replace output$ui &lt;- renderUI({ if (this){ tags$p(&quot;First&quot;) } else { tags$p(&quot;Second&quot;) } }) $(&quot;#id&quot;).remove(); completely removes the element from the DOM. IT can be used as a replacement for shiny::removeUI(), or as a conditional UI. 19.2.2 Where to put them - introduction to JavaScript events OK, now that we’ve got some ideas about JS code that can be used in Shiny, where do we put them? HTML and JS have a concept called events, which are… well events that happen when the user manipulates the webpage: when the user clicks, hovers (the mouse goes over an element), presses the keyboard… All these events can be used to trigger a JavaScript function. Here are some examples of adding JavaScript functions to DOM events: +onclick The onclick attribute can be added straight inside the HTML tag when possible: tags$button( &quot;Show&quot; onclick = &quot;$(&#39;#plot&#39;).show()&quot; ) Or with shiny::tagAppendAttributes: plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alert(&#39;hello world&#39;)&quot; ) Here is for example a small Shiny app that implements this behavior: library(shiny) library(magrittr) ui &lt;- function(request){ fluidPage( plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alert(&#39;iris plot!&#39;)&quot; ) ) } server &lt;- function(input, output, session){ output$plot &lt;- renderPlot({ plot(iris) }) } shinyApp(ui, server) You can find a real Life example of this tagAppendAttributes in the {tidytuesday201942} app: R/mod_dataviz.R#L109, where the click on the plot generates the creation of a Shiny input (we’ll see this below) That, of course, works well with very small JavaScript code. For longer JavaScript code, you can write a function inside and external file, and add it to your app. In {golem}, this works by launching the add_js_file(&quot;name&quot;), which will create a .js file. You’ll then need to add this function using tags$script(src=&quot;www/name.js&quot;) inside golem_add_external_resources() in R/app_ui.R file. This, for example, could be: inst/app/www/script.js function alertme(id){ // Asking information var name = prompt(&quot;Who are you?&quot;); // Showing an alert alert(&quot;Hello &quot; + name + &quot;! You&#39;re seeing &quot; + id); } Then: plotOutput( &quot;plot&quot; ) %&gt;% tagAppendAttributes( onclick = &quot;alertme(&#39;plot&#39;)&quot; ) Inside this inst/app/www/script.js, you can also attach a new behavior with jQuery to one or several elements. For example, you can add this alertme / onclick behavior to all plots of the app: function alertme(id){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! You&#39;re seeing &quot; + id); } /* We&#39;re adding this so that the function is launched only when the document is ready */ $(function(){ // Selecting all Shiny plots $(&quot;.shiny-plot-output&quot;).on(&quot;click&quot;, function(){ /* Calling the alertme function with the id of the clicked plot */ alertme(this.id); }); }); Then, all the plots from your app will receive this on-click event39. Note that there is a series of Shiny events which are specific to Shiny but that can be used just like the one we’ve just seen: function alertme(){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! Welcome to my app&quot;); } $(function(){ // Waiting for Shiny to be connected $(document).on(&#39;shiny:connected&#39;, function(event) { alertme(); }); }); See JavaScript Events in Shiny for the full list of JavaScript events available in Shiny. 19.3 JavaScript &lt;-&gt; Shiny communication Now that we’ve seen some client-side optimization, i.e. R doesn’t do anything with these events when they happen (in fact R is not even aware they happened), let’s now see how we can make these two communicate with each other. 19.3.1 From R to JavaScript Calling JS from the server side (i.e from R) is done by defining a series of CustomMessageHandler: these are functions with one argument that can then be called using the session$sendCustomMessage() method from the server. You can define them using this skeleton: $( document ).ready(function() { Shiny.addCustomMessageHandler(&#39;fun&#39;, function(arg) { }) }); This skeleton is the one generated by golem::add_js_handler(&quot;plop&quot;). Then, it can be called from server-side with: session$sendCustomMessage(&quot;fun&quot;, list()) Note that the list() argument from your function will be converted to JSON, and read as such from JS. In other words, if your have an argument called x, and you call the function with list(a = 1, b = 12), then in JS you’ll be able to use x.a and x.b. For example: In inst/app/www/script.js Shiny.addCustomMessageHandler(&#39;computed&#39;, function(mess) { alert(&quot;Computed &quot; + mess.what + &quot; in &quot; + mess.sec + &quot; secs&quot;); }) Then in R: observe({ deb &lt;- Sys.time() # Do the computation for id Sys.sleep( sample(1:5, 1) ) session$sendCustomMessage( &quot;computed&quot;, list( what = &quot;plop&quot;, sec = round(Sys.time() - deb) ) ) }) 19.3.2 From JavaScript to R How to do the other way around (from JS to R)? Shiny apps, in the browser, contain an object called Shiny, which can be used to send values to R, by creating an IputValue. For example, with: Shiny.setInputValue(&quot;rand&quot;, Math.random()) you’ll bind an input that can be caught from the server side with: observeEvent( input$rand , { print( input$rand ) }) This Shiny.setInputValue can of course be used inside any JavaScript function. Here is a small example wrapping some of the things we’ve seen previously: In inst/app/www/script.js function alertme(){ var name = prompt(&quot;Who are you?&quot;); alert(&quot;Hello &quot; + name + &quot;! Welcome to my app&quot;); Shiny.setInputValue(&quot;username&quot;, name) } $(function(){ // Waiting for Shiny to be connected $(document).on(&#39;shiny:connected&#39;, function(event) { alertme(); }); $(&quot;.shiny-plot-output&quot;).on(&quot;click&quot;, function(){ /* Calling the alertme function with the id of the clicked plot */ Shiny.setInputValue(&quot;last_plot_clicked&quot;, this.id); }); }); These events (getting the user name and the last plot clicked), can then be caught from the server side with: observeEvent( input$username , { cli::cat_rule(&quot;User name:&quot;) print(input$username) }) observeEvent( input$last_plot_clicked , { cli::cat_rule(&quot;Last plot clicked:&quot;) print(input$last_plot_clicked) }) Which will give: &gt; golex::run_app() Loading required package: shiny Listening on http://127.0.0.1:5495 ── User name: ───────────────────────────────────────────────────── [1] &quot;Colin&quot; ── Last plot clicked: ───────────────────────────────────────────── [1] &quot;plota&quot; ── Last plot clicked: ───────────────────────────────────────────── [1] &quot;plopb&quot; Important note: if you’re using modules, you’ll need to pass the namespacing of the id to be able to get it back from the server. This can be done using the session$ns function, which comes by default in any golem-generated module. In other words, you’ll need to write something like: $( document ).ready(function() { Shiny.addCustomMessageHandler(&#39;whoareyou&#39;, function(arg) { var name = prompt(&quot;Who are you?&quot;) Shiny.setInputValue(arg.id, name); }) }); mod_my_first_module_ui &lt;- function(id){ ns &lt;- NS(id) tagList( actionButton( ns(&quot;showname&quot;), &quot;Enter your name&quot; ) ) } mod_my_first_module_server &lt;- function(input, output, session){ ns &lt;- session$ns observeEvent( input$showname , { session$sendCustomMessage( &quot;whoareyou&quot;, list( id = ns(&quot;name&quot;) ) ) }) observeEvent( input$name , { cli::cat_rule(&quot;Username is:&quot;) print(input$name) }) } 19.4 About {golem} js functions {golem} comes with a series of JavaScript functions that you can call from the server. These functions are added by default with golem::activate_js() in app_ui. Then they are called with golem::invoke_js(&quot;function&quot;, &quot;element&quot;). This element can be one of a series of elements (most of the time scalar elements) which can be used to select the DOM node you want to interact with. It can be a full jQuery selector, an id or a class. Note that you can pass multiple elements, with invoke_js ... parameters 19.4.1 golem::invoke_js() showid &amp; hideid, showclass &amp; hideclass show and hide elements through their id or class. golem::invoke_js(&quot;showid&quot;, ns(&quot;plot&quot;)) showhref &amp; hidehref hide and show a link by trying to match the href content. golem::invoke_js(&quot;showhref&quot;, &quot;panel2&quot;) clickon click on the element. You have to use the full jQuery selector. show &amp; hide show and hide elements, using the full jQuery selector. See ?golem::activate_js for a full list of built-in functions. 19.5 Learn more about JavaScript We have written an online, freely available bbok about Shiny &amp; JavaScript. You’ll find it at http://connect.thinkr.fr/js4shinyfieldnotes/ Here is a list of external resources to learn more about JavaScript: 19.5.1 JavaScript basics Mozilla JavaScript w3schools JavaScript Free Code Camp JavaScript For Cats Learn JS 19.5.2 jQuery jQuery Learning Center w3schools jQuery 19.5.3 Intermediate / advanced JavaScript Eloquent JavaScript You Don’t Know JS Yet "]
]
