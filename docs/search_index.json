[
["index.html", "Building Big Shiny Apps - A Workflow Chapter 1 Motivation", " Building Big Shiny Apps - A Workflow Colin Fay 2019-04-07 Chapter 1 Motivation The idea behind this book is not to talk about how to deploy and scale, but about the process of building the app. Why? Lots of blog posts and books talk about putting apps in production. Very few talks about working on building these apps. This is why I choose to talk about the process, workflow, and tools we use at ThinkR when building big Shiny Apps. So, to sum up, we‚Äôll not talk about what to do when the app is ready, we‚Äôll talk about how to make it ready. "],
["bigshinyapp.html", "Chapter 2 About Big Shiny Apps", " Chapter 2 About Big Shiny Apps If you‚Äôre reading this page, chances are you already know what a Shiny App is ‚Äî a web application that communicates with R, built in R, and working with R. Almost anybody can create a prototype for a small data product in a matter of hours. And no knowledge of HTML, CSS or JavaScript is required, making it really easy to use ‚Äî you can rapidly create a POC. But what to do now you want to build a big Shiny App? What‚Äôs a big Shiny App? Well, first, one that includes several thousand lines of code (R and others). It‚Äôs also one that is potentially developed by several coders, working on the same application at the same time. It‚Äôs an application where scaling matters. Maintainability and ease of upgrading are important. In many cases, Shiny Apps in production are not used by ‚Äútech literate‚Äù people. People rely on this application for making real-world decisions, with real consequences. "],
["challenges.html", "Chapter 3 Challenges 3.1 Finding a good UI (and stick with it) 3.2 Working as a team", " Chapter 3 Challenges 3.1 Finding a good UI (and stick with it) Choosing a UI is hard ‚Äî we have a natural tendency, as coders, to be focused on the backend, i.e the algorithmic part of the application. But let‚Äôs state the truth: no matter how complex and innovative your backend can be, your application is bad if your UI is bad. That‚Äôs the hard truth. If people can‚Äôt understand how to use your application, your application doesn‚Äôt work. No matter how incredible the backend is. Try to find a simple, and efficient UI. One that people can understand and use in a matter of seconds. Don‚Äôt implement features or visual elements that are not actually needed, just ‚Äúin case‚Äù. And spend time working on that UI, really thinking about what visual elements you are implementing. 3.2 Working as a team Big Shiny Apps usually mean that several people will work on the application. For example, at ThinkR, 3 to 4 people usually work on the application. So, how do we organize that? 3.2.1 From the tools point of view: Use version control (not sure I have to expand on that topic ;) ) Think of your shiny app as a tree, and divide it as much as possible into little pieces. Then, create one Shiny module by piece. This allows you to split the work, and also to have smaller files ‚Äî it‚Äôs easier to work on 20 files of 200 lines than on one big app.R file. 3.2.2 From the organisational point of view Define one person in charge of having the big picture of the app. This person will kick off the project, and write the skeleton of the app, with the good modules and files structure. This person will also be in charge of accepting new merge requests from other developers, and to orchestrate the master and dev branches. List the tasks, and open one issue for each task on your version control system. Each issue will be solved in a separate branch. Finally, assign one module to one developer ‚Äî if it seems that working on one module is a two-person job, divide again into two other submodules. This is a relatively complex task, as the output of one module influences the input of another, so be sure to assign them well. 3.2.3 Making the app production ready This includes two things: scaling and maintaining. As said in the disclaimer, I won‚Äôt expand on the topic of scaling, as many have written about that, but here is one piece of advice: make the R process running the app do as little as possible, and in particular prevent it from doing what it‚Äôs not supposed to do. Which includes: use JavaScript so that the client browser renders things (instead of making R do the work ‚Äî basic JS is easy to learn), use parallelization and async, and if possible, make the heavy lifting be done outside the R session running the app. Maintainance, on the other hand, is something to think about from the beginning. It includes being able to ensure that the application will work in the long run, and that new features can be easily implemented. Working in the long run: separate the code with ‚Äúbusiness logic‚Äù (aka the data manipulation and the algorithm, that can work outside the context of the app) from the code building the application. That way, you can write regression tests for these functions to ensure they are stable. Implement new elements: as we are working with modules, it‚Äôs easy to insert new elements inside the global application. "],
["stepbystep.html", "Chapter 4 Step by step 4.1 Step 1: Design 4.2 Step 2: Prototype 4.3 Step 3: Build 4.4 Step 4: Secure 4.5 Step 5: Deploy", " Chapter 4 Step by step 4.1 Step 1: Design Don‚Äôt rush into coding. I know you want to, because it‚Äôs what we like to do and what we are good at. But before entering the coding marathon, take time to think about the application and the way it will be deployed and used. Take a pen and a piece of paper and draw the app. Talk about it with the people who will use the app, just to decipher what they actually need. Take a moment to talk with the IT team. Here are some example questions you can ask: ‚ÄúWho are the end users of the app?‚Äù ‚Äî This will help you know if the end users are tech literate or not, and what they aim to achieve with the app. ‚ÄúHow frequently will they use the app?‚Äù ‚Äî The details of the design &amp; the UI of the app you use every day is more crucial than when the app is used once a month. ‚ÄúWhat level of complexity and personalization do the users really need?‚Äù ‚Äî People writing app specifications sometimes want more functionality than what is actually needed by the users. ‚ÄúWhat level of interactivity do you want, and to what extent is it central?‚Äù ‚Äî People love interactive graphs and like when things automatically sync with each other. Yet these two can make the app slower, without any significant gain. For example, being reactive to a selectInput() or a sliderInput() can lead to too much computation: maybe the user will not succeed to choose the right input the first, second or third time‚Ä¶ So let them do their choice, and add a button. ‚ÄúHow important is it that the app is fast?‚Äù ‚Äî Should you spend a lot of time optimizing the little things? etc. Asking questions, taking notes, and drawing the app help you have a good idea of what is expected and what you have to do now. 4.2 Step 2: Prototype I like to go ‚ÄúUI first‚Äù. For two main reasons: Once the UI is set, there is no ‚Äúsurprise implementation‚Äù. Once we agree on what elements there are in the app, there is no sudden ‚Äúoh the app needs to do that now‚Äù. A pre-defined UI allows every person involved in the coding to know which part of the app they are working on. In other words, when you start working on the backend, it‚Äôs much easier to work on a piece you can visually identify and integrate in a complete app scenario. So yes, spend time writing a front-end prototype in lorem ipsum. And good news, we‚Äôve got a tool for you: it‚Äôs called {shinipsum}. The main goal of this package is to create random Shiny elements that can be used to draw a UI, without actually doing any heavy lifting in the backend. Hence, once you‚Äôve got a draft of your app on a piece of paper, you can then move to the ‚Äúipsum-UI‚Äù stage: building the front-end of the app, and filling it with random Shiny elements, with functions like random_ggplot() or random_DT(). Another package that can be used to do that is {fakir}. This package is designed to create fake data frames, primarily for teaching purposes, but it can also be used for inserting data into a shiny prototype. 4.3 Step 3: Build Now the UI and the features are set, time to work on the backend üéâ This part is pretty standard ‚Äî everybody can now work on the implementation of the functions that process the app inputs, in their own modules. As the UI, functionalities and modules have been defined in the previous steps, everyone (well, in theory) knows what they have to work on. And also, as said before, there should be no ‚Äúsurprise implementation‚Äù, as the app has been well defined before. 4.4 Step 4: Secure Securing your app means two things: testing, and locking the application environment. So first, be sure to include tests all along the building process ‚Äî just like any other R code. As the app is contained in a package, you can use standard testing tools for testing the business logic of your app ‚Äî as said in the first part, it‚Äôs important to split the backend functions and algorithm from the user interface. That means that these backend functions can run outside of the application. And yes, if they can run outside of the app, they can be tested the standard way, using {testthat}. When it comes to testing the front end, you can try the {shinytest} package from RStudio, if you need to be sure there is no visual regression all along the project development. {shinyloadtest}, on the other hand, tests how an application behaves when one, two, three, twenty, one hundred users connect to the app, and gives you a visual report about the connection and response time of each session. One other tool I like to use is Katalon Studio. It‚Äôs not R related, and can be used with any kind of web app. How it works is quite simple: it opens your browser where the Shiny app runs, and record everything that happens. Once you stop the recording, you can relaunch the app and it will replay all the events it has recorded. And of course, you can specify your own scenario, define your own events, etc. It‚Äôs not that straightforward to use, but once you get a good grasp of how it works, it‚Äôs a very powerful tool. Secondly, secure your app means that it can be deployed again any time in the future ‚Äî in other words, you have to ensure you‚Äôve got a proper handle on the required R version, and of the package versions which are required to run your app. That means that you have to be aware that upgrading a package might break your app ‚Äî so, provide an environment that can prevent your app from breaking when a package gets updated. For that, there is, of course, Docker, R specific tools like {packrat}, or deploying custom CRAN repositories or package manager. 4.5 Step 5: Deploy Tools for deployment are not the subject of this blog post so I won‚Äôt talk about this in detail (remember, we are talking about building üòâ ), but our two tools of choice are Docker &amp; ShinyProxy, and RStudio Connect. "],
["golem.html", "Chapter 5 Using Golem", " Chapter 5 Using Golem Ok, that‚Äôs a lot of things to process. Is there a tool that can help us simplify this workflow? Of course there is, and it‚Äôs called {golem}. It can be found at https://github.com/ThinkR-open/golem {golem} is an R package that implements an opinionated framework for building production-ready Shiny apps. It all starts with an RStudio project, which contains a predefined setup for building your app. The idea is that with {golem}, you don‚Äôt have to focus on the foundation of your app, and can spend your time thinking about what you want to do, not about how to do it. It‚Äôs built on top of the working process we‚Äôve developed at ThinkR, and tries to gather in one place the functions and tools we‚Äôve created for building applications designed for production. When you open a golem project, you‚Äôll start with a dev-history file, which contains a series of functions that will guide you through the whole process of starting, building, and deploying your app. The newly created package also contains an app_ui.R and app_server.R waiting to be filled, and a run_app() function that will launch your application. Any new module can be added with golem::add_module(), a function that creates a new file with the required skeleton for a shiny module. As I said, you don‚Äôt need to think about the technical things. You can also find a series of UI, server, and prod-related tools, functions for creating deployment scripts, and other cool stuffs. Check the README for more information. "],
["tools.html", "Chapter 6 Tools 6.1 {shinipsum} and {fakir}:", " Chapter 6 Tools 6.1 {shinipsum} and {fakir}: These two tools allow you to prototype a Shiny App and to go ‚ÄúUI first‚Äù. Learn more : https://github.com/ThinkR-open/shinipsum https://github.com/ThinkR-open/fakir "],
["tooling.html", "Chapter 7 Tools 7.1 Package 7.2 Git 7.3 Shiny modules 7.4 {shinipsum} and {fakir}: 7.5 CI and testing 7.6 Deploy", " Chapter 7 Tools 7.1 Package Shiny Apps are to be put into a package. Why? Because it allows them to be documented, tested, and installed in different environments. 7.2 Git Friends don‚Äôt let friends work on a coding project without version control. 7.3 Shiny modules Shiny modules are crucial tools when it comes to building big shiny apps: they allow to collaborate, to split the work into pieces, they facilitate testing, and they allow implementation of new features to be made more easily. 7.4 {shinipsum} and {fakir}: These two tools allow you to prototype a Shiny App and to go ‚ÄúUI first‚Äù. Learn more : https://github.com/ThinkR-open/shinipsum https://github.com/ThinkR-open/fakir 7.5 CI and testing Testing is central for making your application survive in the long run. The {testthat} package can be used to test the ‚Äúbusiness logic‚Äù side of your app, while the application features can be tested with packages like {shinytest}, or software like Katalon. 7.6 Deploy Docker, Shiny Proxy, RStudio Connect‚Ä¶ Don‚Äôt just put your app on the server and let it live. Use tools that are specifically designed for deploying and scaling web applications. "]
]
