[
["successfulshinyapp.html", "Chapter 1 About Successful Shiny Apps 1.1 A (very) short introduction to Shiny 1.2 What’s a complex Shiny App? 1.3 What’s a successful Shiny App?", " Chapter 1 About Successful Shiny Apps If you’re reading this page, chances are you already know what a Shiny App is — a web application that communicates with R, built in R, and working with R. The beauty of {shiny} is that it makes it easy for anybody tp create a small app in a matter of hours. With small and simple Shiny apps, no knowledge of HTML, CSS or JavaScript is required, which makes it really easy to use — you can rapidly create a POC for a data-product and showcase an algorithm or present your results with an elegant, simple to build user interface. 1.1 A (very) short introduction to Shiny // TODO 1.2 What’s a complex Shiny App? 1.2.1 Reaching the cliff of complexity Things are quite simple when it comes to small prototypes or proof of concepts. But things change when your application reach “the cliff of complexity”: when your app is big enough in term of size and in term of functionality so you can not reason about your whole app at once, and you need to rely on tools to handle this complexity. 1.2.2 With great complexity comes great responsabilities When your program reaches this state, there is a lot of potential for failure, be it from a developer perspective or from a user point of view. For the code, bugs are harder to anticipate: it’s hard to think about all the different path the software can follow, it’s hard to detect bug because they are deeply nested in the numerous routines the app is doing. It’s also hard to think about what the state of your at a given moment in time because of the numerous inputs and output your app contains. From the user perspective, the more complex an app, the more important the learning curve is. Which means that the user will have to invest time learning how the app works, and will be even more disappointed if ever they realise this time has been a waste. 1.2.3 Production Grade Software Engineering Complexity is still frowned upon by a lot of developers, notably because it has been seen as something to avoid according to the Unix philosophy. But there are dozens of reason why an app can become complex: for example, the question your app is answering to is quite a complicated question which involves a lot of computation and routines, the app is rather ambitious and implement a lot of features, etc. So yes, there is a chance that if you’re reading this page, you’re working or are planning to work on a complex Shiny app. And this is not necessarily a bad thing. Shiny apps can definitely be used to implement a production-grade 1 software, but production-grade software implies production-grade software engineering. And your goal to make this project a succes is be to prepared, to use tool that will reduce the complexity of your app, and ensure that your app has the quality to age well. In other words, production-grade Shiny apps require to work with a software engineering mindset. Which is not always that easy a task in the R world. R comes from the land of the academics and is still used a lot as an “experiementation tool”, and in context where production quality is one of the least concerns. Many developers in the R world have learned R as a tool for making statistics, not as a tool for building softwares. Both these contexts are very different and require different mindsets, different skills and tools. With {shiny}, as we said before, it’s quite easy to prototype a simple app, without any “hardcore” software engineering skills. And when we’re happy with our little proof of concept, we’re tempted to add something new. And another. And another. And without any structured methodology, we’re almost certain that we’ll reach the cliff of complexity very soon, with a code base that is hardly (if ever) ready to be refactored to be sent to production. The good news is that building a complex app with R (or with any other language) is not an impossible task. But it requires planning, rigor, and correct tooling. This is what this book is about: how to organise your Shiny App project in a way that is time and code efficient, and how to get the correct tooling for making your application a success. 1.3 What’s a successful Shiny App? Another good news is that your application does not have to be complexe to be successful. Even more, in a world where “less is more”, the more you can reduce your application complexity, the more you’ll be prepared for success. So what’s a successful Shiny app? Defining such a metric is not that easy a task, but we can extract some common patterns when it comes to applications that can be listed as successful. 1.3.1 It exists First of all, an app is successful if it was delivered. In other words, the developer team was able to move from specification to implementation to testing to delivering. This is a very engineering-oriented definition of success, but that’s a pragmatic one: an app that never reaches the state of usability is not a successful app, as something along the way has blocked the process of finishing the code. This implies a lot of things: but mostly it implies that the team was able to organise itself in an efficient way, so that they were able to work together in making the project a success. And anybody that has already work on a code base as a team knows it’s not an easy task. 1.3.2 It’s accurate The app was delivered, and it answers the question it is supposed to answer, or serves the purpose it is supposed to serve. Delivering is not the only thing to keep in mind: you can deliver a working app but it doesn’t work in the way it is supposed to work. Just as before, accuracy means that between the moment the idea appears in someone’s mind and the moment the app is actually ready to be used, everybody was able to work together toward a common goal. 1.3.3 It’s usable The app was delivered, it answers the question it is supposed to answer, and it is friendly on the user. Unless you’re coding for the sake of the art, there will always be one or more end user(s). And if these person can’t use the app because it’s too hard to use, too hard to understand, because it’s too slow or there is no inerhent logic in the way the user experience is designed, then it’s hard to tell the app is a success. 1.3.4 It’s immortal Of course that’s a little bit far fetched, but when designing the app, you should set the ground for robustness in time and aim at a (theoretical) immortality of the app. Planning for the future is a very important component of a successful Shiny App project. Once the app is out, it’s successful if it can exist on the long run, with all the hasards that it implies: new package versions that potentially break the code base, implementation of new features in the global interface, changing key features of the UI or the back-end, and not to mention passing the code base along to someone who has not worked on the first version, and who is now in charge of working on version 2. And this, again, is hard to do without effective planning and efficient tooling. Well, and this new person might simply be you, month from now. And &quot;You’ll be there in the future too, maintaining code you may have half forgotten under the press of more recent projects. When you design for the future, the sanity you save may be your own.2 By production-grade, we mean a software that can be used in a context where people use it for doing their job, and where failures or bug have real-life consequences↩ The Art of Unix Programming, Eric Steven Raymond↩ "]
]
