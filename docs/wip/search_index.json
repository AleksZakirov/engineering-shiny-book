[
["index.html", "Building Big Shiny Apps - A Workflow Introduction Motivation Book structure About the authors Want to help? Other resources Acknowledgments", " Building Big Shiny Apps - A Workflow Colin Fay, Vincent Guyader, Cervan Girard, Sébastien Rochette 2019-09-13 Introduction This book is still at a Work in Progress stage. Motivation This book will not get you started with Shiny, nor talk about how to deploy into production and scale your app. What we’ll see is the process of building the app. Why? Lots of blog posts and books talk about starting to use shiny or putting apps in production. Very few (if any) talk about this grey area between getting started and pushing into production. So this is what this book is going to talk about: building Shiny application. We’ll focus on the process, the workflow, and the tools we use at ThinkR when building big Shiny Apps. Hence, if you’re starting to read this book, we assume you have a working knowledge of how to build a small application, and want to know how to go one step further. Book structure Part 1 (Building big Shiny Apps) gives a general context about what is a successful Shiny Apps and what challenges arise when you’re dealing with a large scale application. It also introduces the {golem} package and more general concept about organising your workflow. This first part will be light on code: you’ll read more about conceptual ideas and organisation strategy. Part 2 to 6 describes a series of steps you can take when you want to build a Shiny App, and the tooling associated with each step. Part 7 (Optimizing) tackles the question of optimization, first by presenting some common caveats of Shiny Apps, and then showing how to optimize R code, and use JavaScript to lighten R work. About the authors // TODO Want to help? Any feedbacks on the book is very welcome. Feel free to open an issue, or to make a PR if you spot a typo (I’m not a native english speaker, so there might be some waiting to be found ;) ). Other resources Getting started with Shiny Learn Shiny with RStudio Getting Started with Shiny (WIP) Mastering Shiny A gRadual intRoduction to Shiny Shiny into production Shiny in production: Principles, practices, and tools Shiny in Production Suggest a Resource! Acknowledgments // TODO : "],
["successfulshinyapp.html", "Chapter 1 About Successful Shiny Apps 1.1 A (very) short introduction to Shiny 1.2 What’s a complex Shiny App? 1.3 What’s a successful Shiny App?", " Chapter 1 About Successful Shiny Apps If you’re reading this page, chances are you already know what a Shiny App is — a web application that communicates with R, built in R, and working with R. The beauty of {shiny} is that it makes it easy for anybody tp create a small app in a matter of hours. With small and simple Shiny apps, no knowledge of HTML, CSS or JavaScript is required, which makes it really easy to use — you can rapidly create a POC for a data-product and showcase an algorithm or present your results with an elegant, simple to build user interface. 1.1 A (very) short introduction to Shiny // TODO 1.2 What’s a complex Shiny App? Complex software is harder to think about, harder to test, harder to debug, and harder to maintain — and above all, harder to learn and use. .right{ text-align: right;} Basics of the Unix Philosophy 1.2.1 Reaching the cliff of complexity Things are quite simple when it comes to small prototypes or proof of concepts. But things change when your application reach “the cliff of complexity” 1. But what is complexity? Getting a clear definition is not an easy task 2 as it very depends on who is concerned. In the context of engineering Shiny applications, we can think of complexity from two points of view: the complexity as it is seen by the coder, and the complexity as it is seen by the customer / end user 3. From the developer point of view. An app is to be considered complex when it is big enough in term of size and functionality so that it makes it impossible to reason about it at once, and you need to rely on tools to handle this complexity. This type of complexity is called implementation complexity. One of the goal of this book is to present you a methodology and toolings that will help you reduce this form of complexity. For example, we’ll talk about a design / prototype / build / secure / deploy, which helps you reduce the complexity of implementing and maintain new app features. We’ll also be talking at length about the {golem} package, which provides a toolkit for reducing the cognitive load of handling complexity in large Shiny applications. For example, creatign a new Shiny module requires following a very strict structure. One way to do that is to remember how to do that and to code it from scratch (a method which has an important cognitive load and is very error prone). Another way is to copy and paste an existing module and to adapt it, which is, as any copy and paste, likely to lead to errors. Or there is the {golem} way, in which you rely on a robust tool to build the foundations for a new module. Another benefit of adopting automation for common application component is that it allows to be sure that you’re following a convention. And conventions are crucial when it comes to building and maintaining complex system: by imposing a formalized structure for a piece of code, it ehances readability, lessens the learning curve, and lightens the chance for typo and/or copy and paste error. Customers and users, on the other hand, see complexity as interface complexity. Interface complexity can be driven by a lot of elements, with for example the probability of making an error while using the app, difficulty to understand the evolution of the app, unfamiliar behaviour or terms, uncommon forms, visual distraction… There is an inherent tension between these two source of complexity, as designing an app means finding a good balance between implementation ann interface complexity. Reducing implementation complexity means one has to make some decisions that will lower one while rising the other. For example, we can think of something very common in Shiny: the “too much reactivity” pattern. In some cases, coders try to make everything reactive: e.g., three sliders and a selectInput, all updating a plot. This behaviour lowers the interface complexity: users don’t have to think a lot about what they are doing, they just move things around and it updates. But this kind of pattern can make the app computing too much things: user rarely go to the slider value they need from the first shoot, and usually miss what they want to select in an input. So, way more computation for R. One solution can be to delay reactivity or to cache things so that R computes less things. But that comes with a cost: handling delayed reactivity and caching elements, which increases implementation complexity. One other solution is simply to add a button after the input, and only update the plot when the user clicks on it. This pattern makes it easier to control reactivity from an implementation side. But it can make the interface a little bit more complex for the user who have to perform another action. We’ll argue somewhere else in the book that on the other hand, not enough reactivity is better than too much reactivity, as the latter increases computation time, and relies on the assumption that the user makes the right action on the first try. Another good example is {shiny}’s dateRangeInput() function being able to take a start which is posterior to the end (which is the behaviour of the JavaScript plugin used in {shiny} to create this input). Handling this special case is doable: with a little bit of craft, you can watch what the user inputs and throw an error if the start is after the end 4. That solution augments the implementation complexity, while leaving it as is requires the user to think about wether or not the starting date is before the ending date, thus increasing the interface complexity. -&gt; Insert here something of the like: “It’s up to you to think about what’s the best balance between these two sources.” Another measure that sometime comes in the discussion is the codebase size. It’s relatively hard to use this number of lines metric, as R is very permissive when it comes to identation and line break. It also depends on your coding style and the packages you’re using. For example, tidyverse packages encourage the use of the pipe (%&gt;%) 5 with one function by line, producing more lines in the end code. Consider this piece of valid R code: iris[ 1 : 5, c ( &quot;Species&quot; ) ] ## [1] setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica 9 lines of code for something that should also be written in one, three, five… Another drawback of this metric is that it focuses on numbers instead of readability, and on the long run yes, readability matters 6. -&gt; https://github.com/hrbrmstr/cloc -&gt; Cyclomatic complexity https://en.wikipedia.org/wiki/Cyclomatic_complexity -&gt; https://github.com/MangoTheCat/cyclocomp 1.2.2 With great complexity comes great responsabilities When your program reaches this state, there is a lot of potential for failure, be it from a developer perspective or from a user point of view. For the code, bugs are harder to anticipate: it’s hard to think about all the different path the software can follow, it’s hard to detect bug because they are deeply nested in the numerous routines the app is doing. It’s also hard to think about what the state of your at a given moment in time because of the numerous inputs and output your app contains. From the user perspective, the more complex an app, the more important the learning curve is. Which means that the user will have to invest time learning how the app works, and will be even more disappointed if ever they realise this time has been a waste. 1.2.3 Production Grade Software Engineering Complexity is still frowned upon by a lot of developers, notably because it has been seen as something to avoid according to the Unix philosophy. But there are dozens of reason why an app can become complex: for example, the question your app is answering to is quite a complicated question which involves a lot of computation and routines, the app is rather ambitious and implement a lot of features, etc. So yes, there is a chance that if you’re reading this page, you’re working or are planning to work on a complex Shiny app. And this is not necessarily a bad thing. Shiny apps can definitely be used to implement a production-grade 7 software, but production-grade software implies production-grade software engineering. And your goal to make this project a succes is be to prepared, to use tool that will reduce the complexity of your app, and ensure that your app has the quality to age well. In other words, production-grade Shiny apps require to work with a software engineering mindset. Which is not always that easy a task in the R world. R comes from the land of the academics and is still used a lot as an “experiementation tool”, and in context where production quality is one of the least concerns. Many developers in the R world have learned R as a tool for making statistics, not as a tool for building softwares. Both these contexts are very different and require different mindsets, different skills and tools. With {shiny}, as we said before, it’s quite easy to prototype a simple app, without any “hardcore” software engineering skills. And when we’re happy with our little proof of concept, we’re tempted to add something new. And another. And another. And without any structured methodology, we’re almost certain that we’ll reach the cliff of complexity very soon, with a code base that is hardly (if ever) ready to be refactored to be sent to production. The good news is that building a complex app with R (or with any other language) is not an impossible task. But it requires planning, rigor, and correct tooling. This is what this book is about: how to organise your Shiny App project in a way that is time and code efficient, and how to get the correct tooling for making your application a success. 1.3 What’s a successful Shiny App? Another good news is that your application does not have to be complexe to be successful. Even more, in a world where “less is more”, the more you can reduce your application complexity, the more you’ll be prepared for success. So what’s a successful Shiny app? Defining such a metric is not that easy a task, but we can extract some common patterns when it comes to applications that can be listed as successful. 1.3.1 It exists First of all, an app is successful if it was delivered. In other words, the developer team was able to move from specification to implementation to testing to delivering. This is a very engineering-oriented definition of success, but that’s a pragmatic one: an app that never reaches the state of usability is not a successful app, as something along the way has blocked the process of finishing the code. This implies a lot of things: but mostly it implies that the team was able to organise itself in an efficient way, so that they were able to work together in making the project a success. And anybody that has already work on a code base as a team knows it’s not an easy task. 1.3.2 It’s accurate The app was delivered, and it answers the question it is supposed to answer, or serves the purpose it is supposed to serve. Delivering is not the only thing to keep in mind: you can deliver a working app but it doesn’t work in the way it is supposed to work. Just as before, accuracy means that between the moment the idea appears in someone’s mind and the moment the app is actually ready to be used, everybody was able to work together toward a common goal. 1.3.3 It’s usable The app was delivered, it answers the question it is supposed to answer, and it is friendly on the user. Unless you’re coding for the sake of the art, there will always be one or more end user(s). And if these person can’t use the app because it’s too hard to use, too hard to understand, because it’s too slow or there is no inerhent logic in the way the user experience is designed, then it’s hard to tell the app is a success. 1.3.4 It’s immortal Of course that’s a little bit far fetched, but when designing the app, you should set the ground for robustness in time and aim at a (theoretical) immortality of the app. Planning for the future is a very important component of a successful Shiny App project. Once the app is out, it’s successful if it can exist on the long run, with all the hasards that it implies: new package versions that potentially break the code base, implementation of new features in the global interface, changing key features of the UI or the back-end, and not to mention passing the code base along to someone who has not worked on the first version, and who is now in charge of working on version 2. And this, again, is hard to do without effective planning and efficient tooling. Well, and this new person might simply be you, month from now. And &quot;You’ll be there in the future too, maintaining code you may have half forgotten under the press of more recent projects. When you design for the future, the sanity you save may be your own.8 We borrow this term from Charity Major, as heard in Test in Production with Charity Majors, CoRecursive↩ Ironic right?↩ from The Art of Unix Programming, “Chapter 13: Speaking of Complexity”↩ see shiny/issues/2043#issuecomment-525640738 for an example↩ “Pressure to keep the codebase size down by using extremely dense and complicated implementation techniques can cause a cascade of implementation complexity in the system, leading to an un-debuggable mess.”, from The Art of Unix Programming, “Chapter 13: Speaking of Complexity”↩ By production-grade, we mean a software that can be used in a context where people use it for doing their job, and where failures or bug have real-life consequences↩ The Art of Unix Programming, Eric Steven Raymond↩ "],
["planning.html", "Chapter 2 Planning Ahead 2.1 Working with a “long-term” mindset 2.2 Working as a team: tools &amp; organisation", " Chapter 2 Planning Ahead 2.1 Working with a “long-term” mindset “Rome ne fut pas faite toute en un jour” French proverb 2.1.1 Prepare for success -&gt; Planification is everything -&gt; Get ready for complexity -&gt; Think big, act small. Understand the big picture, but implement one small feature at a time. -&gt; Future is now 2.1.2 Applying the KISS principle The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided. .right{ text-align: right;} KISS principle Deeply rooted in the Unix Philosophy, the KISS principle stands for “Keep Thing Simple, Stupid”. The story behind this principle is supposed to be that Kelly Johnson, lead engineer at the Lockheed Skunk Works, gives his workers a set of very common tools and said that the airplanes should be repairable with these tools, and these tools only. The idea behing that being that the action of repairing the aicrafts that come out of their factories should be repairable by the average engineer. -&gt; Help you reason about the app on the long run -&gt; Hard to remove a feature once it’s implemented 2.1.3 Think long-term maintnenance, now Maintainance, on the other hand, is something to think about from the beginning. It includes being able to ensure that the application will work in the long run, and that new features can be easily implemented. Working in the long run: separate the code with “business logic” (aka the data manipulation and the algorithm, that can work outside the context of the app) from the code building the application. That way, you can write regression tests for these functions to ensure they are stable. Implement new elements: as we are working with modules, it’s easy to insert new elements inside the global application. 2.2 Working as a team: tools &amp; organisation Big Shiny Apps usually mean that several people will work on the application. For example, at ThinkR, 3 to 4 people usually work on the application. So, how do we organize that? 2.2.1 From the tools point of view: Use version control (not sure I have to expand on that topic ;) ) Think of your shiny app as a tree, and divide it as much as possible into little pieces. Then, create one Shiny module by piece. This allows you to split the work, and also to have smaller files — it’s easier to work on 20 files of 200 lines than on one big app.R file. 2.2.2 From the organisational point of view Define one person in charge of having the big picture of the app. This person will kick off the project, and write the skeleton of the app, with the good modules and files structure. This person will also be in charge of accepting new merge requests from other developers, and to orchestrate the master and dev branches. List the tasks, and open one issue for each task on your version control system. Each issue will be solved in a separate branch. Finally, assign one module to one developer — if it seems that working on one module is a two-person job, divide again into two other submodules. This is a relatively complex task, as the output of one module influences the input of another, so be sure to assign them well. "],
["structure.html", "Chapter 3 Structuring your Project 3.1 Shiny App as a Package 3.2 Using Shiny Modules 3.3 Splitting your app into files", " Chapter 3 Structuring your Project 3.1 Shiny App as a Package In the next chapter you’ll be introduced to the {golem} package, which is an opinionated framework for building production-ready Shiny Applications. This framework starts by creating a package skeleton waiting to be filled. But, in a world where Shiny Applications are mostly created as a series of files, why bother with a package? 3.1.1 What’s in a Shiny App? OK, so let’s ask the question the other way round. Think about your last Shiny which was created as a single-file (app.R) or two files app (ui.R and server.R). You’ve got these two, and you put them into a folder. So, let’s have a review of what you’ll need next for a robust application. First, metadata. In other words, the name of the app, the version number (which is crucial to any serious, production-level project), what the application does, who to contact if something goes wrong. Then, you need to find a way to handle the dependencies. Because you know, when you want to push your app into production, you can’t have this conversation with IT: IT: Hey, I tried to ‘source(“app.R”)’ but I’ve got an error. R-dev: What’s the error? IT: It says “could not find package ‘shiny’”. R-dev: Ah yes, you need to install {shiny}. Try to run ‘install.packages(“shiny”)’. IT: Ok nice. What else? R-dev: Let me think, try also ‘install.packages(“DT”)’… good? Now try ‘install.packages(“ggplot2”)’, and … […] IT: Ok, now I source the ‘app.R’, right? R-dev: Sure! IT: Ok so it says ‘could not find function runApp()’ R-dev: Ah, you’ve got to do library(shiny) at the beginning of your script. And library(purrr), and library(jsonlite)*. * Which will lead to a Namespace conflict on the flatten() function that can cause you some debugging headache. So, hey, it would be cool if we could have a Shiny app that only imports specific functions from a package, right? So yes, dependencies matter. You need to handle them, and handle them correctly. Now, let’s say you’re building a big app. Something with thousands of lines of code. Handling a one-file or two-file shiny app with that much lines is just a nightmare. So, what to do? Let’s split everything into smaller files that we can call! And finally, we want our app to live long and prosper, which means we need to document it: each small pieces of code should have a piece of comment to explain what these specific lines do. The other thing we need for our application to be successful on the long term is tests, so that we are sure we’re not introducing any regression. Oh, and that would be nice if people can get a tar.gz and install it on their computer and have access to a local copy of the app! OK, so let’s sum up: we want to build an app. This app needs to have metadata and to handle dependencies correctly, which is what you get from the DESCRIPTION + NAMESPACE files of the package. Even more practical is the fact that you can do “selective namespace extraction” inside a package, i.e you can say “I want this function from this package”. Also, this app needs to be split up in smaller .R files, which is the way a package is organized. And I don’t need to emphasize how documentation is a vital part of any package, so we solved this question too here. So is the testing toolkit. And of course, the “install everywhere” wish comes to life when a Shiny App is in a package. 3.1.2 The other plus side of Shiny as a Package 3.1.2.1 Testing Nothing should go to production without being tested. Nothing. Testing production apps is a wide question, and I’ll just stick to tests inside a Package here. Frameworks for package testing are robust and widely documented. So you don’t have to put any extra-effort here: just use a canonical testing framework like {testthat}. Learning how to use it is not the subject of this chapter, so feel free to refer to the documentation. See also Chapter 5 of “Building a package that lasts”. What should you test? First of all, as we’ve said before, the app should be split between the UI part and the backend (or ‘business logic’) part. These backend functions are supposed to run without any interactive context, just as plain old functions. So for these ones, you can do classical tests. As they are backend functions (so specific to a project), {golem} can’t provide any helpers for that. For the UI part, remember that any UI function is designed to render an HTML element. So you can save a file as HTML, and then compare it to a UI object with the golem::expect_html_equal(). library(shiny) ui &lt;- tagList(h1(&quot;Hello world!&quot;)) htmltools::save_html(ui, &quot;ui.html&quot;) golem::expect_html_equal(ui, &quot;ui.html&quot;) # Changes ui &lt;- tagList(h2(&quot;Hello world!&quot;)) golem::expect_html_equal(ui, &quot;ui.html&quot;) This can for example be useful if you need to test a module. A UI module function returns an HTML tag list, so once your modules are set you can save them and use them inside tests. my_mod_ui &lt;- function(id){ ns &lt;- NS(&quot;id&quot;) tagList( selectInput(ns(&quot;this&quot;), &quot;that&quot;, choices = LETTERS[1:4]) ) } my_mod_ui_test &lt;- tempfile(fileext = &quot;html&quot;) htmltools::save_html(my_mod_ui(&quot;test&quot;), my_mod_ui_test) # Some time later, and of course saved in the test folder, # not as a temp file golem::expect_html_equal(my_mod_ui(&quot;test&quot;), my_mod_ui_test) {golem} also provides two functions, expect_shinytag() and expect_shinytaglist(), that test if an objet is of class &quot;shiny.tag&quot; or &quot;shiny.tag.list&quot;. Testing package launch: when launching golem::use_recommended_tests(), you’ll find a test built on top of {processx} that allows to check if the application is launch-able. Here’s a short description of what happens: # Standard testthat things context(&quot;launch&quot;) library(processx) testthat::test_that( &quot;app launches&quot;,{ # We&#39;re creating a new process that runs the app x &lt;- process$new( &quot;R&quot;, c( &quot;-e&quot;, # As we are in the tests/testthat dir, we&#39;re moving # two steps back before launching the whole package # and we try to launch the app &quot;setwd(&#39;../../&#39;); pkgload::load_all();run_app()&quot; ) ) # We leave some time for the app to launch # Configure this according to your need Sys.sleep(5) # We check that the app is alive expect_true(x$is_alive()) # We kill it x$kill() } ) Note: this specific configuration will possibly fail on Continuous integration platform as Gitlab CI or Travis. A workaround is to, inside your CI yml, first install the package with remotes::install_local(), and then replace the setwd (...) run_app() command with myuberapp::run_app(). For example: in .gitlab-ci.yml: test: stage: test script: - echo &quot;Running tests&quot; - R -e &#39;remotes::install_local()&#39; - R -e &#39;devtools::check()&#39; in test-golem.R: testthat::test_that( &quot;app launches&quot;,{ x &lt;- process$new( &quot;R&quot;, c( &quot;-e&quot;, &quot;datuberapp::run_app()&quot; ) ) Sys.sleep(5) expect_true(x$is_alive()) x$kill() } ) 3.1.2.2 Documenting Documenting packages is a natural thing for any R developer. Any exported function should have its own documentation, hence you are “forced” to document any user facing-function. Also, building a Shiny App as a package allows you to write standard R documentation: A README at the root of your package Vignettes that explain how to use your app A {pkgdown} that can be used as an external link for your application. 3.1.3 Deploy 3.1.3.1 Local deployment As your Shiny App is a standard package, it can be built as a tar.gz, sent to your colleagues, friends, and family, and even to the CRAN. It can also be installed in any R-package repository. Then, if you’ve built your app with {golem}, you’ll just have to do: library(myuberapp) run_app() to launch your app. 3.1.3.2 RStudio Connect &amp; Shiny Server Both these platforms expect a file app configuration, i.e an app.R file or ui.R / server.R files. So how can we integrate this “Shiny App as Package” into Connect or Shiny Server? Using an internal package manager like RStudio Package Manager, where the package app is installed, and then you simply have to create an app.R with the small piece of code from the section just before. Uploading the package package folder to the server. In that scenario, you use the package folder as the app package, and upload the whole thing. Then, write an app.R that does: pkgload::load_all() shiny::shinyApp(ui = app_ui(), server = app_server) And of course, don’t forget to add this file in the .Rbuildignore! This is the file you’ll get if your run golem::add_rconnect_file(). 3.1.3.3 Docker containers In order to dockerize your app, simply install the package as any other package, and use as a CMD R -e 'options(&quot;shiny.port&quot;=80,shiny.host=&quot;0.0.0.0&quot;);myuberapp::run_app()'. Of course changing the port to the one you need. You’ll get the Dockerfile you need with golem::add_dockerfile(). 3.1.4 Resources R packages “Building a package that lasts” Writing R Extensions R package primer - a minimal tutorial 3.2 Using Shiny Modules // TODO 3.3 Splitting your app into files // TODO "],
["golem.html", "Chapter 4 Introduction to {golem} 4.1 Getting started with {golem} 4.2 Understanding {golem} package structure", " Chapter 4 Introduction to {golem} Ok, that’s a lot of things to process. Is there a tool that can help us simplify this workflow? Of course there is, and it’s called {golem}. It can be found at https://github.com/ThinkR-open/golem The stable release can be found on CRAN, and installed with: install.packages(&quot;golem&quot;) {golem} can only be found on GitHub so you have to install it with: remotes::install_github(&quot;Thinkr-open/golem&quot;) {golem} is an R package that implements an opinionated framework for building production-ready Shiny apps. It all starts with an RStudio project, which contains a predefined setup for building your app. The idea is that with {golem}, you don’t have to focus on the foundation of your app, and can spend your time thinking about what you want to do, not about how to do it. It’s built on top of the working process we’ve developed at ThinkR, and tries to gather in one place the functions and tools we’ve created for building applications designed for production. 4.1 Getting started with {golem} Note before using {golem}: A {golem} app is contained inside a package, so knowing how to build a package is highly recommended. A {golem} app works better if you are working with shiny modules, so knowing how modules work is heavily recommended. In the rest of the book, we’ll assume you’re working in RStudio. 4.2 Understanding {golem} package structure // TODO "],
["workflow.html", "Chapter 5 The workflow 5.1 Part 1: Design 5.2 Part 2: Prototype 5.3 Part 3: Build 5.4 Part 4: Secure 5.5 Part 5: Deploy", " Chapter 5 The workflow -&gt; Overview of the workflow 5.1 Part 1: Design // TODO 5.2 Part 2: Prototype // TODO 5.3 Part 3: Build // TODO 5.4 Part 4: Secure // TODO 5.5 Part 5: Deploy // TODO https://en.wikipedia.org/wiki/Principle_of_least_astonishment#cite_note-Raymond2004-1 https://www.ibm.com/developerworks/web/library/us-cranky10/index.html https://www.cs.tufts.edu/~nr/cs257/archive/mike-cowlishaw/rexx.pdf https://books.google.fr/books?id=I-NOcVMGWSUC&amp;pg=PA85&amp;redir_esc=y#v=onepage&amp;q&amp;f=false http://www.faqs.org/docs/artu/ch11s01.html http://canonical.org/~kragen/tao-of-programming.html#book4 "],
["uxmatters.html", "Chapter 6 UX Matters 6.1 The Unbearable Lightness of Being 6.2 The danger of over-featuring 6.3 About Accessibility 6.4 Further reading", " Chapter 6 UX Matters We have a natural tendency, as R-coders, to be focused on the back-end, i.e the server part of the application 9. Which is perfectly normal—chances are you didn’t come to R to code front-ends 10. But let’s state the truth: no matter how complex and innovative your backend is, your application is bad if your User Experience (UX) is bad. That’s the hard truth. If people can’t understand how to use your application, your application isn’t successful, no matter how incredible the backend is. This natural taste for back-end / server logic can deserve you on the long run: by neglecting the UI, you’ll make your application less likely to be adopted among your users. Which is a good way to fail your application project. 6.1 The Unbearable Lightness of Being “Simplify, then add lightness” Colin Chapman CBE, Founder of Lotus Cars There are mainly two contexts where you’ll be building a web app with R: one for professional use (i.e people will rely on this app to do their job), or for fun (i.e people will just use the app as a distraction). But in both cases, people will want the app to be useable, and easily usable. If people will use your app in a professional context, they don’t want to fight with your interface, read complexe manuals, or lose time understanding what is supposed to do what in your application. Think about all the professional applications and softwares that you’ve been ranting about during your professional life. You don’t want your app to be one of that. On the other end, if users open your app for fun, they are not going to fight your app into submission: they are just going to give up using your app if it’s too complex to be used. 6.1.1 Make a self-explanatory app All kinds of things on a Web page can make us stop and think unnecessarily. Take names, for example. Typical culprits are cute or clever names, marketing-induced names, company-specific names, and unfamiliar technical names. .right{ text-align: right;} 'Don't make me think', Steve Krug -&gt; If things are clickable, it has to look clickable “As a user, I should never have to devote a millisecond of thought to whether things are clickable—or not” .right{ text-align: right;} 'Don't make me think', Steve Krug -&gt; If there is a progression in your app, you should have a clear pattern of moving forward -&gt; If you need inputs, this should be made clear -&gt; Have some “reading logic”: from left to right or right to left, there should be a progression in the way visual elements are organised. 6.1.2 “Rule of Least Surprise” “Rule of Least Surprise” or “Principle of Least Astonishment.” Rule of Least Surprise: In interface design, always do the least surprising thing. .right{ text-align: right;} 'Basic of the Unix Philosophy', Eric Steven Raymond Try to find a simple, and efficient UI. One that people can understand and use in a matter of seconds. Don’t implement features or visual elements that are not actually needed, just “in case”. And spend time working on that UI, really thinking about what visual elements you are implementing. 6.2 The danger of over-featuring 6.2.1 Restrain reactivity As a designer, you think: they’ll select this, and when they release the slider, this will update automatically. In real life, people make mistakes using the app, so if everything reacts to their every moves, the experience using the app can be bad. 6.2.2 Too much interactivity Don’t make things interactive if there is no value in adding interactivity. Adding interactivity widgets (in most cases) means adding visual elements to your original content: in other words, you’re adding visual components that might distract the user from focusing on the content of the information. Good rule: don’t add feature for the sake of adding a feature. Less is more. Example: using DT::data.table() or plotly or dygraph when it’s not needed. Maybe a parallel with 90/00 website design with a lot of visual noise vs minimalist modern design? 6.3 About Accessibility A user interface needs to be “ready to be consumed” by the broader audience possible. That means people with visual, mobility, or cognitive disabilities. Web Accessibility is pretty standard concept in the web development world, and you can learn about this straight from the first chapter of learn.freecodecamp.org. -&gt; Screen to speech technology : html semantic tags -&gt; Mobility impairment, people w/ parkinson for example. Exemple of the text input &amp; ENTER button. Making things keyboard friendly. -&gt; ColorBlind, viridis 6.4 Further reading ‘Don’t Make Me Think’, Steve Krug // TODO: Find resources about simplicity in UI/UX design aka what happens in the server side of a Shiny App↩ Front-end are the visual parts of your application, the one with which your user interacts, as opposed to the back-end, which is what is installed on the server. In shiny, front-end is what correspond to the UI, back-end to the server.↩ "],
["step-design.html", "Chapter 7 Don’t rush into coding 7.1 Designing before coding 7.2 Ask questions", " Chapter 7 Don’t rush into coding 7.1 Designing before coding Don’t rush into coding. I know you want to, because it’s what we like to do and what we are good at. But before entering the coding marathon, take time to think about the application and the way it will be deployed and used. 7.2 Ask questions Take a pen and a piece of paper and draw the app. Talk about it with the people who will use the app, just to decipher what they actually need. Take a moment to talk with the IT. Here are some questions you can ask: “Who are the end users of the app?” — This will help you know if the end users are tech literate or not, and what they aim to achieve with the app. “How frequently will they use the app?” — The small details of the design &amp; the UI of an app you use on a daily basis is more crucial than when the app is used once a month. “What level of complexity and personalization do the users really need?” — People writing app specifications sometimes want more functionalities than what is actually needed by the users. “What level of interactivity do you want, and to what extent is it central?” — People love interactive graphs and like when things automatically sync with each other. Yet these two can make the app slower, without any significant gain. For example, being reactive to a selectInput() or a sliderInput() can lead to too much computation: maybe the user will not succeed to choose the right input the first, second or third time… So let them do their choice, and add a button so that they can validate when they are ready. “How important is it that the app is fast?” — Should you spend a lot of time optimizing the little things? etc. Asking questions, taking notes, and drawing the app help you have a good idea of what is expected and what you have to do now. So, next step! "],
["stepprotopype.html", "Chapter 8 Building an “ipsum-app” 8.1 Prototyping is crucial 8.2 The “UI first” approach", " Chapter 8 Building an “ipsum-app” 8.1 Prototyping is crucial Rule of Optimization: Prototype before polishing. Get it working before you optimize it. http://www.catb.org/~esr/writings/taoup/html/ch01s06.html#rule_of_optimization 8.2 The “UI first” approach I like to go “UI first”. For two main reasons: Once the UI is set, there is no “surprise implementation”. Once we agree on what elements there are in the app, there is no sudden “oh the app needs to do that now”. A pre-defined UI allows every person involved in the coding to know which part of the app they are working on. In other words, when you start working on the backend, it’s much easier to work on a piece you can visually identify and integrate in a complete app scenario. So yes, spend time writing a front-end prototype in lorem ipsum. And good news, we’ve got a tool for you: it’s called {shinipsum}. The main goal of this package is to create random Shiny elements that can be used to draw a UI, without actually doing any heavy lifting in the backend. Hence, once you’ve got a draft of your app on a piece of paper, you can then move to the “ipsum-UI” stage: building the front-end of the app, and filling it with random Shiny elements, with functions like random_ggplot() or random_DT(). Another package that can be used to do that is {fakir}. This package is designed to create fake data frames, primarily for teaching purposes, but it can also be used for inserting data into a shiny prototype. "],
["proto.html", "Chapter 9 Tools for prototyping 9.1 Fast prototyping with {shinipsum} 9.2 Using {fakir} for fake data generation", " Chapter 9 Tools for prototyping These two tools allow you to prototype a Shiny App and to go “UI first”. Learn more: 9.1 Fast prototyping with {shinipsum} // TODO https://github.com/ThinkR-open/shinipsum 9.2 Using {fakir} for fake data generation // TODO https://github.com/ThinkR-open/fakir "],
["stepbuild.html", "Chapter 10 Building app with {golem} 10.1 Using {golem} 10.2 dev/01_start.R 10.3 Day to Day Dev with {golem} 10.4 Launching the app 10.5 dev/02_dev.R 10.6 Adding these external resources to your app 10.7 Documentation 10.8 Using {golem} dev functions", " Chapter 10 Building app with {golem} Now the UI and the features are set, time to work on the backend. This part is pretty standard — everybody can now work on the implementation of the functions that process the app inputs, in their own modules. As the UI, functionalities and modules have been defined in the previous steps, everyone (well, in theory) knows what they have to work on. And also, as said before, there should be no “surprise implementation”, as the app has been well defined before. 10.1 Using {golem} 10.1.1 Create a package Once the package is installed, you can got to File &gt; New Project… in RStudio, and choose “Package for Shiny App Using golem” input. If you want to do it through command line, you can use: golem::create_shiny_template(path = &quot;path/to/package&quot;) This command allows you to create “illegally-named” package (for example, 1234) by passing the check_name argument to FALSE. Note that this is not recommended and should only be done if you know what you are doing. Once you’ve got that, a new RStudio project will be launched. Here is the structure of this project: DESCRIPTION ¦--dev/ ¦--01_start.R ¦--02_dev.R ¦--03_deploy.R ¦--run_dev.R ¦--inst/ ¦--app ¦--server.R ¦--ui.R ¦--www/ ¦--favicon.ico ¦--man/ ¦--run_app.Rd NAMESPACE myapp.Rproj ¦--R/ ¦--app_server.R ¦--app_ui.R ¦--run_app.R If you’re already familiar with R packages, most of these files will appear very familiar to you. That’s because a {golem} app IS a package. DESCRIPTION &amp; NAMESPACE: Package meta-data. dev/: Scripts that will be used along the process of developing your app. inst/app: You’ll add external dependencies in www (images, css, etc). Don’t touch app_ui and app_server. man: Package doc, to be generated by R. myapp.Rproj: RStudio project. R/app_server.R, R/app_ui.R: Top level UI and server elements. R/run_app.R: a function to configure and launch the application. 10.2 dev/01_start.R Once you’ve created your project, the first file that opens is dev/01_start.R. This file contains a series of commands to run once, at the start of the project. 10.2.1 Fill the DESC First, fill the DESCRIPTION by adding information about the package that will contain your app: golem::fill_desc( pkg_name = &quot;shinyexample&quot;, # The Name of the package containing the App pkg_title = , # The Title of the package containing the App pkg_description = , # The Description of the package containing the App author_first_name = , # Your First Name author_last_name = , # Your Last Name author_email = , # Your Email repo_url = NULL) # The (optional) URL of the GitHub Repo 10.2.2 Set common Files If you want to use the MIT licence, README, code of conduct, lifecycle badge, and news usethis::use_mit_license(name = &quot;Your Name&quot;) # You can set another licence here usethis::use_readme_rmd() usethis::use_code_of_conduct() usethis::use_lifecycle_badge(&quot;Experimental&quot;) usethis::use_news_md() 10.2.3 Add a data-raw folder If you have data in your package usethis::use_data_raw() 10.2.4 Init Tests Create a template for tests: golem::use_recommended_tests() 10.2.5 Use Recommended Package This will add “shiny”, “DT”, “attempt”, “glue”, “htmltools”, and “golem” as a dependecy to your package. golem::use_recommended_dep(&quot;&quot;) 10.2.6 Add various tools These two functions add a file with various functions that can be used along the process of building your app. See each file in details for a description of the functions. golem::use_utils_ui() golem::use_utils_server() 10.2.7 If you want to change the default favicon golem::use_favicon( path = &quot;path/to/favicon&quot;) You’re now set! You’ve successfully initiated the project and can go to dev/02_dev.R. rstudioapi::navigateToFile(&quot;dev/02_dev.R&quot;) 10.3 Day to Day Dev with {golem} Now that you’re all set with your project init, time to move to development :) App development should happen through the dev/02_dev.R file, which contains common commands for developping. 10.4 Launching the app To run the app, go to the dev/run_dev.R file, and run the all thing. 10.5 dev/02_dev.R 10.5.1 Add modules The golem::add_module() functions creates a module in the R folder. The file and the modules will be named after the name parameter, by adding mod_ to the R file, and mod_*_ui and mod_*_server to the UI and server functions. golem::add_module(name = &quot;my_first_module&quot;) # Name of the module The new file will contain: # mod_UI mod_my_first_module_ui &lt;- function(id){ ns &lt;- NS(id) tagList( ) } mod_my_first_module_server &lt;- function(input, output, session){ ns &lt;- session$ns } ## To be copied in the UI # mod_my_first_module_ui(&quot;my_first_module_1&quot;) ## To be copied in the server # callModule(mod_my_first_module_server, &quot;my_first_module_1&quot;) In order not to make errors when putting these into your app, the end of the file will contain code that has to be copied and pasted inside your UI and server functions. 10.5.2 Add dependencies To be called each time you need a new package as a dependency: usethis::use_package(&quot;pkg&quot;) 10.5.3 Add tests Add more tests to your application: usethis::use_test(&quot;app&quot;) 10.5.4 Add a browser button Learn more about this: https://rtask.thinkr.fr/blog/a-little-trick-for-debugging-shiny/ golem::browser_button() 10.5.5 Add external files These functions create external dependencies (JavaScript and CSS). add_js_file() creates a simple JavaScript file, while add_js_handler() adds a file with a skeleton for shiny custom handlers. golem::add_js_file(&quot;script&quot;) golem::add_js_handler(&quot;script&quot;) golem::add_css_file(&quot;custom&quot;) 10.6 Adding these external resources to your app You can add any external resource (JS, css) into inst/app/www. Then, You’ll need to point to these external resources in golem_add_external_resources(). For example, if you’ve created a CSS file with golem::add_css_file(&quot;custom&quot;), you can add the file with: tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;www/custom.css&quot;) Also, you can list here the use of other packages, for example useShinyalert() from the {shinyalert} package. Note: we’ve chosen to leave it “raw”, in the sense that there is a addResourcePath and a tags$head. If you’re comfortable with {htmltools}, you can build a htmltools::htmlDependency. 10.7 Documentation 10.7.1 Vignette usethis::use_vignette(&quot;shinyexample&quot;) devtools::build_vignettes() 10.7.2 Code coverage usethis::use_travis() usethis::use_appveyor() usethis::use_coverage() 10.8 Using {golem} dev functions There’s a series of tools to make your app behave differently whether it’s in dev or prod mode. Notably, the app_prod() and app_dev() function tests for options( &quot;golem.app.prod&quot;) (or return TRUE if this option doesn’t exist). Setting this options at the beginning of your dev process allows to make your app behave in a specific way when you are in dev mode. For example, printing message to the console with cat_dev(). options( &quot;golem.app.prod&quot; = TRUE) golem::cat_dev(&quot;hey\\n&quot;) options( &quot;golem.app.prod&quot; = FALSE) golem::cat_dev(&quot;hey\\n&quot;) ## hey You can then make any function being “dev-dependant” with the make_dev() function: log_dev &lt;- golem::make_dev(log) log_dev(10) ## [1] 2.302585 options( &quot;golem.app.prod&quot; = TRUE) log_dev(10) "],
["step-secure.html", "Chapter 11 Build yourself a safe net 11.1 Testing your app 11.2 A reproducible environment", " Chapter 11 Build yourself a safe net Securing your app means two things: testing, and locking the application environment. 11.1 Testing your app So first, be sure to include tests all along the building process — just like any other R code. As the app is contained in a package, you can use standard testing tools for testing the business logic of your app — as said in the first part, it’s important to split the backend functions and algorithm from the user interface. That means that these backend functions can run outside of the application. And yes, if they can run outside of the app, they can be tested the standard way, using {testthat}. When it comes to testing the front end, you can try the {shinytest} package from RStudio, if you need to be sure there is no visual regression all along the project development. {shinyloadtest}, on the other hand, tests how an application behaves when one, two, three, twenty, one hundred users connect to the app, and gives you a visual report about the connection and response time of each session. One other tool I like to use is Katalon Studio. It’s not R related, and can be used with any kind of web app. How it works is quite simple: it opens your browser where the Shiny app runs, and record everything that happens. Once you stop the recording, you can relaunch the app and it will replay all the events it has recorded. And of course, you can specify your own scenario, define your own events, etc. It’s not that straightforward to use, but once you get a good grasp of how it works, it’s a very powerful tool. 11.2 A reproducible environment Secondly, secure your app means that it can be deployed again any time in the future — in other words, you have to ensure you’ve got a proper handle on the required R version, and of the package versions which are required to run your app. That means that you have to be aware that upgrading a package might break your app — so, provide an environment that can prevent your app from breaking when a package gets updated. For that, there is, of course, Docker, R specific tools like {packrat} or {renv}, or deploying custom CRAN repositories or package manager. "],
["secure.html", "Chapter 12 Secure your work 12.1 Git 12.2 CI and testing", " Chapter 12 Secure your work 12.1 Git Friends don’t let friends work on a coding project without version control. // TO DO 12.2 CI and testing Testing is central for making your application survive in the long run. The {testthat} package can be used to test the “business logic” side of your app, while the application features can be tested with packages like {shinytest}, or software like Katalon. // TO DO: more info about the tools + link to resources. "],
["stepdeploy.html", "Chapter 13 Send your app to production", " Chapter 13 Send your app to production Tools for deployment are not the subject of this blog post so I won’t talk about this in detail (remember, we are talking about building 😉 ), but our two tools of choice are Docker &amp; ShinyProxy, and RStudio Connect. // TODO: link to resources. "],
["deploy-golem.html", "Chapter 14 Deploy with {golem} 14.1 Local deployment 14.2 Deploying Apps with {golem} 14.3 RStudio Environments 14.4 Docker", " Chapter 14 Deploy with {golem} 14.1 Local deployment // TODO 14.2 Deploying Apps with {golem} The dev/03_deploy.R file contains function for deploying on various plateforms. 14.3 RStudio Environments // TODO 14.4 Docker // TODO "],
["when-optimize.html", "Chapter 15 The Need for Optimization 15.1 Build first, then optimize 15.2 Tools for profiling", " Chapter 15 The Need for Optimization 15.1 Build first, then optimize // TODO 15.2 Tools for profiling // TODO "],
["optim-caveat.html", "Chapter 16 Common Application Caveats 16.1 Reactivity anti-patterns 16.2 Reading data 16.3 R does too much", " Chapter 16 Common Application Caveats 16.1 Reactivity anti-patterns // TODO 16.2 Reading data // TODO 16.3 R does too much // TODO "],
["optimizing-shiny-code.html", "Chapter 17 Optimizing Shiny Code 17.1 Reading data 17.2 Caching elements 17.3 Keeping things simple", " Chapter 17 Optimizing Shiny Code 17.1 Reading data // TODO 17.2 Caching elements // TODO 17.3 Keeping things simple // TODO "],
["optimjs.html", "Chapter 18 Using JavaSript 18.1 Client-side Optimization 18.2 JavaScript &lt;-&gt; Shiny communication 18.3 Common JavaScript patterns for Shiny 18.4 About {golem} js functions", " Chapter 18 Using JavaSript 18.1 Client-side Optimization // TODO 18.2 JavaScript &lt;-&gt; Shiny communication // TODO 18.3 Common JavaScript patterns for Shiny // TODO 18.4 About {golem} js functions {golem} comes with a series of JavaScript functions that you can call from the server. These functions are added by default with golem::activate_js() in app_ui. Then they are called with golem::invoke_js(&quot;function&quot;, &quot;ui_element&quot;). This ui_element define the UI element to interact with. It can be a full jQuery selector, an id or a class. 18.4.1 golem::activate_js() showid &amp; hideid, showclass &amp; hideclass show and hide elements through their id or class. session$sendCustomMessage(&quot;showid&quot;, ns(&quot;plot&quot;)) showhref &amp; hidehref hide and show a link by trying to match the href content. session$sendCustomMessage(&quot;showhref&quot;, &quot;panel2&quot;) clickon click on the element. You have to use the full jQuery selector. show &amp; hide show and hide elements, using the full jQuery selector. 18.4.2 About jQuery selectors #plop: the element with the id plop .pouet: elements of class pouet &quot;button:contains('this')&quot;: buttons with a text containing 'this' Note that in html, tags contains attributes. For example: &lt;a href = &quot;https://thinkr.fr&quot; data-value = &quot;panel2&quot;&gt;ThinkR&lt;/a&gt; contains href &amp; data-value. You can refer to these attributes with [] after the tag name. a[href = &quot;https://thinkr.fr&quot;]: link with href being https://thinkr.fr a[data-value=&quot;panel2&quot;]: link with data-value being &quot;panel2&quot; "]
]
