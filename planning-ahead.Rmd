# Planning Ahead {#planning}

## Working with a "long-term" mindset

> "Rome ne fut pas faite toute en un jour"

French proverb

### Prepare for success

One common thing you'll hear about Shiny is that it's a good prototyping tool. 
And this can't be denied: building a POC for an app is relatively easy if you compare to what it needs when building apps in other languages. 
With Shiny, you can build a "works on my machine" app in just a couple of hours, and show it to your team, your boss, your investors...
Thanks to the way Shiny is built, you don't have to care about websocket, ports, html, JavaScript, libraries, and all the things that are elegantly bundled straight into Shiny. 

So, you can have a quick, hacky application that will work on your machine, and that very rapidly. 
But that's not the way you should start. 
Indeed, starting with hacky foundations will lead to two possibilities:

+ You'll have to rewrite everything from scratch to have a robust application.
+ If you don't want to do that, you'll get stucked with a legacy code base for the app that is built on top of hacky function.

The idea there is that even if Shiny is a good tool for prototyping, there is no harm in starting your application on solid ground, even for a prototype. 
We'll discover in this book a framework called `{golem}`, which is a toolbox for building production-grade Shiny application. 
Even if `{golem}` is focused on production, there is no reason not to use it for your Proof of Concepts: starting a new `{golem}` project is relatively straightforward, and even if you don't use the advanced features, you can use it for very small apps. 
That way, you're getting ready for complexity, and if you need to turn this small app into a production app, the foundations are there.

### Team work and the KISS principle

> The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided.

`r right_link("KISS principle", "https://en.wikipedia.org/wiki/KISS_principle")`

Deeply rooted in the [Unix Philosophy](http://www.catb.org/~esr/writings/taoup/html/ch01s07.html), the KISS principle stands for "Keep It Simple, Stupid".

The story behind this principle is supposed to be that Kelly Johnson, lead engineer at the Lockheed Skunk Works, gave his workers a set of very common tools and said that the airplanes should be repairable with these tools, and these tools only. 
The idea behind this being that repairing an aircraft should be possible for any average engineer. 

This should be a principle to keep in mind when building application. 
Indeed, large scale Shiny projects can lead to many people working on the code base, and this for a long period of time. 
Many people means a variety of skills, with some common ground in Shiny development. 
So when choosing how and what to implement, try to make a rule to go for the simplest solution^[
Which might not be the most "elegant" solution, but production code requires pragmatism.
], i.e the one that any common Shiny Developer would be able to understand and maintain.  
If you go for an exotic solution or a complex technology, be sure that you're doing it for a good reason: unknown or hard to grasp technology reduce the chance of finding someone that will be able to maintain that piece of code in the future. 

## Working as a team: tools & organisation

Complex Shiny Apps usually imply that several people will work on the application. 
For example, at ThinkR, 3 to 4 people usually work on the application, but there might be more people involved on larger project. 
Working as a team, whatever the coding project, requires discipline and organisation. 
How can we achieve that?

### From the tools point of view: 

#### Version Control & Test all the things

When you are working on a complex application, chances are that you'll be working on it for a significant period of time, meaning that you'll write code, modify it, use it, go back to it after a few weeks, change some other things, and probably break things. 
Breaking things is a natural process of software engineering, notably when working on a piece of code during a long period.
Remember the last chapter where we defined that complex applications are too large to be understood fully? 
Adding code that breaks the codebase will happen with complex app, so the sooner you take measure to solve code break the better. 

As you can't prevent code to break, you should at least get the tooling to:

+ Be informed that the code has broken
+ Be able to identify changes, and to potentially get back in time to a previous code base. 

To get informed about a code break, you'll need to write tests for your app, and to use Continuous Integration so that you're sure this is automatically detected^[
Relying on automatic tooling for monitoring code base is way safer than relying on developers to do manual checks every time they commit code.
].

We'll get back to testing and version control in depth in [chapter 14](#step-secure).

#### Small is beautiful 

Last chapter introduced the notion of complexity in size, where the app grows so large that it's very hard to have a good grasp of it. 
A large code base implies that the safe way to work is to split the app in pieces as much as possible.  
Splitting a Shiny project is made possible by following two techniques: 

+ Split your app into Shiny Modules, so that your app be though of as a tree, making is possible for every developer to concentrate on one node, and only one, instead of having to think about the global infrastructure when implementing features

![](img/app_tree.png)

+ Extract your core "non-reactive" functions, that we will also call the "business logic", and include them in external files, so that you can work on these outside of the app: in other words, so that you don't have to relaunch the whole app every time you need to do something new

We'll get back to Shiny module and how to organised your project in the next chapter. 

### From the organisational point of view

First of all, you'll need one person (or maybe two) to be in charge of supervising the whole project. 
It's hard to have the complete picture of what the app is doing, and most of the time, as a developer, you don't need to. 
On the other hand, if the work is correctly spit between members of the team, you'll probably be focusing on one or more part(s) of the application, but you don't need to know every single bit of what the application is doing. 

But someone has to be get the whole picture: what each part of the software is doing, and how to make all work together, and of course how to check that, at the end of the day, the results returned by the application are the correct ones. 
This very same person will be the one that kicks off the project, and write the first draft of the application. 
If you're following the workflow we'll describe in this book, this person in charge of supervising will create a `{golem}` project, fill the information, and define the application structure by providing the modules, and the prototype of the app. 

If you're working following `git flow` (described in chapter 13), this person in charge of managing the app will also be in charge of reviewing the pull requests and merging them to `dev` if they solve the associated issue.
Don't worry if this sounds like a foreign language to you, we'll get back to this method in this book. 

Once this skeleton of an app is created, create a series of tasks to be accomplished. 
Using a Version Control System like `git` will help you there: you'll open a series of issues which will be closed during the development. 
Other management tools can be used there: for example `redmine`, `jira`, or any issue tracking software can play this role. 
We strongly suggest to use git, either on GitHub or on GitLab, as it can be easily integrated with R, and of course as it can also be used for doing versioning. 

As the app will be split in various Shiny Modules, you can assign the development of one or more module(s) to one member of the team.
Remember that it's simpler to work in a context where one developer is assigned to one module, even if in reality it's a little bit more complex than that, and several members of the team might go back and forth working on a module. 
But in a perfect world, one module equals one file, and every body safely works on their own part of the application. 
Then, only one person is in charge of making all the pieces fit together.
