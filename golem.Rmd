# (PART) Tools {-}

# Using Golem {#golem}

Ok, that’s a lot of things to process. Is there a tool that can help us simplify this workflow? Of course there is, and it’s called `{golem}`.

It can be found at https://github.com/ThinkR-open/golem

For now, `{golem}` can only be found on GitHub (but it should be on CRAN soon), so you have to install it with:

```{r eval = FALSE}
remotes::install_github("Thinkr-open/golemn")
```

`{golem}` is an R package that implements an opinionated framework for building production-ready Shiny apps. It all starts with an RStudio project, which contains a predefined setup for building your app. The idea is that with `{golem}`, you don’t have to focus on the foundation of your app, and can spend your time thinking about what you want to do, not about how to do it. It’s built on top of the working process we’ve developed at ThinkR, and tries to gather in one place the functions and tools we’ve created for building applications designed for production.

## Getting started with `{golem}`

Note before using `{golem}`: 

- A `{golem}` app is contained inside a package, so knowing how to build a package is highly recommended. 

- A `{golem}` app works better if you are working with `shiny modules`, so knowing how modules work is heavily recommended.

In the rest of the Vignettes, we'll assume you're working in RStudio. 

### Create a package

Once the package is installed, you can got to File > New Project... in RStudio, and choose "Package for Shiny App Using golem" input. 

If you want to do it through command line, you can use:

```{r eval = FALSE}
golem::create_shiny_template(path = "path/to/package")
```

This command allows you to create "illegally-named" package (for example, `1234`) by passing the `check_name` argument to `FALSE`. Note that this is not recommanded and __should only be done if you know what you are doing__.

Once you've got that, a new RStudio project will be launched. Here is the structure of this project:

```
DESCRIPTION               
¦--dev/          
  ¦--01_start.R           
  ¦--02_dev.R           
  ¦--03_deploy.R           
  ¦--run_dev.R
¦--inst/ 
  ¦--app                
    ¦--server.R       
    ¦--ui.R           
    ¦--www/          
      ¦--favicon.ico
¦--man/ 
    ¦--run_app.Rd      
NAMESPACE
myapp.Rproj
¦--R/ 
  ¦--app_server.R       
  ¦--app_ui.R           
  ¦--run_app.R      
```
]

If you're already familiar with R pacakges, most of these files will appear very familiar to you. That's because a `{golem}` app IS a package.

+ `DESCRIPTION` & `NAMESPACE`: Package meta-data.

+ `dev/`: Scripts that will be used along the process of developping your app. 

+ `inst/app`: You'll add external dependencies in `www` (images, css, etc). Don't touch `app_ui` and `app_server`.

+ `man`: Package doc, to be generated by R.  

+ `myapp.Rproj`: RStudio project.

+ `R/app_server.R`, `R/app_ui.R`: Top level UI and server elements. 

+ `R/run_app.R`: a function to configure and launch the application.

## `dev/01_start.R`

Once you've created your project, the first file that opens is `dev/01_start.R`. This file contains a series of commands to run once, at the start of the project. 

### Fill the DESC

First, fill the DESCRIPTION by adding information about the package that will contain your app:

```{r eval = FALSE}
golem::fill_desc(
  pkg_name = "shinyexample", # The Name of the package containing the App 
  pkg_title = , # The Title of the package containing the App 
  pkg_description = , # The Description of the package containing the App 
  author_first_name = , # Your First Name
  author_last_name = ,  # Your Last Name
  author_email = ,      # Your Email
  repo_url = NULL)      # The (optional) URL of the GitHub Repo
```

### Set common Files 

If you want to use the MIT licence, README, code of conduct, lifecycle badge, and news

```{r eval = FALSE}
usethis::use_mit_license(name = "Your Name")  # You can set another licence here
usethis::use_readme_rmd()
usethis::use_code_of_conduct()
usethis::use_lifecycle_badge("Experimental")
usethis::use_news_md()
```

### Add a data-raw folder

If you have data in your package

```{r eval = FALSE}
usethis::use_data_raw()
```

### Init Tests

Create a template for tests:

```{r eval = FALSE}
golem::use_recommended_tests()
```


### Use Recommended Package

This will add "shiny", "DT", "attempt", "glue", "htmltools", and "golem" as a dependecy to your package.

```{r eval = FALSE}
golem::use_recommended_dep("")
```

### Add various tools

These two functions add a file with various functions that can be used along the process of building your app.

See each file in details for a description of the functions.

```{r eval = FALSE}
golem::use_utils_ui()
golem::use_utils_server()
```

### If you want to change the default favicon

```{r eval = FALSE}
golem::use_favicon( path = "path/to/favicon")
```

You're now set! You've successfully initiated the project and can go to dev/02_dev.R.

```{r eval = FALSE}
rstudioapi::navigateToFile("dev/02_dev.R")
```

## Day to Day Dev with `{golem}`

Now that you're all set with your project init, time to move to development :) 

App development should happen through the `dev/02_dev.R` file, which contains common commands for developping. 

## Launching the app

To run the app, go to the `dev/run_dev.R` file, and run the all thing.

## `dev/02_dev.R`

### Add modules

The `golem::add_module()` functions creates a module in the `R` folder. The file and the modules will be named after the `name` parameter, by adding `mod_` to the R file, and `mod_*_ui` and `mod_*_server` to the UI and server functions.

```{r eval = FALSE}
golem::add_module(name = "my_first_module") # Name of the module
```

The new file will contain:

```{r eval = FALSE}
# mod_UI
mod_my_first_module_ui <- function(id){
  ns <- NS(id)
  tagList(
  
  )
}

mod_my_first_module_server <- function(input, output, session){
  ns <- session$ns
}
    
## To be copied in the UI
# mod_my_first_module_ui("my_first_module_1")
    
## To be copied in the server
# callModule(mod_my_first_module_server, "my_first_module_1")
```

In order not to make errors when putting these into your app, the end of the file will contain code that has to be copied and pasted inside your UI and server functions. 

### Add dependencies

To be called each time you need a new package as a dependency:

```{r eval = FALSE}
usethis::use_package("pkg")
```

### Add tests

Add more tests to your application:

```{r eval = FALSE}
usethis::use_test("app")
```

### Add a browser button

Learn more about this: https://rtask.thinkr.fr/blog/a-little-trick-for-debugging-shiny/

```{r eval = FALSE}
golem::browser_button()
```

### Add external files

These functions create external dependencies (JavaScript and CSS). `add_js_file()` creates a simple JavaScript file, while `add_js_handler()` adds a file with a skeleton for shiny custom handlers.

```{r eval = FALSE}
golem::add_js_file("script")
golem::add_js_handler("script")
golem::add_css_file("custom")
```

## Adding these external resources to your app

You can add any external resource (JS, css) into `inst/app/www`. 

Then, You'll need to point to these external resources in `golem_add_external_resources()`. For example, if you've created a CSS file with `golem::add_css_file("custom")`, you can add the file with:

``` r
tags$link(rel="stylesheet", type="text/css", href="www/custom.css")
```

Also, you can list here the use of other packages, for example `useShinyalert()` from the `{shinyalert}` package.

Note: we've chosen to leave it "raw", in the sense that there is a `addResourcePath` and a `tags$head`. If you're comfortable with `{htmltools}`, you can build a `htmltools::htmlDependency`. 

## Documentation

### Vignette

```{r eval = FALSE}
usethis::use_vignette("shinyexample")
devtools::build_vignettes()
```

### Code coverage

```{r eval = FALSE}
usethis::use_travis()
usethis::use_appveyor()
usethis::use_coverage()
```

## Using `{golem}` dev functions

There's a series of tools to make your app behave differently whether it's in dev or prod mode. Notably, the `app_prod()` and `app_dev()` function tests for `options( "golem.app.prod")` (or return TRUE if this option doesn't exist). 

Setting this options at the beginning of your dev process allows to make your app behave in a specific way when you are in dev mode. For example, printing message to the console with `cat_dev()`.

```{r eval = TRUE}
options( "golem.app.prod" = TRUE)
golem::cat_dev("hey\n")
options( "golem.app.prod" = FALSE)
golem::cat_dev("hey\n")
```

You can then make any function being "dev-dependant" with the `make_dev()` function: 

```{r eval = TRUE}
log_dev <- golem::make_dev(log)
log_dev(10)
options( "golem.app.prod" = TRUE)
log_dev(10)
```

## Deploying Apps with `{golem}`

The `dev/03_deploy.R` file contains function for deploying on various plateforms. 

### RStudio Connect

To create an `app.R` ready to be deployed on RStudio Connect, run:

```{r eval = FALSE}
golem::add_rconnect_file()
```

### Docker 

You can create a generic Dockerfile, or one which is plateform specific (for now, only ShinyProxy and Heroku are supported).

```{r eval = FALSE}
# If you want to deploy via a generic Dockerfile
golem::add_dockerfile()

# If you want to deploy to ShinyProxy
golem::add_shinyproxy_dockerfile()

# If you want to deploy to Heroku
golem::add_heroku_dockerfile()
```

## Using `{golem}` js functions

`{golem}` comes with a series of JavaScript functions that you can call from the server. These functions are added by default with `golem::js()` in `app_ui`.


Then they arer called with `session$sendCustomMessage("fonction", "ui_element")`.

This `ui_element` define the UI element to interact with. It can be a full jQuery selector, an id or a class.

### `golem::js()`

+ `showid` & `hideid`, `showclass` & `hideclass` show and hide elements through their id or class.

```{r eval = FALSE}
session$sendCustomMessage("showid", ns("plot"))
```

+ `showhref` & `hidehref` hide and show a link by trying to match the `href` content.

```{r eval = FALSE}
session$sendCustomMessage("showhref", "panel2")
```

+ `clickon` click on the element. You have to use the full jQuery selector. 

+ `show` & `hide` show and hide elements, using the full jQuery selector.

### About jQuery selectors

+ `#plop`: the element with the id `plop`

+ `.pouet`: elements of class `pouet`

+ `"button:contains('this')"`: buttons with a text containing `'this'`

Note that in html, tags contains attributes. For example:

``` html
<a href = "https://thinkr.fr" data-value = "panel2">ThinkR</a>
```

contains `href` & `data-value`. You can refer to these attributes with `[]` after the tag name.

+ `a[href = "https://thinkr.fr"]`: link with `href` being `https://thinkr.fr`

+ `a[data-value="panel2"]`: link with  `data-value` being `"panel2"`


